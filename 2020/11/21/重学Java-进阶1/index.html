<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>重学Java-进阶(1/2) | CPPRTO</title><meta name="description" content="引言【因内容较多，将拆分为两篇博文，此为篇一】本篇博文为 Java 的一些高级特性的常见概念及相关细节梳理，意在重学 Java 查漏补缺。博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。 多线程概念程序、进程、线程程序(Program)：为完成特定任务，使用某种编程语言编写的一组指令的集合。即指一段静态的"><meta name="keywords" content="Java"><meta name="author" content="cpprto"><meta name="copyright" content="cpprto"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cpprto.gitee.io/2020/11/21/%E9%87%8D%E5%AD%A6Java-%E8%BF%9B%E9%98%B61/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="重学Java-进阶(1/2)"><meta property="og:url" content="https://cpprto.gitee.io/2020/11/21/%E9%87%8D%E5%AD%A6Java-%E8%BF%9B%E9%98%B61/"><meta property="og:site_name" content="CPPRTO"><meta property="og:description" content="引言【因内容较多，将拆分为两篇博文，此为篇一】本篇博文为 Java 的一些高级特性的常见概念及相关细节梳理，意在重学 Java 查漏补缺。博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。 多线程概念程序、进程、线程程序(Program)：为完成特定任务，使用某种编程语言编写的一组指令的集合。即指一段静态的"><meta property="og:image" content="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><meta property="article:published_time" content="2020-11-21T21:31:46.000Z"><meta property="article:modified_time" content="2020-11-22T00:33:37.000Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?69d8bd2de8f48be7e268be5386f98dc5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-11-22 00:33:37'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/09/21/wqn7cV.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">程序、进程、线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8-CPU%E3%80%81%E5%A4%9A%E6%A0%B8-CPU"><span class="toc-number">2.1.2.</span> <span class="toc-text">单核 CPU、多核 CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.4.</span> <span class="toc-text">多线程的优点与使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.5.</span> <span class="toc-text">线程的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%BA%8E-Thread-%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建线程方式一：继承于 Thread 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">创建线程方式二：实现 Runnable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3-JDK5-0%E6%96%B0%E5%A2%9E"><span class="toc-number">2.2.3.</span> <span class="toc-text">创建线程方式三：实现 Callable 接口 (JDK5.0新增)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0-JDK5-0%E6%96%B0%E5%A2%9E"><span class="toc-number">2.2.4.</span> <span class="toc-text">创建线程方式四：使用线程池 (JDK5.0新增)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">Thread 类的常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.6.</span> <span class="toc-text">线程的调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.</span> <span class="toc-text">线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">线程同步方式一：同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">线程同步方式二：同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9ALock-%E9%94%81"><span class="toc-number">2.4.3.</span> <span class="toc-text">线程同步方式三：Lock(锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.4.</span> <span class="toc-text">线程的死锁问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.5.</span> <span class="toc-text">关于锁的小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.6.</span> <span class="toc-text">线程的通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">字符串相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">String 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">String 对象的创建：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%9A%84%E6%8B%BC%E6%8E%A5%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">String 的拼接特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">String 常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.5.</span> <span class="toc-text">String 与其他类型之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer-%E5%92%8C-StringBuilder"><span class="toc-number">3.1.6.</span> <span class="toc-text">StringBuffer 和 StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8-%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="toc-number">3.2.</span> <span class="toc-text">JDK8 之前的日期时间 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-System-%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">java.lang.System 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Date-%E7%B1%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">java.util.Date 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-text-SimpleDateFormat-%E7%B1%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">java.text.SimpleDateFormat 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-Calendar-%E7%B1%BB-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-number">3.2.4.</span> <span class="toc-text">java.util.Calendar 类(日历类)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8-%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="toc-number">3.3.</span> <span class="toc-text">JDK8 中新的日期时间 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-time"><span class="toc-number">3.3.1.</span> <span class="toc-text">java.time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-time-format-DateTimeFormatter-%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">java.time.format.DateTimeFormatter 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-API"><span class="toc-number">3.3.3.</span> <span class="toc-text">其他 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E9%81%97%E7%95%99%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.4.</span> <span class="toc-text">与遗留日期处理类的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">Java 比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Comparable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.1.</span> <span class="toc-text">java.lang.Comparable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-Comparator"><span class="toc-number">3.4.2.</span> <span class="toc-text">java.lang.Comparator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">System 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">Math 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger-%E4%B8%8E-BigDecimal"><span class="toc-number">3.7.</span> <span class="toc-text">BigInteger 与 BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger"><span class="toc-number">3.7.1.</span> <span class="toc-text">BigInteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal"><span class="toc-number">3.7.2.</span> <span class="toc-text">BigDecimal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">定义枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">Enum 中的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-enum-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.3.</span> <span class="toc-text">使用 enum 关键字定义的枚举类实现接口的情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-number">5.</span> <span class="toc-text">注解(Annotation)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">常见注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">自定义注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E4%B8%AD%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">JDK 中的元注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8-%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.4.</span> <span class="toc-text">JDK8 中注解的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.4.1.</span> <span class="toc-text">可重复注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.4.2.</span> <span class="toc-text">类型注解</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://s1.ax1x.com/2020/09/22/wXA4RP.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CPPRTO</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">重学Java-进阶(1/2)</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-21T21:31:46.000Z" title="发表于 2020-11-21 21:31:46">2020-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-22T00:33:37.000Z" title="更新于 2020-11-22 00:33:37">2020-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>【因内容较多，将拆分为两篇博文，此为篇一】<br>本篇博文为 Java 的一些高级特性的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="程序、进程、线程"><a href="#程序、进程、线程" class="headerlink" title="程序、进程、线程"></a>程序、进程、线程</h3><p><strong>程序(Program)：</strong>为完成特定任务，使用某种编程语言编写的一组指令的集合。即指一段静态的代码，静态对象</p>
<p><strong>进程(Process)：</strong>指程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程 —— 生命周期</p>
<ul>
<li>如：运行中的 Edge 浏览器、Chrome 浏览器</li>
<li>程序是静态的，进程是动态的</li>
<li><strong>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</strong></li>
</ul>
<p><strong>线程(Thread)：</strong>进程可进一步细化为线程，是一个程序内部的一条执行路径</p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li><strong>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</strong></li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间(它们从同一堆中分配对象，可以访问相同的变量和对象，使得线程间通信更便捷、高效。但多个线程操作共享的系统资源可能会带来安全隐患)</li>
</ul>
<h3 id="单核-CPU、多核-CPU"><a href="#单核-CPU、多核-CPU" class="headerlink" title="单核 CPU、多核 CPU"></a>单核 CPU、多核 CPU</h3><p>单核 CPU 中其实是一种假的多线程，因为在一个时间单元内，只能执行一个线程的任务</p>
<ul>
<li>多个任务只能由一个 CPU 进行处理，将正在执行中的任务”挂起”之后再去执行其他的任务，如此轮转。因为 CPU 时间单元特别短，因此感觉不出任务的切换</li>
<li>多核 CPU 才能更好的发挥多线程的效率</li>
<li>一个 Java 应用程序其实至少有三个线程：main() 主线程，gc() 垃圾回收线程，异常处理线程(如果发生异常，会影响主线程)</li>
</ul>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li><strong>并行：</strong>多个 CPU 同时执行多个任务(多个人同时做不同的事)</li>
<li><strong>并发：</strong>一个 CPU(采用时间片轮转)同时执行多个任务(多个人做同一件事)</li>
</ul>
<h3 id="多线程的优点与使用场景"><a href="#多线程的优点与使用场景" class="headerlink" title="多线程的优点与使用场景"></a>多线程的优点与使用场景</h3><p><strong>优点：</strong></p>
<ul>
<li>提高应用程序的响应</li>
<li>提高计算机系统 CPU 的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>程序需要同时执行两个或多个任务</li>
<li>程序需要实现一些需要等待的任务时</li>
<li>需要一些后台运行的程序时</li>
</ul>
<h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><p>Java 中的线程分为两类：一种是守护线程，一种是用户线程</p>
<ul>
<li>它们几乎每方面都是相同的，唯一的区别是判断 JVM 何时离开</li>
<li>守护线程是用来服务用户线程的，通过在 start() 方法前调用 thread.setDaemon(true) 可以把一个用户线程变成一个守护线程</li>
<li>Java 垃圾回收就是一个典型的守护线程</li>
<li>若 JVM 中都是守护线程，当前 JVM 将退出</li>
</ul>
<h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><p><strong>多线程的创建</strong></p>
<h3 id="创建线程方式一：继承于-Thread-类"><a href="#创建线程方式一：继承于-Thread-类" class="headerlink" title="创建线程方式一：继承于 Thread 类"></a>创建线程方式一：继承于 Thread 类</h3><ul>
<li>创建一个继承于 Thread 类的子类</li>
<li>重写 Thread 类的 run() 方法</li>
<li>创建 Thread 类的子类的对象</li>
<li>通过此子类对象调用 start() 方法：<ul>
<li>启动当前线程</li>
<li>调用当前线程的 run() 方法</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>不能通过直接调用 run() 的方式启动线程</li>
<li>不可以让已经 threadSubObj.start() 的线程再去执行启动线程( threadSubObj.start() )的操作。会报错：IllegalThreadStateException</li>
</ul>
<h3 id="创建线程方式二：实现-Runnable-接口"><a href="#创建线程方式二：实现-Runnable-接口" class="headerlink" title="创建线程方式二：实现 Runnable 接口"></a>创建线程方式二：实现 Runnable 接口</h3><ul>
<li>创建一个实现了 Runnable 接口的类</li>
<li>实现类去实现 Runnable 中的抽象方法：run() 方法</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象</li>
<li>通过这个 Thread 类的对象调用 start() 方法：<ul>
<li>启动当前线程</li>
<li>调用当前线程的 run() 方法(调用了 Runnable 类型的 target 的 run() 方法)</li>
</ul>
</li>
</ul>
<p><strong>创建线程的两种方式的比较：</strong></p>
<ul>
<li>开发中：优先选择实现 Runnable 接口的方式<ul>
<li>实现的方式没有类的单继承的局限性</li>
<li>实现的方式更适合用来处理多个线程有共享数据的情况</li>
</ul>
</li>
<li>两种实现方式的联系：( Thread 类也是 Runnable 的实现类 ) public class Thread implements Runnable</li>
<li>相同点：两种方式都需要重写 run() 方法，将线程要执行的逻辑声明在 run() 方法中</li>
</ul>
<h3 id="创建线程方式三：实现-Callable-接口-JDK5-0新增"><a href="#创建线程方式三：实现-Callable-接口-JDK5-0新增" class="headerlink" title="创建线程方式三：实现 Callable 接口 (JDK5.0新增)"></a>创建线程方式三：实现 Callable 接口 (JDK5.0新增)</h3><ul>
<li><code>import java.util.concurrent.Callable;</code></li>
<li>创建一个实现 Callable 接口的实现类</li>
<li>实现 call() 方法，将此线程需要执行的操作声明在 call() 方法中</li>
<li>创建 Callable 接口实现类的对象</li>
<li>将此 Callable 接口实现类的对象作为参数传递到 FutureTask 构造器中，创建 FutureTask 的对象</li>
<li>将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start() 方法</li>
<li>(可选)获取 Callable 中 call() 方法的返回值<br>get() 返回值即为 FutureTask 构造器参数 —— Callable 实现类重写的 call() 的返回值</li>
</ul>
<p><strong>与使用 Runnable 相比，Callable 功能更强，针对 Callable：</strong></p>
<ul>
<li>相比 run() 方法，call() 方法可以有返回值</li>
<li>call() 方法可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable 支持泛型的返回值</li>
<li>需要借助 FutureTask 类，比如获取返回结构</li>
</ul>
<p><strong>Future 接口：</strong></p>
<ul>
<li>可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完成、获取结果等</li>
<li>FutureTask 是 Future 接口的唯一的实现类</li>
<li>FutureTask 同时实现了 Runnable，Future 接口。它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值</li>
</ul>
<h3 id="创建线程方式四：使用线程池-JDK5-0新增"><a href="#创建线程方式四：使用线程池-JDK5-0新增" class="headerlink" title="创建线程方式四：使用线程池 (JDK5.0新增)"></a>创建线程方式四：使用线程池 (JDK5.0新增)</h3><p>开发中线程是经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。若提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p>
<p>JDK5.0起提供了线程池相关 API：ExecutorService 和 Executors</p>
<ul>
<li>ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行 Runnable</li>
<li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般用来执行 Callable</li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n)：创建一个可重用的固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</li>
</ul>
</li>
</ul>
<p><strong>创建及使用：</strong></p>
<ul>
<li><p><code>import java.util.concurrent.ExecutorService;</code><br><code>import java.util.concurrent.Executors;</code><br><code>import java.util.concurrent.ThreadPoolExecutor;</code></p>
</li>
<li><p>提供指定线程数量的线程池(ExecutorService service = Executors.newFixedThreadPool(nThreads: 10); )</p>
</li>
<li><p>执行指定的线程的操作。需要提供实现 Runnable 接口或 Callable 接口实现类的对象</p>
<ul>
<li>service.executer(Runnable runnable);  适用于 Runnable</li>
<li>service.submit(Callable callable); 适用于 Callable</li>
</ul>
</li>
<li><p>关闭连接池(service.shutdown(); )</p>
</li>
</ul>
<p><strong>线程池的优点：</strong></p>
<ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
<h3 id="Thread-类的常见方法"><a href="#Thread-类的常见方法" class="headerlink" title="Thread 类的常见方法"></a>Thread 类的常见方法</h3><ul>
<li>void start()：启动线程，并执行对象的 run() 方法</li>
<li>run()：线程在被调度时执行的操作<ul>
<li>通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中</li>
</ul>
</li>
<li>static Thread currentThread()：返回当前线程。在 Thread 子类中就是 this，通常用于主线程和 Runnable 实现类<ul>
<li>静态方法，返回执行当前代码的线程</li>
</ul>
</li>
<li>String getName()：返回该线程的名称<ul>
<li>获取当前线程的名称</li>
</ul>
</li>
<li>void setName(String name)：设置该线程名称<ul>
<li>设置当前线程的名称</li>
</ul>
</li>
<li>static void yield()：线程让步<ul>
<li>释放当前 CPU 的执行权</li>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</li>
<li>join()：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<ul>
<li>在线程 thread1 中调用线程 thread2 的 join()，此时线程 thread1 就进入阻塞状态，直到线程 thread2 完全执行完成后，线程 thread1 才结束阻塞状态</li>
<li>低优先级的线程也可以获得执行</li>
</ul>
</li>
<li>static void sleep(long millis)：(指定时间：毫秒)<ul>
<li>让当前线程”睡眠”指定的毫秒。在指定的毫秒时间内，当前线程是阻塞状态</li>
<li>令当前活动线程在指定时间段内放弃对 CPU 控制，使其他线程有机会被执行，时间到后重新排队</li>
<li>抛出 InterruptedException 异常(需要使用 try-catch)</li>
</ul>
</li>
<li>stop()：强制线程生命期结束，不推荐使用(已过时)<ul>
<li>当执行此方法时，强制结束当前线程</li>
</ul>
</li>
<li>boolean isAlive()：判断线程是否还活着</li>
</ul>
<h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p><strong>调度策略：</strong></p>
<ul>
<li>时间片</li>
<li>抢占式：高优先级的线程抢占 CPU</li>
</ul>
<p><strong>Java 的调度方法：</strong></p>
<ul>
<li>同优先级线程组成先进先出队列(先到先服务)，使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p><strong>线程的优先级：</strong></p>
<ul>
<li>现成的优先级等级：<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN_PRIORITY：1</li>
<li>NORM_PRIORITY：5 (默认优先级)</li>
</ul>
</li>
<li>涉及的方法：<ul>
<li>getPriority()：返回线程优先值</li>
<li>setPriority(int newPriority)：改变线程的优先级</li>
</ul>
</li>
<li>说明：<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
<li>高优先级的线程要抢占低优先级线程 CPU 的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后低优先级的线程才执行</li>
</ul>
</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>JDK 中用 Thread.State 类定义了线程的几种状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java 语言使用 Thread 类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建(new)：当一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被 start() 后将进入线程队列等待 CPU 时间片，此时它已具备了运行的条件，只是没有分配到 CPU 资源</li>
<li>运行：当就绪的线程被调度并获得 CPU 资源时，便进入运行状态，run() 方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时终止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地终止或出现异常导致结束</li>
</ul>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p><strong>线程存在的问题：</strong></p>
<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对数据的共享，会造成操作的不完整性，会破坏数据</li>
</ul>
<p><strong>Java 中通过同步机制来解决线程的安全问题</strong></p>
<h3 id="线程同步方式一：同步代码块"><a href="#线程同步方式一：同步代码块" class="headerlink" title="线程同步方式一：同步代码块"></a>线程同步方式一：同步代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器) &#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>操作共享数据的代码，即为需要被同步的代码<br>共享数据：多个线程共同操作的变量(数据)</li>
<li>同步监视器，俗称：”锁”。任何一个类的对象，都可以充当锁<br>要求：多个线程必须要共用同一把锁</li>
<li>补充：<ul>
<li>在实现 Runnable 接口创建多线程的方式中，可以考虑使用 this 充当同步监视器</li>
<li>在继承于 Thread 类创建多线程的方式中，可以考虑使用当前类本身(ClassX.clss)充当同步监视器</li>
</ul>
</li>
</ul>
<h3 id="线程同步方式二：同步方法"><a href="#线程同步方式二：同步方法" class="headerlink" title="线程同步方式二：同步方法"></a>线程同步方式二：同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，可以将此方法声明为同步的</p>
<p><strong>关于同步方法的总结：</strong></p>
<ul>
<li>同步方法仍然涉及同步监视器，只是不需要显式的声明</li>
<li>非静态的同步方法，同步监视器是：this<br>静态的同步方法，同步监视器是：当前类本身</li>
</ul>
<h3 id="线程同步方式三：Lock-锁"><a href="#线程同步方式三：Lock-锁" class="headerlink" title="线程同步方式三：Lock(锁)"></a>线程同步方式三：Lock(锁)</h3><ul>
<li>从 JDK5.0开始，Java 提供了更强大的线程同步机制 —— 通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当</li>
<li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具<ul>
<li>锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象</li>
</ul>
</li>
<li>ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock，可以显式加锁、释放锁</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 实例化 ReentrantLock</span></span><br><span class="line">    <span class="comment">// 参数 fair: 默认为 false 表示不公平的; true 表示公平的，即先进先出</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.Lock();</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized 与 Lock 的异同：</strong></p>
<ul>
<li>相同：二者都可以解决线程安全问题</li>
<li>不同：<ul>
<li>synchronized 机制在执行完相应的同步代码以后，自动的释放同步监视器</li>
<li>Lock 需要手动的启动( lock() )，同时结束同步也需要手动实现( unlock() )</li>
</ul>
</li>
</ul>
<p><strong>synchronized 与 Lock 的对比：</strong></p>
<ul>
<li>Lock 是显式锁(手动开启和关闭锁)，synchronized 是隐式锁，出了作用域自动释放</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)</li>
<li>优先使用顺序：Lock -&gt; 同步代码块(已经进入了方法体，分配了相应资源) -&gt; 同步方法(在方法体之外)</li>
</ul>
<p><strong>线程同步的局限性：</strong>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低</p>
<h3 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h3><p><strong>死锁：</strong></p>
<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
<h3 id="关于锁的小结"><a href="#关于锁的小结" class="headerlink" title="关于锁的小结"></a>关于锁的小结</h3><p><strong>释放锁的操作：</strong></p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步方法、同步代码块中遇到 break、return 终止了该方法、该代码块的继续执行</li>
<li>当前线程在同步方法、同步代码块中出现了未处理的 Error 或 Exception，导致异常结束</li>
<li>当前线程在同步方法、同步代码块中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁</li>
</ul>
<p><strong>不会释放锁的操作：</strong></p>
<ul>
<li>线程执行同步方法或同步代码块时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁(同步监视器)<ul>
<li>应尽量避免使用 suspend() 和 resume() 来控制线程</li>
</ul>
</li>
</ul>
<h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><p><strong>例子：</strong>交替打印、生产者消费者</p>
<p><strong>涉及到的三个方法：</strong></p>
<ul>
<li>wait()：一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器</li>
<li>notify()：一旦执行此方法，就会唤醒被 wait() 的一个线程。如果有多个线程被 wait，就唤醒优先级高的线程</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被 wait 的线程</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>wait()、notify()、notifyAll() 这三个方法必须使用在同步代码块或同步方法中</li>
<li>wait()、notify()、notifyAll() 这三个方法的调用者必须是同步代码块或同步方法中的同步监视器<br>否则，会出现 IllegalMonitorStateException 异常</li>
<li>wait()、notify()、notifyAll() 这三个方法定义在 java.lang.Object 类中</li>
</ul>
<p><strong>sleep() 和 wait() 的异同：</strong></p>
<ul>
<li><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态</p>
</li>
<li><p>不同点：</p>
<ul>
<li>两个方法声明的位置不同：<ul>
<li>Thread 类中声明 sleep()</li>
<li>Object 类中声明 wait()</li>
</ul>
</li>
<li>调用的要求不同：<ul>
<li>sleep() 可以在任何需要的场景下调用</li>
<li>wait() 必须使用在同步代码块或同步方法中</li>
</ul>
</li>
<li>关于是否释放同步监视器(锁)：<ul>
<li>如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放、wait() 会释放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>String 类：代表字符串。Java 程序中的所有字符串字面值(如”str”)都为此类的实例实现</p>
<ul>
<li>String 实现了 Serializable 接口：表示字符串是支持序列化的</li>
<li>String 内部定义了 final char[] value 用于存储字符串数据。String 代表不可变的字符序列(不可变性)<ul>
<li>当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li>
<li>当对现有的字符串进行连接操作时，需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li>
<li>当调用 String 的 replace() 方法修改指定字符或字符串时，需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li>
</ul>
</li>
<li>通过字面量的方式(区别于 new)给一个字符串赋值，此时的字符串值声明在字符串常量池中</li>
<li>字符串常量池中不会存储相同内容的字符串</li>
<li>字符串是常量，用双引号引起来表示。值在创建之后不能更改</li>
</ul>
<h3 id="String-对象的创建："><a href="#String-对象的创建：" class="headerlink" title="String 对象的创建："></a>String 对象的创建：</h3><ul>
<li>通过字面量定义的方式：此时变量指向的数据声明在方法区中的字符串常量池中</li>
<li>通过 new + 构造器的方式：此时变量指向数据在堆空间中开辟空间以后对应的地址值</li>
<li><strong>因此会有如下结果：</strong><br>String s1 = “str”;String s2 = “str”;<br>String s3 = new String(“str”);String s4 = new String(“str”);<br>s1 == s2 结果为 true、s1 == s3 结果为 false、s3 == s4 结果为 false</li>
<li>字符串常量存储在字符串常量池，目的是共享</li>
<li>字符串非常量对象存储在堆中</li>
<li>String s = new String(“str”); 方式创建对象，在内存中创建了两个对象：<ul>
<li>一个是堆空间中 new 结构</li>
<li>另一个是 char[] 对应的常量池中的数据：”str”</li>
</ul>
</li>
</ul>
<h3 id="String-的拼接特性："><a href="#String-的拼接特性：" class="headerlink" title="String 的拼接特性："></a>String 的拼接特性：</h3><ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量</li>
<li>只要其中一个是变量，结果就在堆中</li>
<li>如果拼接的结果调用 intern() 方法，返回值就在常量池中 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过字面量定义的方式</span></span><br><span class="line">String str0 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上：this.value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上：this.value = original.value;</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(String original);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上：this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>

<h3 id="String-常用方法："><a href="#String-常用方法：" class="headerlink" title="String 常用方法："></a>String 常用方法：</h3><ul>
<li>int length()：返回字符串的长度：return value.length</li>
<li>char charAt(int index)：返回某索引处的字符：return value[index]</li>
<li>boolean isEmpty()：判断是否是空字符串：return value.length == 0</li>
<li>String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写</li>
<li>String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为小写</li>
<li>String trim()：返回字符串的副本，忽略前导空白和尾部空白</li>
<li>boolean equals(Object obj)：比较字符串的内容是否相同</li>
<li>boolean equalsIgnoreCase(String anotherString)：与 equals 方法类似，忽略大小写</li>
<li>String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用 “+”</li>
<li>int compareTo(String anotherString)：比较两个字符串的大小</li>
<li>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串</li>
<li>String substring(int beginIndex, int endIndex)：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到 endIndex(不包含)的一个子字符串</li>
<li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</li>
<li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</li>
<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</li>
<li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</li>
<li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最后出现处的索引</li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后出现处的索引，从指定的索引开始反向搜索<br>indexOf 和 lastIndexOf 方法如果未找到都是返回 -1</li>
<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</li>
<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</li>
<li>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串</li>
<li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</li>
<li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式</li>
<li>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串</li>
<li>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过 limit 个，如果超过了，剩下的全部拼接为一个元素</li>
</ul>
<h3 id="String-与其他类型之间的转换"><a href="#String-与其他类型之间的转换" class="headerlink" title="String 与其他类型之间的转换"></a>String 与其他类型之间的转换</h3><p><strong>字符串与基本数据类型、包装类之间的相互转换：</strong></p>
<ul>
<li>字符串 -&gt; 基本数据类型、包装类：<ul>
<li>调用包装类的静态方法</li>
</ul>
</li>
<li>基本数据类型、包装类 -&gt; 字符串：<ul>
<li>调用 String 重载的 valueOf() 方法</li>
</ul>
</li>
</ul>
<p><strong>字符串与字符数组之间的相互转换：</strong></p>
<ul>
<li>字符数组 -&gt; 字符串：<ul>
<li>String 类的构造器 String(char[])：用字符数组中的全部字符创建字符串对象</li>
<li>String(char[], int offset, int length)：用部分字符创建字符串对象</li>
</ul>
</li>
<li>字符串 -&gt; 字符数组：<ul>
<li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法</li>
<li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：将指定索引范围内的字符串存放到字符数组中的方法</li>
</ul>
</li>
</ul>
<p><strong>字符串与字节数组之间的相互转换：</strong></p>
<ul>
<li>字节数组 -&gt; 字符串：<ul>
<li>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String</li>
<li>String(byte[], int offset, int length)：用指定的字节数组的一部分，即从数组的起始位置 offset 开始取 length 个字节构造一个字符串对象</li>
</ul>
</li>
<li>字符串 -&gt; 字节数组：<ul>
<li>public byte[] getBytes()：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</li>
<li>public byte[] getBytes(String charsetName)：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组</li>
<li>解码时要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码</li>
</ul>
</li>
</ul>
<h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><p><strong>String、StringBuffer、StringBuilder 三者的异同：</strong></p>
<ul>
<li>String：不可变的字符序列：底层使用 char[] 存储</li>
<li>StringBuffer：可变的字符序列：线程安全的，效率较低，底层使用 char[] 存储</li>
<li>StringBuilder：可变的字符序列：jdk5.0 新增，线程不安全的，效率较高，底层使用 char[] 存储</li>
</ul>
<p><strong>StringBuffer 和 StringBuilder 的常用方法：</strong></p>
<ul>
<li>StringBuffer append(参数列表)：提供了一些 append() 方法，用于进行字符串拼接</li>
<li>StringBuffer delete(int start, int end)：删除指定位置的内容</li>
<li>StringBuffer replace(int start, int end, String str)：把[start, end) 位置(左闭右开，包含左不包含右)替换为 str</li>
<li>StringBuffer insert(int offset, xxx)：在指定位置插入 xxx</li>
<li>StringBuffer reverse()：把当前字符序列逆转</li>
<li>当 append 和 insert 时，如果原来 value 数组长度不够，可扩容</li>
<li>如上方法支持方法链操作(sB.append(“a”).append(“b”).append(“c”))</li>
</ul>
<p>方法链原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8-之前的日期时间-API"><a href="#JDK8-之前的日期时间-API" class="headerlink" title="JDK8 之前的日期时间 API"></a>JDK8 之前的日期时间 API</h2><h3 id="java-lang-System-类"><a href="#java-lang-System-类" class="headerlink" title="java.lang.System 类"></a>java.lang.System 类</h3><p>System 类提供的 public static currentTimeMillis() 用来返回当前时间与 1970 年 1 月 1 日 0 时 0 分 0 秒之间以毫秒为单位的时间差(时间戳)</p>
<ul>
<li>此方法适于计算时间差</li>
</ul>
<p><strong>计算世界时间的主要标准：</strong></p>
<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
<h3 id="java-util-Date-类"><a href="#java-util-Date-类" class="headerlink" title="java.util.Date 类"></a>java.util.Date 类</h3><p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li>构造器：<ul>
<li>Date()：使用无参构造器创建的对象可以获取本地当时时间</li>
<li>Date(long date)：创建指定毫秒数的 Date 对象</li>
</ul>
</li>
<li>常用方法：<ul>
<li>getTime()：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</li>
<li>toString()：把此 Date 对象转换为以下形式的String：dow mon dd hh:mm:ss zzz yyyy 其中：dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri、Sat)，zzz 是时间标准</li>
<li>其他很多方法已过时</li>
</ul>
</li>
</ul>
<h3 id="java-text-SimpleDateFormat-类"><a href="#java-text-SimpleDateFormat-类" class="headerlink" title="java.text.SimpleDateFormat 类"></a>java.text.SimpleDateFormat 类</h3><p>Date 类的 API 不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化：日期 -&gt; 文本，解析：文本 -&gt; 日期</p>
<p><strong>格式化：</strong></p>
<ul>
<li>SimpleDateFormat()：默认的模式和语言环境创建对象</li>
<li>public SimpleDateFornat(String pattern)：该构造方法可以用参数 pattern 指定的格式创建一个对象，该对象调用：<ul>
<li>public String format(Date date)：方法格式化事件对象 date</li>
</ul>
</li>
</ul>
<p><strong>解析：</strong></p>
<ul>
<li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期</li>
<li>解析要求字符串必须是符合 SimpleDateFormat 识别的格式(通过构造器参数体现)</li>
</ul>
<h3 id="java-util-Calendar-类-日历类"><a href="#java-util-Calendar-类-日历类" class="headerlink" title="java.util.Calendar 类(日历类)"></a>java.util.Calendar 类(日历类)</h3><p>Calendar 是一个抽象基类，主要用于完成日期字段之间相互操作的功能</p>
<p>获取 Calendar 实例的方法：</p>
<ul>
<li>使用 Calendar.getInstance() 方法</li>
<li>调用它的子类 GregorianCalendar 的构造器</li>
</ul>
<p>一个 Calendar 的实例是系统时间的抽象表示，通过 get(int field) 方法来取得想要的时间信息。比如 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</p>
<ul>
<li>public void set(int field, int value)：将指定 field 设置成新的值</li>
<li>public void add(int field, int amount)：将指定 field 增加 amount、减少可以使用负的 amount</li>
<li>public final Date getTime()：通过日历类获取 Date 对象</li>
<li>public final void setTime(Date date)：将 Date 的对象的时间设置成日历类的时间</li>
<li>注意：<ul>
<li>获取月份时：一月是 0、二月是 1，以此类推</li>
<li>获取星期时：周日是1、周二是 2，以此类推</li>
</ul>
</li>
</ul>
<h2 id="JDK8-中新的日期时间-API"><a href="#JDK8-中新的日期时间-API" class="headerlink" title="JDK8 中新的日期时间 API"></a>JDK8 中新的日期时间 API</h2><p>Date 与 Calendar 面临的问题：</p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的</li>
<li>偏移性：Date 中的年份是从 1900 开始的，二月份都从 0 开始</li>
<li>格式化：格式化只对 Date 有用，Calendar 则不行</li>
<li>此外它们也不是线程安全的、不能处理闰秒等</li>
<li>闰秒：指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中(也可能在季末)对协调世界时增加或减少 1 秒的调整</li>
</ul>
<h3 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h3><p><strong>java.time：</strong>包含值对象的基础包</p>
<p>java.time 中包含了所有关于：本地日期(LocalDate)、本地时间(LocalTime)、本地日期时间(LocalDateTime)、时区(ZonedDateTime)和持续时间(Duration)的类</p>
<p>LocalDate、LocalTime、LocalDateTime 它们的实例是不可变的对象，它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息</p>
<ul>
<li>LocalDate 代表 ISO 格式(yyy-MM-dd)的日期</li>
<li>LocalTime 表示一个时间</li>
<li>LocalDateTime 用来表示日期和时间</li>
<li>注：ISO-8601 日历系统是国际标准化组织制定的现代公民的日期和时间的表示法(公历)</li>
</ul>
<p><strong>关于 LocalDate、LocalTime、LocalDateTime 类创建对象及其对象的相关方法：</strong></p>
<ul>
<li>now() / now(ZoneId zone)：静态方法，根据当前时间创建对象 / 指定时区的对象<br>获取当前的日期、时间、日期+时间</li>
<li>of()：静态方法，根据指定日期/时间创建对象<br>设置指定的年、月、日、时、分、秒。没有偏移量</li>
<li>getDayOfMonth() / getDayOfYear()：获得月份天数(1-31) / 获得年份天数(1-366)</li>
<li>getDayOfWeek()：获得星期几(返回一个 DayOfWeek 枚举类)</li>
<li>getMonth()：获得月份(返回一个 Month 枚举类)</li>
<li>getMonthValue() / getYear()：获得月份(1-12) / 获得年份</li>
<li>getHour() / getMinute() / getSecond()：获得当前对象对应的小时、分钟、秒</li>
<li>withDayOfMonth() / withDayOfYear() / withMonth() / withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</li>
<li>plusDays() / plusWeeks() / plusMonths() / plusYears() / plusHours()：向当前对象增加几天、几周、几个月、几年、几小时</li>
<li>minusDays() / minusWeeks() / minusMonths() / minusYears() / minusHours()：向当前对象减去几天、几周、几个月、几年、几小时</li>
</ul>
<p><strong>Instant(瞬时)：</strong>时间线上的一个瞬时点</p>
<ul>
<li><p>只是简单的表示自 1970 年 1 月 1 日 0 分 0 秒(UTC) 开始的秒数)</p>
</li>
<li><p>因为 java.time 包是基于纳秒计算的，所以 Instant 的精度可以达到纳秒级(1 ns = 10^(-9) s、1秒=1000毫秒=10^6微妙=10^9纳秒)</p>
</li>
</ul>
<p><strong>关于 Instant 类创建对象及其对象的相关方法：</strong></p>
<ul>
<li>now()：静态方法，返回默认 UTC 时区的 Instant 类的对象</li>
<li>ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00:00:00 基础上加上指定毫秒数之后的 Instant 类的对象</li>
<li>atOffset(ZoneOffset offset)：结合即时的偏移来创建一个 OffsetDateTime</li>
<li>toEpochMilli()：返回 1970-01-01 00:00:00 到当前时间的毫秒数，即为时间戳</li>
</ul>
<h3 id="java-time-format-DateTimeFormatter-类"><a href="#java-time-format-DateTimeFormatter-类" class="headerlink" title="java.time.format.DateTimeFormatter 类"></a>java.time.format.DateTimeFormatter 类</h3><p><strong>该类提供了三种格式化方法：</strong></p>
<ul>
<li><p>预定义的标准格式</p>
<ul>
<li>ISO_LOCAL_DATE_TIME</li>
<li>ISO_LOCAL_DATE</li>
<li>ISO_LOCAL_TIME</li>
</ul>
</li>
<li><p>本地化相关的格式：</p>
<ul>
<li><p>ofLocalizedDate(FormatStyle.LONG)：适用于LocalDate</p>
<ul>
<li>FormatStyle.FULL</li>
<li>FormatStyle.LONG</li>
<li>FormatStyle.MEDIUM</li>
<li>FormatStyle.SHORT</li>
</ul>
</li>
<li><p>ofLocalizedDateTime(FormatStyle.LONG)：适用于 LocalDateTime</p>
<ul>
<li>FormatStyle.LONG</li>
<li>FormatStyle.MEDIUM</li>
<li>FormatStyle.SHORT</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义的格式，如：ofPattern(“yyyy-MM-dd hh:mm:ss E”)</p>
</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>ofPattern(String pattern)：静态方法，返回一个指定字符串格式的 DateTimeFormater</li>
<li>format(TemporalAccessor t)：格式化一个日期、时间，返回字符串</li>
<li>parse(CharSequence texr)：将指定格式的字符序列解析为一个日期、时间</li>
</ul>
<h3 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h3><ul>
<li>ZoneId：该类中包含了所有的时区信息，一个时区的 ID，如 Europe/Paris</li>
<li>ZonedDateTime：一个在 ISO-8601 日历系统时区的日期时间，如 2020-11-22T16:31:22+01:00 Europe/Paris<ul>
<li>其中每个时区都对应着 ID，地区 ID 都为 “{区域}/{城市}” 的格式，例如：Asia/Shanghai 等</li>
</ul>
</li>
<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟</li>
<li>持续时间：Duration，用于计算两个 “时间” 间隔</li>
<li>日期间隔：Period，用于计算两个 “日期” 间隔</li>
<li>TemporalAdjuster：时间校正器。如：将日期调整到 “下一个工作日” 等操作</li>
<li>TemporalAdjusters：该类通过以下静态方法提供了大量的常用 TemporalAdjuster 的实现：<ul>
<li>firstDayOfXxx()</li>
<li>lastDayOfXxx()</li>
<li>nextXxx()</li>
</ul>
</li>
</ul>
<h3 id="与遗留日期处理类的转换"><a href="#与遗留日期处理类的转换" class="headerlink" title="与遗留日期处理类的转换"></a>与遗留日期处理类的转换</h3><table>
<thead>
<tr>
<th>类</th>
<th align="left">转换为(To)遗留类</th>
<th align="left">升级为新类</th>
</tr>
</thead>
<tbody><tr>
<td>java.time.Instant 与 java.util.Date</td>
<td align="left">Date.from(instant)</td>
<td align="left">date.toinstant()</td>
</tr>
<tr>
<td>java.time.Instant 与 java.sql.Timestamp</td>
<td align="left">Timestamp.from(instant)</td>
<td align="left">timestamp.toinstant()</td>
</tr>
<tr>
<td>java.time.zonedDateTime 与 java.util.GregorianCalendar</td>
<td align="left">GregorianCalendar.from(zonedDateTime)</td>
<td align="left">cal.toZonedDateTime()</td>
</tr>
<tr>
<td>java.time.LocalDate 与 java.sql.Date</td>
<td align="left">Date.valueOf(localDate)</td>
<td align="left">date.toLocalDate()</td>
</tr>
<tr>
<td>java.time.LocalTime 与 java.sql.Time</td>
<td align="left">Date.valueOf(localTime)</td>
<td align="left">date.toLocalTime()</td>
</tr>
<tr>
<td>java.time.LocalDateTime 与 java.sql.Timestamp</td>
<td align="left">Timestamp.valueOf(localDateTime)</td>
<td align="left">timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td>java.time.ZoneId 与 java.util.TimeZone</td>
<td align="left">Timestamp.getTimeZone(id)</td>
<td align="left">timeZone.toZonedId()</td>
</tr>
<tr>
<td>java.time.format.DateTimeFormatter 与 java.text.DateFormat</td>
<td align="left">formatter.toFormat()</td>
<td align="left">无</td>
</tr>
</tbody></table>
<h2 id="Java-比较器"><a href="#Java-比较器" class="headerlink" title="Java 比较器"></a>Java 比较器</h2><p>在 Java 中经常会涉及到对象数组的排序问题，涉及到对象之间的比较问题，正常情况下只能进行比较：== 或 !=，不能使用 &gt; 或 &lt;</p>
<p><strong>Java 实现对象排序的方式：</strong></p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.lang.Comparator</li>
</ul>
<h3 id="java-lang-Comparable-接口"><a href="#java-lang-Comparable-接口" class="headerlink" title="java.lang.Comparable 接口"></a>java.lang.Comparable 接口</h3><p>像 String、包装类等实现了 Comparable 接口，重写了 compareTo(Object obj) 方法，给出了比较两个对象大小的方式</p>
<p>重写 compareTo(Object obj) 的规则：</p>
<ul>
<li>如果当前对象 this 大于形参对象 obj，则返回正整数</li>
<li>如果当前对象 this 小于形参对象 obj，则返回负整数</li>
<li>如果当前对象 this 等于形参对象 obj，则返回零</li>
</ul>
<p>对于自定义类，如果需要排序，可以让自定义类实现 comparable 接口，重写 compareTo(Object obj) 方法，在 compareTo(Object obj) 方法中指明如何排序</p>
<h3 id="java-lang-Comparator"><a href="#java-lang-Comparator" class="headerlink" title="java.lang.Comparator"></a>java.lang.Comparator</h3><p>当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较</p>
<ul>
<li>重写 compare(Object  obj1, Object obj2) 方法，比较 obj1 和 obj2 的大小，如果方法返回正整数，则表示 obj1 大于 obj2、如果返回 0，表示相等、返回负整数，表示 obj1 小于 obj2</li>
<li>可以将 Comparator 传递给 sort 方法(如 Collections.sort 或 Arrays.sort)，从而允许在排序顺序上实现精确控制</li>
<li>还可以使用 Comparator 来控制某些数据结构(如有序 set 或有序映射)的顺序，或者为那些没有自然顺序的对象 collection 提供排序</li>
</ul>
<p><strong>Comparable 接口与 Comparator 的使用对比：</strong></p>
<ul>
<li>Comparable 接口的方式一旦一定，保证 Comparable 接口实现类的对象在任何位置都可以比较大小</li>
<li>Comparator 接口属于临时性的比较</li>
</ul>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><ul>
<li>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部，该类位于 java.lang 包</li>
<li>由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的</li>
<li>成员变量：<ul>
<li>System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流(键盘输入)、标准输出流(显示器)和标准错误输出流(显示器)</li>
</ul>
</li>
<li>成员方法：<ul>
<li>native long currentTimeMillis()：返回当前的计算机时间，时间的表达格式为当前计算机时间和 GMT 时间(格林威治时间)1970年1月1日0时0分0秒所差的毫秒数</li>
<li>void exit(int status)：退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。(使用该方法可以在图形界面编程中实现程序的退出功能)</li>
<li>void gc()：请求系统进行垃圾回收。至于系统是否立即回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况</li>
<li>String getProperty(String key)：获得系统中属性名为 key 的属性对应的值<ul>
<li>java.version：java 运行时环境版本</li>
<li>java.home：java 安装目录</li>
<li>os.name：操作系统的名称</li>
<li>os.version：操作系统的版本</li>
<li>user.name：用户的账户名称</li>
<li>user.home：用户的主目录</li>
<li>user.dir：用户的当前工作目录 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><ul>
<li>abs：求绝对值</li>
<li>acos、asin、atan、cos、sin、tan：三角函数</li>
<li>sqrt：求平方根</li>
<li>pow(double a, double b)：求 a 的 b 次幂</li>
<li>log：自然对数</li>
<li>exp：e 为底指数</li>
<li>max(double a, double b)：求最大值</li>
<li>min(double a, double b)：求最小值</li>
<li>random()：返回 0.0 到 1.0 之间的随机数</li>
<li>long round(double a)：double 型数据 a 转换为 long 型(四舍五入)</li>
<li>toDegrees(double angrad)：弧度 -&gt; 角度</li>
<li>toRadians(double angdeg)：角度 -&gt; 弧度</li>
</ul>
<h2 id="BigInteger-与-BigDecimal"><a href="#BigInteger-与-BigDecimal" class="headerlink" title="BigInteger 与 BigDecimal"></a>BigInteger 与 BigDecimal</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>Integer 类作为 int 的包装类，能存储的最大整型值为 <code>2^31 -1</code> ，Long 类也是有限的。如果要表示再大的整数，不管是基本数据类型还是它们的包装类都无能为力</p>
<p>java.math 包的 BigInteger 可以表示不可变的任意精度的整数。BigInteger 除了与 Java 中基本整数操作相同外还提供：模算数、GCD 计算、质数测试、素数生成、位操作以及一些其他操作</p>
<p><strong>构造器：</strong>BigInteger(String val)：根据字符串构建 BigInteger 对象</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>public BigInteger abs()：返回 BigInteger 的绝对值的 BigInteger</li>
<li>BigInteger add(BigInteger val)：返回其值为(this + val)的 BigInteger</li>
<li>BigInteger subtract(BigInteger val)：返回其值为(this - val)的 BigInteger</li>
<li>BigInteger multiply(BigInteger val)：返回其值为(this * val)的 BigInteger</li>
<li>BigInteger divide(BigInteger val)：返回其值为(this / val)的 BigInteger。整数相除只保留整数部分</li>
<li>BigInteger remainder(BigInteger val)：返回其值为(this % val)的 BigInteger</li>
<li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含(this / val)后跟(this % val)的两个 BigInteger 的数组</li>
<li>BigInteger pow(int exponent)：返回其值为(this^exponent)的 BigInteger</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类</p>
<p>BigDecimal 类支持不可变的、任意精度的有符号十进制定点数</p>
<p><strong>构造器：</strong></p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p><strong>枚举类的理解：</strong>类的对象是确定的且只有有限个，称此类为枚举类</p>
<ul>
<li><strong>需要定义一组常量时强烈建议使用枚举类</strong></li>
<li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li>
</ul>
<h2 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h2><ul>
<li>JDK5.0 之前，自定义枚举类<ul>
<li>自定义枚举类</li>
<li>声明对象的属性：private final 修饰</li>
<li>私有化(private)类的构造器，并初始化对象的属性</li>
<li>提供当前枚举类的多个对象：public static final 修饰</li>
<li>其他功能：<ul>
<li>获取枚举类对象的属性</li>
<li>提供 toString()</li>
</ul>
</li>
</ul>
</li>
<li>JDK5.0 新增，可以使用 enum 关键字定义枚举类<ul>
<li>使用 enum 关键字定义枚举类：默认继承于 java.lang.Enum 类</li>
<li>提供当前枚举类的对象，多个对象之间用逗号 “,” 隔开，末尾对象用分号 “;” 结束：enumObjName(“stringContent”)</li>
<li>声明对象的属性：private final 修饰</li>
<li>私有化(private)类的构造器，并初始化对象的属性</li>
<li>提供当前枚举类的多个对象：public static final 修饰</li>
<li>其他功能：<ul>
<li>获取枚举类对象的属性</li>
<li>提供 toString()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Enum-中的常用方法"><a href="#Enum-中的常用方法" class="headerlink" title="Enum 中的常用方法"></a>Enum 中的常用方法</h2><p><strong>Enum 类的主要方法：</strong></p>
<ul>
<li>values()：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值</li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的”名字”。若不是则出现运行时异常：IllegalArgumentException</li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
<h2 id="使用-enum-关键字定义的枚举类实现接口的情况"><a href="#使用-enum-关键字定义的枚举类实现接口的情况" class="headerlink" title="使用 enum 关键字定义的枚举类实现接口的情况"></a>使用 enum 关键字定义的枚举类实现接口的情况</h2><ul>
<li>情况一：实现接口，在 enum 类中实现抽象方法</li>
<li>情况二：让枚举类的对象分别实现接口中的抽象方法<ul>
<li>enumObjName(“stringContent”){  // 实现抽象方法}</li>
</ul>
</li>
</ul>
<h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><p>从 JDK5.0 开始，Java 增加了对元数据(MetaData)的支持。也就是 Annotation(注解)</p>
<ul>
<li>Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理</li>
<li>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在 Annotation 的 “name=value” 对中</li>
</ul>
<h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p>使用 Annotation 时要在其前面增加 @ 符号，并把该 Annotation 当成一个修饰符使用，用于修饰它支持的程序元素</p>
<ul>
<li>生成文档相关的注解：<ul>
<li>@author：标明开发该类模块的作者，多个作者之间使用逗号 “,” 分隔</li>
<li>@version：标明该类模块的版本</li>
<li>@see：标明参考转向，也就是相关主题</li>
<li>@since：标明从哪个版本开始增加</li>
<li>@param：对方法中某参数的说明，如果没有参数则不能写</li>
<li>@return：对方法返回值的说明，如果方法的返回值类型是 void 则不能写</li>
<li>exception：对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常则不能写</li>
<li>其中：<ul>
<li>@param、@return、@exception 这三个标记都是只用于方法的</li>
<li>@param 的格式要求：@param 形参名 形参类型 形参说明</li>
<li>@return 的格式要求：@return 返回值类型 返回值说明</li>
<li>@exception 的格式要求：@exception 异常类型 异常说明</li>
<li>@param 和 @exception 可以并列多个</li>
</ul>
</li>
</ul>
</li>
<li>在编译时进行格式检查(JDK 内置的三个基本注解)<ul>
<li>@Override：限定重写父类方法，该注解只能用于方法</li>
<li>@Deprecated：用于表示所修饰的元素(类、方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings：抑制编译器警告<ul>
<li>@SuppressWarnings(“unused”)</li>
<li>@SuppressWarnings({ “unused”, “rawtypes” })</li>
</ul>
</li>
</ul>
</li>
<li>跟踪代码依赖性，实现替代配置文件功能<ul>
<li>Servlet3.0 提供了注解(Annotation)，使得不再需要在 web.xml 文件中进行 Servlet 的部署</li>
<li>spring 框架中关于 “事务” 的管理</li>
</ul>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p><strong>说明：</strong></p>
<ul>
<li>定义新的 Annotation 类型使用 @interface 关键字</li>
<li>自定义注解自动继承了 java.lang.annotation.Annotation 接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。称为配置参数。类型只能是八种基本数据类型、String 类型、Class 类型、enum 类型、Annotation 类型、以上所有类型的数组</li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值，指定成员变量的初始值可以使用 default 关键字</li>
<li>如果只有一个参数成员，建议使用参数名为 value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式为 “参数名=参数值”，如果只有一个参数成员，且名称为 value，可以省略 “value=”</li>
<li>没有成员定义的 Annotation 称为标记、包含成员变量的 Annotation 称为元数据 Annotation</li>
</ul>
<p><strong>注意：自定义注解必须配上注解的信息处理流程(使用反射)才有意义</strong></p>
<p><strong>自定义注解通常都会指明两个元注解：@Retention、@Target</strong></p>
<p><strong>步骤：</strong></p>
<ul>
<li>注解声明为：@interface</li>
<li>内部定义成员，通常使用 value</li>
<li>可以指定成员的默认值，使用 default 定义</li>
<li>如果自定义注解没有成员，标明是一个标识</li>
</ul>
<h2 id="JDK-中的元注解"><a href="#JDK-中的元注解" class="headerlink" title="JDK 中的元注解"></a>JDK 中的元注解</h2><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义</p>
<p>JDK5.0 提供了 4 个标准的 meta-annotation 类型：</p>
<ul>
<li>@Retrntion：只能用于修饰一个 Annotation 定义，用于指定该 Annotation 的生命周期，@Retention 包含一个 RetentionPolicy 类型的成员变量，使用 @Retention 时必须为该 value 成员变量指定值：<ul>
<li>RetentionPolicy.SOURCE：在源文件中有效(即源文件保留)，编译器直接丢弃这种策略的注解</li>
<li>RetentionPolicy.CLASS：在 class 文件中有效(即 class 保留)，当运行 Java 程序时，JVM 不会保留注解。(该值为默认值)</li>
<li>RetentionPolicy.RUNTIME：在运行时有效(即运行时保留)，当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li>
<li>只有声明为 RUNTIME 声明周期的注解，才能通过反射获取</li>
</ul>
</li>
<li>@Target：用于修饰 Annotation 定义，用于指定被修饰的 Annotation 能用于修饰哪些程序元素。@Target 也包含一个名为 value 的成员变量<ul>
<li>CONSTRUCTOR：用于描述构造器</li>
<li>FIELD：用于描述域</li>
<li>LOCAL_VARIABLE：用于描述局部变量</li>
<li>METHOD：用于描述方法</li>
<li>PACKAGE：用于描述包</li>
<li>PARAMETER：用于描述参数</li>
<li>TYPE：用于描述类、接口(包括注解类型)或 enum 声明</li>
</ul>
</li>
<li>@Documented：用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。默认情况下，javadoc 是不包括注解的<ul>
<li>定义为 Documented 的注解必须设置 Retention 值为 RUNTIME</li>
</ul>
</li>
<li>@Inherited：被它修饰的 Annotation 将具有继承性。如果某个类使用了被 @Inherited 修饰的 Annotation，则其子类将自动具有该注解<ul>
<li>比如：如果把标有 @Inherited 注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解</li>
<li>实际使用较少</li>
</ul>
</li>
</ul>
<h2 id="JDK8-中注解的新特性"><a href="#JDK8-中注解的新特性" class="headerlink" title="JDK8 中注解的新特性"></a>JDK8 中注解的新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p><strong>JDK8 之前的写法：</strong></p>
<ul>
<li>实现 MyAnnotation：public @interface MyAnnotation{String value() default “str”;}</li>
<li>实现 MyAnnotations：public @interface MyAnnotations{MyAnnotations[] value();}</li>
<li>使用：@MyAnnotations({@MyAnnotation(value=”str1”), @MyAnnotation(value=”str2”)})</li>
</ul>
<p>JDK8 新增支持的写法：</p>
<ul>
<li>在 MyAnnotation 上声明 @Repeatable，成员值为 MyAnnotations.class<ul>
<li>在 public @interface MyAnnotation{String value() default “str”;} 之上加上注解 @Repeatable(MyAnnotations.class)</li>
</ul>
</li>
<li>MyAnnotation 的 Target 和 Retention 等元注解与 MyAnnotations 保持一致<ul>
<li>@Retention(RetentionPolicy.RUNTIME)</li>
<li>@Target({TYPE, FIELD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</li>
<li>@Inherited、…</li>
</ul>
</li>
</ul>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>JDK8 之后，关于元注解 @Target 的参数类型 ElementType 枚举值多了两个：TYPE_PARAMETER、TYPE_USE</p>
<p>在 Java8 之前，注解只能是在声明的地方所使用，Java8 开始，注解可以应用在任何地方：</p>
<ul>
<li>ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中(如：泛型声明)</li>
<li>ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">cpprto</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cpprto.gitee.io/2020/11/21/%E9%87%8D%E5%AD%A6Java-%E8%BF%9B%E9%98%B61/">https://cpprto.gitee.io/2020/11/21/重学Java-进阶1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cpprto.gitee.io" target="_blank">CPPRTO</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/09/22/wXA4RP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/22/%E9%87%8D%E5%AD%A6Java-%E8%BF%9B%E9%98%B62/"><img class="prev-cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">重学Java-进阶(2/2)</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><img class="next-cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">重学Java-异常处理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/27/Java基础编程题解/" title="Java基础编程题解"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-27</div><div class="title">Java基础编程题解</div></div></a></div><div><a href="/2021/01/10/Servlet-简明教程/" title="重学Java-Servlet 简明教程"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-10</div><div class="title">重学Java-Servlet 简明教程</div></div></a></div><div><a href="/2020/12/25/重学Java-JUC/" title="重学Java-JUC"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-25</div><div class="title">重学Java-JUC</div></div></a></div><div><a href="/2020/11/20/重学Java-异常处理/" title="重学Java-异常处理"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-20</div><div class="title">重学Java-异常处理</div></div></a></div><div><a href="/2020/11/19/重学Java-基础/" title="重学Java - 基础"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-19</div><div class="title">重学Java - 基础</div></div></a></div><div><a href="/2020/12/24/重学Java-JDBC及数据库连接池/" title="重学Java-JDBC及数据库连接池"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-24</div><div class="title">重学Java-JDBC及数据库连接池</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By cpprto</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>