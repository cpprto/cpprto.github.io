<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>重学Java-面向对象 | CPPRTO</title><meta name="description" content="Java 面向对象三大主线Java 类及类的成员属性、方法、构造器、内部类 面向对象的三大特性封装(Encapsulation)、继承(Inheriance)、多态(Polymorphism)、(抽象) 其他关键字this、super、static、final、abstract、interface、package、import 面向过程(POP)与面向对象(OOP)面向过程：POP - Proce"><meta name="keywords" content="Java"><meta name="author" content="cpprto"><meta name="copyright" content="cpprto"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cpprto.gitee.io/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="重学Java-面向对象"><meta property="og:url" content="https://cpprto.gitee.io/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta property="og:site_name" content="CPPRTO"><meta property="og:description" content="Java 面向对象三大主线Java 类及类的成员属性、方法、构造器、内部类 面向对象的三大特性封装(Encapsulation)、继承(Inheriance)、多态(Polymorphism)、(抽象) 其他关键字this、super、static、final、abstract、interface、package、import 面向过程(POP)与面向对象(OOP)面向过程：POP - Proce"><meta property="og:image" content="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><meta property="article:published_time" content="2020-11-20T00:56:29.000Z"><meta property="article:modified_time" content="2020-11-20T00:57:37.000Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?69d8bd2de8f48be7e268be5386f98dc5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-11-20 00:57:37'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/09/21/wqn7cV.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E4%B8%BB%E7%BA%BF"><span class="toc-number">1.</span> <span class="toc-text">Java 面向对象三大主线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.1.</span> <span class="toc-text">Java 类及类的成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象的三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text">其他关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-POP-%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP"><span class="toc-number">2.</span> <span class="toc-text">面向过程(POP)与面向对象(OOP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF%E5%92%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象分析方法分析问题的思路和步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">面向对象的思想概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%94%A8-class-%E6%9D%A5%E6%8F%8F%E8%BF%B0%E4%BA%8B%E7%89%A9%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E6%9C%89%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">Java 中用 class 来描述事物，常见的类成员有：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">类和对象的使用(面向对象思想的实现)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">类的多个对象的关系：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">2.6.</span> <span class="toc-text">对象的内存解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.</span> <span class="toc-text">属性(成员变量)与局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%9A"><span class="toc-number">2.8.</span> <span class="toc-text">方法的声明：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A%E6%8C%89%E7%85%A7%E6%98%AF%E5%90%A6%E6%9C%89%E5%BD%A2%E5%8F%82%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.8.1.</span> <span class="toc-text">方法的分类：按照是否有形参及返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.8.2.</span> <span class="toc-text">返回值类型：有返回值与没有返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.8.3.</span> <span class="toc-text">return 关键字的使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-number">2.8.4.</span> <span class="toc-text">方法使用中的注意点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%9A"><span class="toc-number">2.8.5.</span> <span class="toc-text">方法的重载：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.6.</span> <span class="toc-text">可变个数形参的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">2.8.7.</span> <span class="toc-text">方法参数的值传递机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BD%93%E5%86%85%E8%B0%83%E7%94%A8%E5%AE%83%E8%87%AA%E8%BA%AB"><span class="toc-number">2.8.8.</span> <span class="toc-text">递归方法：一个方法体内调用它自身</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-number">3.1.</span> <span class="toc-text">封装与隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%BF%BD%E6%B1%82%E2%80%9D%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88%E2%80%9D"><span class="toc-number">3.1.1.</span> <span class="toc-text">程序设计追求”高内聚，低耦合”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">封装的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-constructor"><span class="toc-number">3.1.3.</span> <span class="toc-text">构造器(构造方法 constructor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.4.</span> <span class="toc-text">构造器的作用：创建对象、初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.5.</span> <span class="toc-text">构造器的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.6.</span> <span class="toc-text">属性赋值的先后顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean"><span class="toc-number">3.1.7.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML-%E7%B1%BB%E5%9B%BE"><span class="toc-number">3.1.8.</span> <span class="toc-text">UML 类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-this-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.9.</span> <span class="toc-text">关键字 this 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-package%E3%80%81import-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.10.</span> <span class="toc-text">关键字 package、import 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.11.</span> <span class="toc-text">package 关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.12.</span> <span class="toc-text">import 关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="toc-number">3.1.13.</span> <span class="toc-text">JDK 中常用的包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.14.</span> <span class="toc-text">MVC 设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">继承的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">继承的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E7%B1%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">Object 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.2.4.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-super"><span class="toc-number">3.2.5.</span> <span class="toc-text">关键字 super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.6.</span> <span class="toc-text">子类对象实例化的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E5%A4%9A%E6%80%81%E6%83%85%E5%86%B5%E4%B8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">虚拟方法调用(多态情况下)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.3.2.</span> <span class="toc-text">方法重载和方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instaceof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.3.3.</span> <span class="toc-text">instaceof 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">向下转型的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-%E7%B1%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%89%96%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">Object 类结构的剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.1.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">toString() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-Wrapper-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.3.</span> <span class="toc-text">包装类(Wrapper)的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-static"><span class="toc-number">3.5.</span> <span class="toc-text">关键字 static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.6.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-final"><span class="toc-number">3.7.</span> <span class="toc-text">关键字 final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">抽象类与抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-abstract-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.8.1.</span> <span class="toc-text">关键字 abstract 的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.9.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.9.1.</span> <span class="toc-text">接口的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.10.</span> <span class="toc-text">内部类</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://s1.ax1x.com/2020/09/22/wXA4RP.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CPPRTO</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">重学Java-面向对象</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-20T00:56:29.000Z" title="发表于 2020-11-20 00:56:29">2020-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-20T00:57:37.000Z" title="更新于 2020-11-20 00:57:37">2020-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java-面向对象三大主线"><a href="#Java-面向对象三大主线" class="headerlink" title="Java 面向对象三大主线"></a>Java 面向对象三大主线</h1><h2 id="Java-类及类的成员"><a href="#Java-类及类的成员" class="headerlink" title="Java 类及类的成员"></a>Java 类及类的成员</h2><p>属性、方法、构造器、内部类</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>封装(Encapsulation)、继承(Inheriance)、多态(Polymorphism)、(抽象)</p>
<h2 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h2><p>this、super、static、final、abstract、interface、package、import</p>
<h1 id="面向过程-POP-与面向对象-OOP"><a href="#面向过程-POP-与面向对象-OOP" class="headerlink" title="面向过程(POP)与面向对象(OOP)"></a>面向过程(POP)与面向对象(OOP)</h1><p>面向过程：POP - Procedure Oriented Programming<br>面向对象：OOP - Object Oriented Programming<br>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<ul>
<li>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做</li>
<li>面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等</li>
</ul>
<h2 id="面向对象分析方法分析问题的思路和步骤"><a href="#面向对象分析方法分析问题的思路和步骤" class="headerlink" title="面向对象分析方法分析问题的思路和步骤"></a>面向对象分析方法分析问题的思路和步骤</h2><ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具</li>
</ul>
<h2 id="面向对象的思想概述"><a href="#面向对象的思想概述" class="headerlink" title="面向对象的思想概述"></a>面向对象的思想概述</h2><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)</li>
</ul>
</li>
<li>可以理解为：类 = 抽象概念的人；对象 = 实实在在的某个人</li>
<li>面向对象程序设计的重点是类的设计</li>
<li>类的设计，其实就是类的成员的设计</li>
</ul>
<h2 id="Java-中用-class-来描述事物，常见的类成员有："><a href="#Java-中用-class-来描述事物，常见的类成员有：" class="headerlink" title="Java 中用 class 来描述事物，常见的类成员有："></a>Java 中用 class 来描述事物，常见的类成员有：</h2><ul>
<li>属性：对应类中的成员变量</li>
<li>行为：对应类中的成员方法</li>
<li>Field = 属性 = 成员变量，Method = (成员)方法 = 函数</li>
</ul>
<p><strong>Java 类的实例化，即创建类的对象</strong></p>
<h2 id="类和对象的使用-面向对象思想的实现"><a href="#类和对象的使用-面向对象思想的实现" class="headerlink" title="类和对象的使用(面向对象思想的实现)"></a>类和对象的使用(面向对象思想的实现)</h2><ul>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过”对象.属性”或”对象.方法”调用对象的结构</li>
</ul>
<h2 id="类的多个对象的关系："><a href="#类的多个对象的关系：" class="headerlink" title="类的多个对象的关系："></a>类的多个对象的关系：</h2><ul>
<li>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性(非 static)</li>
</ul>
<h2 id="对象的内存解析"><a href="#对象的内存解析" class="headerlink" title="对象的内存解析"></a>对象的内存解析</h2><h2 id="属性-成员变量-与局部变量"><a href="#属性-成员变量-与局部变量" class="headerlink" title="属性(成员变量)与局部变量"></a>属性(成员变量)与局部变量</h2><ul>
<li>相同点<ul>
<li>定义变量的格式：数据类型 变量名 = 值</li>
<li>先声明，后使用</li>
<li>变量都有其对应的作用域</li>
</ul>
</li>
<li>不同点<ul>
<li>在类中声明的位置不同：<ul>
<li>属性：直接定义在类的一对 {} 内</li>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
</ul>
</li>
<li>关于权限修饰符的不同：<ul>
<li>属性：可以在声明属性时，指明其权限，使用权限修饰符<br>常用的权限修饰符：private、public、缺省(即没有)、protected</li>
<li>局部变量：不可以使用权限修饰符</li>
</ul>
</li>
<li>默认初始化值的情况：<ul>
<li>属性：类的属性，根据其类型，都有默认初始化值<br>整型(byte、short、int、long)：0<br>浮点型(float、double)：0.0<br>字符型(char)：0 (或 ‘\u0000’)<br>布尔型(boolean)：false<br>引用数据类型(类、数组、接口)：null</li>
<li>局部变量：没有默认初始化值<br>意味着在调用局部变量之前，一定要显式赋值<br>特别的：形参在调用时赋值即可</li>
</ul>
</li>
<li>在内存中加载的位置：<ul>
<li>属性：加载到堆空间中(非 static)</li>
<li>局部变量：加载到栈空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="方法的声明："><a href="#方法的声明：" class="headerlink" title="方法的声明："></a>方法的声明：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表) &#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的分类：按照是否有形参及返回值"><a href="#方法的分类：按照是否有形参及返回值" class="headerlink" title="方法的分类：按照是否有形参及返回值"></a>方法的分类：按照是否有形参及返回值</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">无返回值</th>
<th align="center">有返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无形参</td>
<td align="center">void 方法名() {}</td>
<td align="center">返回值的类型 方法名() {}</td>
</tr>
<tr>
<td align="center">有形参</td>
<td align="center">void 方法名(形参列表) {}</td>
<td align="center">返回值的类型 方法名(形参列表) {}</td>
</tr>
</tbody></table>
<h3 id="返回值类型：有返回值与没有返回值"><a href="#返回值类型：有返回值与没有返回值" class="headerlink" title="返回值类型：有返回值与没有返回值"></a>返回值类型：有返回值与没有返回值</h3><ul>
<li>如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用 return 关键字返回指定类型的变量或常量：”return 数据;”</li>
<li>如果方法没有返回值，则方法声明时，使用 void 关键字来表示。通常，没有返回值的方法中不需要使用 return，如果需要使用，可以 “return;” 表示结束此方法</li>
</ul>
<h3 id="return-关键字的使用："><a href="#return-关键字的使用：" class="headerlink" title="return 关键字的使用："></a>return 关键字的使用：</h3><ul>
<li>使用范围：使用在方法体中</li>
<li>作用：<ul>
<li>结束方法</li>
<li>针对有返回值类型的方法，使用 “return 数据;” 返回所需要的数据</li>
</ul>
</li>
<li>注意点：return 关键字后不可以声明执行语句</li>
</ul>
<h3 id="方法使用中的注意点："><a href="#方法使用中的注意点：" class="headerlink" title="方法使用中的注意点："></a>方法使用中的注意点：</h3><ul>
<li>方法的使用中，可以调用当前类的属性或方法<ul>
<li>特殊的：方法 A 中又调用了方法 A(递归)</li>
</ul>
</li>
<li>方法中，不可以定义方法</li>
</ul>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h3><ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</li>
<li>重载的特点：<ul>
<li>与方法的权限修饰符、返回值类型、形参变量名、方法体都无关</li>
<li>与参数列表有关且参数列表必须不同(参数个数或参数类型)</li>
<li>调用时，根据方法参数列表的不同来区别</li>
</ul>
</li>
</ul>
<h3 id="可变个数形参的方法"><a href="#可变个数形参的方法" class="headerlink" title="可变个数形参的方法"></a>可变个数形参的方法</h3><p>JavaSE 5.0 中提供了 Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参</p>
<ul>
<li><p>JDK 5.0 以前：采用数组形参来定义方法，传入多个同一类型变量</p>
<ul>
<li>public static void test(int a, String[] b) {}</li>
</ul>
</li>
<li><p>JDK 5.0 采用可变个数形参来定义方法，传入多个同一类型变量</p>
<ul>
<li>public static void test(int a, String … b) {}</li>
</ul>
</li>
<li><p>具体使用：</p>
<ul>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是任意的(0 个、1 个、2 个、…)</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组(数据类型[] 变量名)之间不构成重载。即，二者不能共用</li>
<li>可变个数形参在方法的形参中，必须声明在末尾</li>
<li>可变个数形参在方法的形参中，最多只能声明一个可变个数形参</li>
</ul>
</li>
</ul>
<h3 id="方法参数的值传递机制："><a href="#方法参数的值传递机制：" class="headerlink" title="方法参数的值传递机制："></a>方法参数的值传递机制：</h3><ul>
<li>方法必须由其所在类或对象调用才有意义。若方法含有参数：<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li>Java 的实参值传入方法的方式<ul>
<li>Java 中方法的参数传递方式只有一种：值传递。即，将实际参数值的副本传入方法内，而参数本身不受影响<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参</li>
</ul>
</li>
</ul>
</li>
<li>关于变量的赋值<ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值</li>
</ul>
</li>
</ul>
<h3 id="递归方法：一个方法体内调用它自身"><a href="#递归方法：一个方法体内调用它自身" class="headerlink" title="递归方法：一个方法体内调用它自身"></a>递归方法：一个方法体内调用它自身</h3><ul>
<li>理解递归可以通过画出递归树的方式</li>
</ul>
<h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><h2 id="封装与隐藏"><a href="#封装与隐藏" class="headerlink" title="封装与隐藏"></a>封装与隐藏</h2><h3 id="程序设计追求”高内聚，低耦合”"><a href="#程序设计追求”高内聚，低耦合”" class="headerlink" title="程序设计追求”高内聚，低耦合”"></a>程序设计追求”高内聚，低耦合”</h3><ul>
<li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li>
<li>低耦合：仅对外暴露少量的方法用于使用<br>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。即封装的设计思想</li>
</ul>
<h3 id="封装的体现"><a href="#封装的体现" class="headerlink" title="封装的体现"></a>封装的体现</h3><ul>
<li>避免用户使用 “对象.属性” 的方式对属性进行赋值</li>
<li>将属性name声明为私有(private)，同时提供公共的(public)方法来获取(getName)和设置(setName)此属性的值</li>
<li>封装的体现需要结合权限修饰符<ul>
<li>Java 权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限</li>
<li>Java 规定的 4 种权限(从小到大)：private、缺省(即没有权限修饰符)、protected、public</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内部</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(缺省)</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<ul>
<li>对于 class 的权限修饰只可以用 public 和 default(缺省)<ul>
<li>public 类可以在任意地方被访问</li>
<li>default 类只可以被同一个包内部的类访问</li>
</ul>
</li>
</ul>
<p><strong>总结封装：</strong>Java 提供了 4 种权限修饰符来修饰类及类的内部结构，体现类的内部结构在被调用时的可见性的大小</p>
<h3 id="构造器-构造方法-constructor"><a href="#构造器-构造方法-constructor" class="headerlink" title="构造器(构造方法 constructor)"></a>构造器(构造方法 constructor)</h3><ul>
<li>若没有显式的定义类的构造器，则默认提供一个无参构造器</li>
<li>定义构造器的格式：权限修饰符 类名(参数列表) {}</li>
<li>一个类中定义多个构造器，彼此构成重载</li>
<li>一旦显式的定义了类的构造器，便不再提供默认的无参构造器</li>
<li>一个类中至少存在一个构造器</li>
</ul>
<h3 id="构造器的作用：创建对象、初始化对象"><a href="#构造器的作用：创建对象、初始化对象" class="headerlink" title="构造器的作用：创建对象、初始化对象"></a>构造器的作用：创建对象、初始化对象</h3><ul>
<li>创建类的对象：new 构造器(<code>Order o = new Order();</code>)</li>
<li>初始化对象的信息</li>
</ul>
<h3 id="构造器的特征"><a href="#构造器的特征" class="headerlink" title="构造器的特征"></a>构造器的特征</h3><ul>
<li>具有与类相同的名称</li>
<li>不声明返回值类型</li>
<li>不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值</li>
</ul>
<h3 id="属性赋值的先后顺序"><a href="#属性赋值的先后顺序" class="headerlink" title="属性赋值的先后顺序"></a>属性赋值的先后顺序</h3><p>默认初始化 &gt; 显式初始化 &gt; 构造器中赋值 &gt; 通过 “对象.方法” 或 “对象.属性”的方式赋值</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>JavaBean 是一种 Java 语言写成的可重用组件</li>
<li>所谓 JavaBean 是指符合如下标准的 Java 类<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的 get、set 方法</li>
</ul>
</li>
<li>用户可以使用 JavaBean 将功能、处理、值、数据库访问和其他任何可以用 Java 代码创造的对象进行打包，并且其他的开发者可以通过内部的 JSP 页面、Servlet、其他 JavaBean、applet 程序或者应用来使用这些对象。用户可以认为 JavaBean 提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</li>
</ul>
<h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><table>
<thead>
<tr>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>- 属性名 : 属性类型<br>+ 属性名 : 属性类型<br># 属性名 : 属性类型</td>
</tr>
<tr>
<td>+<u>方法名(参数名 : 参数类型) : 返回值类型</u><br>-方法名(参数名 : 参数类型) : 返回值类型<br>+方法名(参数名 : 参数类型) : 返回值类型</td>
</tr>
</tbody></table>
<ul>
<li>+表示 public 类型、-表示 private 类型、#表示 protected 类型</li>
<li>若方法有下划线表示为构造方法</li>
</ul>
<h3 id="关键字-this-的使用"><a href="#关键字-this-的使用" class="headerlink" title="关键字 this 的使用"></a>关键字 this 的使用</h3><ul>
<li><p>this 的作用与词义很接近</p>
<ul>
<li>在方法内部使用，即这个方法所属对象的引用</li>
<li>在构造器内部使用，表示该构造器正在初始化的对象</li>
</ul>
</li>
<li><p>this 表示当前对象，可以调用类的属性、方法和构造器</p>
</li>
<li><p>this 的使用场景：</p>
<ul>
<li>当在方法内需要用到调用该方法的对象时<br>具体的，可以使用 this 来区分局部变量和属性<br><code>this.name = name;</code></li>
</ul>
</li>
<li><p>在类的方法中(或构造器中)，可以使用 “this.属性” 或 “this.方法” 的方式，调用当前对象属性或方法。但是通常情况下都选择省略 “this.”。特殊情况下，如果方法的形参(或构造器的形参)与类的属性同名时，必须显式的使用 “this.变量” 的方式，表明此变量是属性，而非形参。</p>
</li>
<li><p>this 调用构造器</p>
<ul>
<li>在类的构造器中可以显式的使用 “this(形参列表)” 方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过 “this(形参列表)” 方式调用自己</li>
<li>如果一个类中有 n 个构造器，则最多有 n-1 个构造器中使用了 “this(形参列表)”</li>
<li>规定：”this(形参列表)” 必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个 “this(形参列表)” 用来调用其他的构造器</li>
</ul>
</li>
</ul>
<h3 id="关键字-package、import-的使用"><a href="#关键字-package、import-的使用" class="headerlink" title="关键字 package、import 的使用"></a>关键字 package、import 的使用</h3><h3 id="package-关键字的使用"><a href="#package-关键字的使用" class="headerlink" title="package 关键字的使用"></a>package 关键字的使用</h3><ul>
<li>为了更好的实现项目中类的管理，提供包的概念</li>
<li>使用 package 声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符命名规则、规范、见名知义</li>
<li>每 “.” 一次就代表一层文件目录</li>
<li>补充：同一个包下，不能命名同名的接口、类</li>
</ul>
<h3 id="import-关键字的使用"><a href="#import-关键字的使用" class="headerlink" title="import 关键字的使用"></a>import 关键字的使用</h3><p>import 语句有两种类型：</p>
<ul>
<li>明确导入是在 import 语句中指定单个的类。</li>
<li>通配符导入是指通过使用星号( * )作为通配符，导入一个包中所有的类。</li>
</ul>
<p><strong>注意：</strong>除非要在程序中使用某个类，否则关于被导入包中的这些类的信息在编译时或是运行时是不被读入的。<br>    导入语句只是告诉编译器在什么地方能找到这些类。声明明确导入和声明通配符导入在性能上是没有什么差别的。</p>
<h3 id="JDK-中常用的包"><a href="#JDK-中常用的包" class="headerlink" title="JDK 中常用的包"></a>JDK 中常用的包</h3><ul>
<li>java.lang：包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能(默认导入)</li>
<li>java.net：包含执行与网络相关的操作的类和接口</li>
<li>java.io：包含能提供多种输入/输出功能的类</li>
<li>java.util：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。如 Scanner、Date</li>
<li>java.text：包含了一些 java 格式化相关的类</li>
<li>java.sql：包含了 java 进行 JDBC 数据库编程的相关类/接口</li>
<li>java.awt：包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)</li>
</ul>
<h3 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h3><p>MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层(view)、控制器层(controller)、数据模型层(model)。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序变得灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性</p>
<ul>
<li>模型层 model 主要处理数据<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li>控制层 controller 处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放 fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
<li>视图层 view 显示数据<ul>
<li>相关工具类 view.util</li>
<li>自定义 view view.ui</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java 只支持单继承和多层继承，不允许多重继承</p>
<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
</ul>
<h3 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h3><ul>
<li>减少代码冗余，提高复用性</li>
<li>便于功能拓展</li>
<li>为之后多态的使用提供了前提</li>
</ul>
<h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>class A extends B {}</p>
<ul>
<li><p>A：子类、派生类、subclass</p>
</li>
<li><p>B：父类、超类、基类、superclass</p>
</li>
<li><p>体现：一旦子类 A 继承了父类 B，子类 A 中就获取了父类 B 中声明的结构：属性、方法</p>
<ul>
<li>特别的，父类中声明为 private 的属性或方法，子类继承父类后，仍然认为获取了父类中私有的结构。只因为受封装的影响，使得子类不能直接调用父类的结构而已</li>
</ul>
</li>
<li><p>子类继承父类后，还可以声明自己特有的属性或方法，实现功能的扩展(extends：扩展)</p>
</li>
</ul>
<h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><ul>
<li>如果没有显式的声明一个类的父类，则此类继承于 java.lang.Object 类</li>
<li>所有的 java 类(除 java.lang.Object 类之外) 都直接或间接的继承于 java.lang.Object 类</li>
<li>意味着，所有的 java 类都具有 java.lang.Object 类声明的功能</li>
</ul>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><strong>定义：</strong>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法</p>
<p><strong>要求：</strong></p>
<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<ul>
<li>子类不能重写父类中声明为 private 权限的方法</li>
</ul>
</li>
<li>子类重写的方法抛出的异常不能大于父类被重写的方法的异常</li>
</ul>
<p><strong>注意：</strong>子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，或者同时声明为 static 的(不是重写)。因为 static 方法是属于类的，子类无法覆盖父类的方法。</p>
<p><strong>应用：</strong>方法重写后，当创建子类对象以后，通过子类对象调用子、父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
<h3 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h3><ul>
<li><p>super 理解为：父类的</p>
</li>
<li><p>super 可以用来调用：属性、方法、构造器</p>
</li>
<li><p>super 的使用：</p>
<ul>
<li>可以在子类的方法或构造器中，通过使用 “super.属性” 或 “super.方法” 的方式，显式的调用父类中声明的属性或方法。通常习惯省略 “super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用 “super.属性” 的方式，表明调用的是父类中声明的属性</li>
<li>特殊情况：当子类重写了父类中的方法后，要想在子类的方法中调用父类中被重写的方法时，则必须显式的使用 “super.方法” 的方式，表明调用的是父类中被重写的方法</li>
<li>super 调用构造器<ul>
<li>可以在子类的构造器中显式的使用 “super(形参列表)” 的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)” 的使用，必须声明在子类构造器的首行</li>
<li>在类的构造器中，针对于 “this(形参列表)” 或 “super(形参列表)” 只能二选一，不能同时出现</li>
<li>在构造器的首行，没有显式的声明 “this(形参列表)” 或 “super(形参列表)”，则默认调用的是父类中无参的构造器：”super()”</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了 “super(形参列表)”  调用父类中的构造器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="子类对象实例化的过程"><a href="#子类对象实例化的过程" class="headerlink" title="子类对象实例化的过程"></a>子类对象实例化的过程</h3><p><strong>从结果来看(继承)：</strong></p>
<ul>
<li>子类继承父类后，就获取了父类中声明的属性和方法</li>
<li>创建子类的对象，在堆空间中就会加载所有父类中声明的属性</li>
</ul>
<p><strong>从过程上来看：</strong></p>
<ul>
<li>当通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器…<br>直到调用了 java.lang.Object 类中的无参的构造器为止。正因为加载过所有的父类的结构，所以可以看到内存中有父类中的结构，子类对象才可以考虑进行调用</li>
</ul>
<p><strong>注意：</strong>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即 new 出的子类对象</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>对象的多态性：父类的引用指向子类的对象(或子类的对象赋给父类的引用)</strong></p>
<ul>
<li>可以直接应用在抽象类和接口上</li>
</ul>
<p><strong>Java 引用变量有两个类型：</strong></p>
<ul>
<li><p>编译时类型和运行时类型</p>
</li>
<li><p>编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋值给该变量的对象决定。(编译时，看 “=” 左边、运行时，看 “=” 右边)</p>
</li>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性</p>
</li>
<li><p>多态情况下：</p>
<ul>
<li>“看左边”：看的是父类的引用(父类中不具备子类特有的方法)</li>
<li>“看右边”：看的是子类的对象(实际运行的是子类重写父类的方法)</li>
</ul>
</li>
</ul>
<p><strong>多态的使用：</strong></p>
<ul>
<li>当调用子、父类同名同参数的方法时，实际执行的是子类重写父类的方法(虚拟方法调用)</li>
<li>在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法</li>
<li>多态的使用前提：类继承关系、方法重写</li>
<li>多态只适用于方法，不适用于属性(编译期与运行期均决定于 “=” 左边声明的变量类型)</li>
</ul>
<p><strong>多态是运行时行为</strong></p>
<h3 id="虚拟方法调用-多态情况下"><a href="#虚拟方法调用-多态情况下" class="headerlink" title="虚拟方法调用(多态情况下)"></a>虚拟方法调用(多态情况下)</h3><p>子类中定义了与父类同名同参的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<p><strong>动态绑定：</strong></p>
<p>编译时引用变量类型是父类类型，而方法调用是在运行时确定的，所以调用的便是子类的方法，该过程称为动态绑定</p>
<h3 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h3><p><strong>二者的定义细节：</strong></p>
<ul>
<li>重载：重名方法，方法的参数列表不同</li>
<li>重写：子类根据需求对父类中的方法进行改造。必须方法同名、同参数列表</li>
</ul>
<p><strong>从编译和运行的角度看：</strong></p>
<ul>
<li>重载，是指允许存在多个同名方法，而这些方法的参数列表不同。它们的调用地址在编译期就绑定了。Java 重载是可以包括父类和子类的，即子类可以重载父类的同名，参数列表不同的方法。所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为 “早绑定” 或 “静态绑定”</li>
<li>对于多态与方法重写，只有等到方法调用的那一刻才会确定所要调用的具体方法，这称为 “晚绑定” 或 “动态绑定”</li>
</ul>
<h3 id="instaceof-操作符"><a href="#instaceof-操作符" class="headerlink" title="instaceof 操作符"></a>instaceof 操作符</h3><p>x instanceof A：检验 x 是否为类 A 的对象，返回值为 boolean 型</p>
<ul>
<li>要求 x 所属的类与类 A 必须是子类和父类的关系，否则编译错误</li>
<li>如果 x 属于类 A 的子类 B，x instanceof A 值也为 true</li>
</ul>
<h3 id="向下转型的使用"><a href="#向下转型的使用" class="headerlink" title="向下转型的使用"></a>向下转型的使用</h3><p>由于对象的多态性，内存中实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用</p>
<p>向上转型：多态</p>
<p>向下转型：使用强制类型转换符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Man m = (Man)p;</span><br></pre></td></tr></table></figure>

<p>强转时可能出现 ClassCastException 异常，此时可以使用 instanceof 操作符进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Man) &#123;</span><br><span class="line">    Man m = (Man)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-类结构的剖析"><a href="#Object-类结构的剖析" class="headerlink" title="Object 类结构的剖析"></a>Object 类结构的剖析</h2><ul>
<li>Object 类是所有 Java 类的根父类</li>
<li>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object</li>
</ul>
<h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h3><ul>
<li><p>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</p>
</li>
<li><p>equals() 是属于 java.lang.Object 类中的方法，如果该方法没有被重写过，默认也是 ==。可以看到 String 等类的 equals() 方法是被重写过的，而且 String 类在日常开发中用的比较多，久而久之形成了 equals 是比较值的错误观点</p>
</li>
<li><p>具体要看自定义类里有没有重写 Object 的 equals() 方法来判断</p>
</li>
<li><p>通常情况下，重写 equals() 方法，会比较类中的相应属性是否都相等</p>
</li>
</ul>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><ul>
<li>toString() 方法在 Object 类中定义，其返回值是 String 类型，返回类名和它的引用地址</li>
<li>在进行 String 与其他类型数据的连接操作时，自动调用 toString() 方法</li>
<li>可以根据需要在用户自定义类型中重写 toString() 方法<br>如 String 类重写了 toString() 方法，返回字符串的值</li>
<li>基本类型数据转换为 String 类型时，调用了对应包装类的 toString() 方法</li>
</ul>
<h3 id="包装类-Wrapper-的使用"><a href="#包装类-Wrapper-的使用" class="headerlink" title="包装类(Wrapper)的使用"></a>包装类(Wrapper)的使用</h3><ul>
<li>针对八种基本数据类型定义相应的引用类型 —— 包装类(封装类)</li>
<li>有了类的特点，可以调用类中的方法</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<ul>
<li>其中 Byte、Short、Integer、Long、Float、Double 的父类是 Number</li>
</ul>
<p><strong>基本数据类型包装成包装类的实例 —— 装箱</strong></p>
<ul>
<li>通过包装类的构造器实现：int i =  1; Integer t = new Integer(i);</li>
<li>还可以通过字符串参数构造包装类对象：Float f = new Float(“3.14F”);</li>
</ul>
<p><strong>获得包装类对象中包装的基本类型变量 —— 拆箱</strong></p>
<ul>
<li>调用包装类的 .xxxValue() 方法：boolean b = bObj.booleanValue();</li>
<li>JDK1.5 之后，支持自动装箱，自动拆箱。但类型必须匹配</li>
<li>基本数据类型、包装类转换为 String 类型：调用 String 重载的 valueOf() 方法</li>
<li>String 类型准换为基本数据类型、包装类：调用包装类的 parseXxx() 方法</li>
</ul>
<h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字 static"></a>关键字 static</h2><p>当编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过 new 关键字才会产生出对象，这时才会分配内存空间给对象，其方法才可以供外部调用。若希望无论是否产生了对象或无论产生了多少个对象的情况下，某些特定的数据在内存空间中只有一份，这时可以使用 static 关键字修饰为静态的</p>
<ul>
<li><p>static 可以用来修饰：属性、方法、代码块、内部类</p>
</li>
<li><p>使用 static 修饰属性：静态变量</p>
<ul>
<li>属性按是否使用 static 修饰，分为：静态属性、非静态属性(实例变量)<ul>
<li>实例变量：创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值被修改</li>
<li>静态变量：创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时是被修改过的</li>
</ul>
</li>
<li>static 修饰属性的其他说明：<ul>
<li>静态变量随着类的加载而加载。可以通过 “类.静态变量” 的方式进行调用</li>
<li>静态变量的加载要早于对象的创建</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中</li>
<li>对象可以调用类变量(静态变量)和它的实例变量，类只能调用类变量不能调用实例变量</li>
</ul>
</li>
</ul>
</li>
<li><p>使用 static 修饰方法：静态方法</p>
<ul>
<li>随着类的加载而加载，可以通过 “类.静态方法” 的方式进行调用</li>
<li>对象可以调用类方法(静态方法)和非静态方法，类只能调用静态方法不能调用非静态方法</li>
<li>静态方法中，只能调用静态的方法或属性<br>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li>
</ul>
</li>
<li><p>注意点：在静态方法内，不能使用 this 关键字、super 关键字</p>
</li>
<li><p>何时需要 static</p>
<ul>
<li>属性是可以被多个对象所共享的，不会随着对象的不同而不同</li>
</ul>
</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li>代码块的作用：用来初始化类、对象</li>
<li>代码块只能使用 static 修饰</li>
<li>分类：<ul>
<li>静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着类的加载而执行，而且只执行一次</li>
<li>作用：初始化类的信息</li>
<li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态属性、静态方法，不能调用非静态的结构</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着对象的创建而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法</li>
</ul>
</li>
<li>对属性可以赋值的位置<ul>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中初始化</li>
<li>有了对象以后，可以通过 “对象.属性” 或 “对象.方法” 进行赋值</li>
<li>在代码块中赋值</li>
</ul>
</li>
<li>属性赋值的先后顺序<ul>
<li>默认初始化 &gt; 显式初始化或在代码块中赋值(取决于顺序) &gt; 构造器中初始化 &gt; 有了对象以后，可以通过 “对象.属性” 或 “对象.方法” 进行赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h2><p>final：最终的</p>
<ul>
<li>final 可以用来修饰：类、方法、变量</li>
<li>final 用来修饰类：此类不能被其他类所继承<br>比如 String、System、StringBuffer</li>
<li>final 用来修饰方法：此方法不可以被重写<br>比如 Object 类中的 getClass()</li>
<li>final 用来修饰变量：此时的 “变量” 就称为是一个常量<ul>
<li>final 修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li>
<li>final 修饰局部变量：尤其是使用 final 修饰形参时，表明此形参是一个常量。当调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值</li>
</ul>
</li>
<li>static final 用来修饰属性：全局常量(大写)</li>
</ul>
<h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<h3 id="关键字-abstract-的使用"><a href="#关键字-abstract-的使用" class="headerlink" title="关键字 abstract 的使用"></a>关键字 abstract 的使用</h3><p><strong>abstract：抽象的</strong></p>
<ul>
<li>abstract 可以用来修饰：类、方法</li>
<li>abstract 修饰类：抽象类<ul>
<li>此类不能实例化</li>
<li>抽象类一定有构造器，便于子类实例化时使用(涉及：子类对象实例化的全过程)</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</li>
</ul>
</li>
<li>abstract 修饰方法：抽象方法<ul>
<li>抽象方法只有方法的声明，没有方法体</li>
<li>包含抽象方法的类，一定是抽象类。反之，抽象类中可以没有抽象方法</li>
<li>若子类重写了父类中的所有的抽象方法后，次子类方可实例化<br>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用 abstract 修饰</li>
</ul>
</li>
<li>abstract 使用上的注意点：<ul>
<li>abstract 不能用来修饰：属性、构造器等结构</li>
<li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是 Java 不支持多重继承，而接口便可以得到多重继承的效果</p>
</li>
<li><p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已</p>
</li>
<li><p>接口就是规范，定义的是一组规则，体现了现实世界中 “如果你是/要…则必须能…” 的思想。继承是一个 “是不是” 的关系，而接口实现则是 “能不能” 的关系</p>
</li>
<li><p>接口的本质是契约、标准、规范，指定后需要遵守</p>
</li>
</ul>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ul>
<li>接口使用 interface 来定义</li>
<li>Java 中，接口和类是并列的两个结构</li>
<li>定义接口：定义接口中的成员<ul>
<li>JDK7 及以前：只能定义全局常量和抽象方法<ul>
<li>全局常量：public static final (可以省略不写)</li>
<li>抽象方法：public abstract</li>
</ul>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ul>
</li>
<li>接口中不能定义构造器，意味着接口不能实例化</li>
<li>Java 开发中，接口通过让类去实现(implements)的方式来使用<ul>
<li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li>
</ul>
</li>
<li>Java 类可以实现多个接口，弥补了 Java 单继承的局限性<br>格式：class AA extends BB implements CC, DD, EE</li>
<li>接口与接口之间可以继承，而且可以多继承</li>
<li>接口的具体使用，体现多态</li>
<li>接口，实际上可以看作是一种规范</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类</li>
<li>在 Java 中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类</li>
<li>Inner class 一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称<ul>
<li>Inner class 的名字不能与包含它的外部类类名相同</li>
</ul>
</li>
<li>分类：<ul>
<li>成员内部类(静态、非静态)<ul>
<li>作为外部类的成员<ul>
<li>调用外部类的结构</li>
<li>可以被 static 修饰</li>
<li>可以被 4 种不同的权限修饰</li>
</ul>
</li>
<li>作为一个类<ul>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被 final 修饰，表示此类不能被继承，反之可以被继承</li>
<li>可以被 abstract 修饰</li>
</ul>
</li>
</ul>
</li>
<li>局部内部类(方法内、代码块内、构造器内)、匿名内部类</li>
</ul>
</li>
<li>实例化成员内部类的对象<ul>
<li>静态成员内部类：外部类.内部类 变量 = new 外部类.内部类();</li>
<li>非静态成员内部类：外部类 外部类引用变量 = new 外部类(); 外部类.内部类 内部类引用变量 = 外部类引用变量.new 内部类();</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">cpprto</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cpprto.gitee.io/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">https://cpprto.gitee.io/2020/11/20/重学Java-面向对象/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cpprto.gitee.io" target="_blank">CPPRTO</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/09/22/wXA4RP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><img class="prev-cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">重学Java-异常处理</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/19/%E9%87%8D%E5%AD%A6Java-%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">重学Java - 基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/27/Java基础编程题解/" title="Java基础编程题解"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-27</div><div class="title">Java基础编程题解</div></div></a></div><div><a href="/2021/01/10/Servlet-简明教程/" title="重学Java-Servlet 简明教程"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-10</div><div class="title">重学Java-Servlet 简明教程</div></div></a></div><div><a href="/2020/12/25/重学Java-JUC/" title="重学Java-JUC"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-25</div><div class="title">重学Java-JUC</div></div></a></div><div><a href="/2020/11/20/重学Java-异常处理/" title="重学Java-异常处理"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-20</div><div class="title">重学Java-异常处理</div></div></a></div><div><a href="/2020/11/19/重学Java-基础/" title="重学Java - 基础"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-19</div><div class="title">重学Java - 基础</div></div></a></div><div><a href="/2020/12/24/重学Java-JDBC及数据库连接池/" title="重学Java-JDBC及数据库连接池"><img class="cover" src="https://s1.ax1x.com/2020/09/22/wXA4RP.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-24</div><div class="title">重学Java-JDBC及数据库连接池</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By cpprto</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>