<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 基本使用与常用命令</title>
    <url>/2020/09/22/Git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="版本管理的演变"><a href="#版本管理的演变" class="headerlink" title="版本管理的演变"></a>版本管理的演变</h3><blockquote>
<p><strong>VCS（Version Control System）出现之前</strong></p>
<ul>
<li>用目录拷贝区别不同版本</li>
<li>公共文件容易被覆盖</li>
<li>成员沟通成本高，代码集成效率低下</li>
</ul>
<p><strong>集中式 VCS（如 CVS）</strong></p>
<ul>
<li>有集中的版本管理服务器</li>
<li>具备文件版本管理和分支管理能力</li>
<li>集成效率有明显提高</li>
<li>客户端必须时刻与服务器相连</li>
</ul>
<p><strong>分布式 VCS（如 Git）</strong></p>
<ul>
<li>服务端和客户端都有完整的版本库</li>
<li>脱离服务端，客户端也可以管理版本</li>
<li>支持查看历史和版本比较等多数操作，都不需要访问服务器，比集中式 VCS 更能提高版本管理效率</li>
</ul>
</blockquote>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><blockquote>
<p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper</p>
<p><strong>特点</strong></p>
<ul>
<li>最优的存储能力</li>
<li>非凡的性能</li>
<li>开源</li>
<li>容易做备份</li>
<li>支持离线操作</li>
<li>容易定制工作流程</li>
</ul>
</blockquote>
<h2 id="Git-安装与最小配置"><a href="#Git-安装与最小配置" class="headerlink" title="Git 安装与最小配置"></a>Git 安装与最小配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 <strong><a href="https://git-scm.com/downloads">Git</a></strong></p>
<h3 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h3><p>配置 user 信息 <code>user.name</code> 和 <code>user.email</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;your_name&quot;</span><br><span class="line">$ git config --global user.email &quot;your_email&quot;</span><br></pre></td></tr></table></figure>

<p><code>config</code> 的三个作用域，缺省等同于 <code>local</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --local  # local 即只针对某个仓库有效 </span><br><span class="line">$ git config --global  # global 即针对当前用户的所有仓库有效</span><br><span class="line">$ git config --system  # system 即针对系统所有登录的用户有效</span><br></pre></td></tr></table></figure>

<p>显示 <code>config</code> 的配置， 加 <code>--list</code> 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list --local</span><br><span class="line">$ git config --list --golbal</span><br><span class="line">$ git config --list --system</span><br></pre></td></tr></table></figure>

<h2 id="创建-Git-仓库"><a href="#创建-Git-仓库" class="headerlink" title="创建 Git 仓库"></a>创建 Git 仓库</h2><p>分为以下两种场景：</p>
<ol>
<li>把已有的项目代码纳入 Git 管理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 项目代码所在的目录</span><br><span class="line">$ git init</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>新项目直接使用 Git 管理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 某个目录</span><br><span class="line">$ git init your_project  # 该命令会在该目录下创建与项目名称同名的目录</span><br><span class="line">$ cd your_project</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="基本使用与常用命令"><a href="#基本使用与常用命令" class="headerlink" title="基本使用与常用命令"></a>基本使用与常用命令</h2><h3 id="认识工作区与暂存区"><a href="#认识工作区与暂存区" class="headerlink" title="认识工作区与暂存区"></a>认识工作区与暂存区</h3><p>以下为一些常用的基本命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status  # 查看工作目录与暂存区的状态</span><br><span class="line">$ git add files  # 提交 files 到暂存区 </span><br><span class="line">$ git commit -m “commit message” # 生成 commit（-m 参数：编辑生成 commit 信息，若不加该参数将会进入文本编辑器）</span><br><span class="line">$ git log  # 查看 commit 历史</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/22/Git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/commit.png" alt="向仓库中添加文件的过程"></p>
<h3 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h3><h4 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h4><p><code>git mv old_name new_name</code></p>
<h4 id="回退到上一次-commit"><a href="#回退到上一次-commit" class="headerlink" title="回退到上一次 commit"></a>回退到上一次 commit</h4><p><code>git reset --hard</code></p>
<h4 id="通过-git-log-查看版本演变历史"><a href="#通过-git-log-查看版本演变历史" class="headerlink" title="通过 git log 查看版本演变历史"></a>通过 <code>git log</code> 查看版本演变历史</h4><ul>
<li>查看当前分支的 <strong>commit</strong> 历史信息 <code>git log</code> 不加任何参数时只查看当前分支</li>
<li>查看所有分支的 <strong>commit</strong> 历史信息 <code>git log --all</code></li>
<li>图形化（字符画）展示 <strong>commit</strong> 历史信息 <code>git log --all --graph</code></li>
<li>查看历史 <strong>commit</strong> 信息列表（简洁信息） <code>git log --oneline</code></li>
<li>查看最近的 <strong>4</strong> 条历史 <strong>commit</strong> 信息列表 <code>git log -n4 --oneline</code></li>
<li>图形化界面工具，查看所有分支的 <strong>commit</strong> 历史信息 <code>gitk --all</code></li>
</ul>
<h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><ul>
<li>查看当前分支 <code>git branch</code></li>
<li>查看本地所有分支信息 <code>git branch -v</code></li>
<li>查看所有分支信息（包含远程分支） <code>git branch -av</code></li>
</ul>
<h4 id="管理分支"><a href="#管理分支" class="headerlink" title="管理分支"></a>管理分支</h4><ul>
<li>创建新分支 <code>git checkout -b 新分支名称 hash值</code><br>填写 <strong>commit</strong> 的 “hash值” 可以指定基于该 <strong>commit</strong> 创建新分支（可用 <code>git log</code> 命令查看对应 <strong>commit</strong> 的 “hash值” ）</li>
<li>切换分支 <code>git checkout 其他已存在的分支</code></li>
</ul>
<h2 id="Git-原理剖析"><a href="#Git-原理剖析" class="headerlink" title="Git 原理剖析"></a>Git 原理剖析</h2><p>首先进入 <code>.git</code> 目录下，接下来对 <code>.git</code> 目录下的各文件与目录进行解析</p>
<h3 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd .git&#x2F;</span><br><span class="line">$ cat HEAD</span><br><span class="line">ref: refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure>

<p>即 <code>HEAD</code> 文件中的内容为 <strong>ref: refs/heads/master</strong>，那么这个内容代表什么意思呢？</p>
<p>此时输入 <code>git branch -av</code> 显示我们当前所在分支为 <code>* master</code>， <code>*</code> 即代表当前所在，由此我们了解了，<code>HEAD</code> 文件中的内容即是记录了我们当前所在的分支信息。而 <code>refs/heads/master</code> 看起来像是一个路径，这个接下来再说</p>
<h3 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd .git&#x2F;</span><br><span class="line">$ cat config</span><br><span class="line">...</span><br><span class="line">[user]</span><br><span class="line">    name &#x3D; user.name  # 使用 --local 参数设置的用户名</span><br><span class="line">    email &#x3D; user.email  # 使用 --local 参数设置的邮箱</span><br></pre></td></tr></table></figure>

<p>显而易见 <code>.git</code> 目录下的 <code>config</code> 文件中保存了 <code>--local</code> 相关信息，此时修改文件中的内容后使用 <code>git config --local --list</code> 命令查看相应结果也会发生对应的变化</p>
<h3 id="refs-目录"><a href="#refs-目录" class="headerlink" title="refs 目录"></a>refs 目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd .git&#x2F;</span><br><span class="line">$ cd refs&#x2F;</span><br><span class="line">$ ll -a</span><br><span class="line">drwxr-xr-x    .</span><br><span class="line">drwxr-xr-x    ..</span><br><span class="line">drwxr-xr-x    heads</span><br><span class="line">drwxr-xr-x    tags</span><br></pre></td></tr></table></figure>

<h4 id="heads-目录"><a href="#heads-目录" class="headerlink" title="heads 目录"></a>heads 目录</h4><p><strong>小技巧：</strong></p>
<ul>
<li><code>git cat-file -t 2b81da</code><br>该命令可以查看以上对象 <code>2b81da</code>（这里它本应该表现为一个完整的 hash 值，截取其名称前 5-6 个字符或更多字符即可代表该对象）的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd heads&#x2F;</span><br><span class="line">$ ll -a</span><br><span class="line">drwxr-xr-x    .</span><br><span class="line">drwxr-xr-x    ..</span><br><span class="line">-rw-r--r--    master  # master 分支</span><br><span class="line">$ cat master</span><br><span class="line">2b81da9321641975fed4724138fb77fe1f9b6a  # 对象</span><br><span class="line">$ git cat-file -t 2b81da</span><br><span class="line">commit  # 该对象是一个 commit 类型</span><br></pre></td></tr></table></figure>

<p>接着上面 <code>HEAD</code> 文件没有说完的内容，<code>refs/heads/master</code> 看起来像是一个路径，由此我们进入这个路径进行探寻</p>
<p>对于 <code>.git/refs/heads/master 文件</code>，其中存放的是当前 <code>master</code> 分支指针指向的 <strong>commit</strong></p>
<blockquote>
<p>注释：refs 目录下的 heads 目录可以理解为存放当前分支的目录<br>tags 目录可以理解为存放该仓库所有标签的目录，标签一般意味着一段开发历程的里程碑</p>
</blockquote>
<h4 id="tags-目录"><a href="#tags-目录" class="headerlink" title="tags 目录"></a>tags 目录</h4><p>接上，下面再来看一下 <code>tags</code> 路径下有什么</p>
<p><strong>小技巧：</strong></p>
<ul>
<li><code>git cat-file -p 345864</code><br>该命令查看以上对象 <code>345864</code> 的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd .git</span><br><span class="line">$ cd tags&#x2F;</span><br><span class="line">$ ll -a</span><br><span class="line">drwxr-xr-x    .</span><br><span class="line">drwxr-xr-x    ..</span><br><span class="line">-rw-r--r--    release-1.0.0  # 假设已生成了 1 个 tag</span><br><span class="line">$ cat release-1.0.0</span><br><span class="line">345864e3d80d85cdf7fbf55a4a77d5f846d419  # 这个 hash 值代表一个对象</span><br><span class="line">$ git cat-file -t 345864</span><br><span class="line">tag  # 该对象是一个 tag 类型</span><br><span class="line">$ git cat-file -p 345864</span><br><span class="line">object f6237a79adb743a351ea26bf5eae51d4a14483</span><br><span class="line">type commit  # 以上对象是一个 commit 类型</span><br><span class="line">tag release-1.0.0</span><br><span class="line">tagger xxx &lt;xxx@xxx.com&gt; xxxxxxxxxx +0800</span><br><span class="line"></span><br><span class="line">commit_message  # commit message 内容</span><br><span class="line">$ git cat-file -t f6237a</span><br><span class="line">commit  # 该对象是一个 commit 类型</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释：当我们查看 tags 路径下文件的内容时，显示了一个 hash 值，它通常代表一个对象，接着我们查看它的类型 —— 一个 tag 类型；接着是它的内容，内容中又包含一个 hash 值，它已经标注了自己的类型 —— 是一个 commit，并且还包含了 tag 名称、生成时间戳、提交人信息、commit message 等，可以再使用命令 <code>git cat-file -t f6237a</code> 检查一下</p>
</blockquote>
<h3 id="Git-文件系统的核心-objects"><a href="#Git-文件系统的核心-objects" class="headerlink" title="Git 文件系统的核心 - objects"></a>Git 文件系统的核心 - objects</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd .git</span><br><span class="line">$ cd objects&#x2F;</span><br><span class="line">$ ll -a</span><br><span class="line">drwxr-xr-x    .</span><br><span class="line">drwxr-xr-x    ..</span><br><span class="line">drwxr-xr-x    de</span><br><span class="line">drwxr-xr-x    e0</span><br><span class="line">drwxr-xr-x    e1</span><br><span class="line">drwxr-xr-x    e2</span><br><span class="line">drwxr-xr-x    e3</span><br><span class="line">drwxr-xr-x    e4</span><br><span class="line">drwxr-xr-x    info</span><br><span class="line">drwxr-xr-x    pack</span><br><span class="line">cd e0&#x2F;  # 随便进入一个目录</span><br><span class="line">$ ll -a</span><br><span class="line">drwxr-xr-x    .</span><br><span class="line">drwxr-xr-x    ..</span><br><span class="line">-rw-r--r--    8a9e0cde36b17bda8583a91a81c5e35f1408f4</span><br><span class="line">$ git cat-file -t e08a9e0cde  # 此时 Git 的策略是将父级目录名与该文件拼接成一个 hash 值</span><br><span class="line">tree  # 该对象是一个 tree 类型</span><br><span class="line">$ git cat-file -p e08a9e0cde</span><br><span class="line">100000 blob b72e61c8b6782cd0fab5w41ea2b044d1fe05be3f file_name  # blob 代表文件类型</span><br><span class="line">$ git cat-file -t b72e61c8</span><br><span class="line">blob  # 该对象是一个 blob 类型</span><br><span class="line">$ git cat-file -p b72e61c8</span><br><span class="line">file_name_content  # 展现文件中的内容 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释：当我们进入 objects 目录下时使用 <code>ll -a</code> 命令可以看到一些以两个字母命名的目录。<br>随机选择进入一个这样的目录后再使用 <code>ll -a</code> 命令，得到的将是一个或多个类似 hash 值命名的对象，实际上 Git 的策略是以它的父级目录名加上该类似 hash 值的内容拼接作为一个 hash 值，查看该对象的类型，其为一个新的类型 —— tree，接着查看它的内容，其中又包含一个新类型 blob，代表文件类型，查看这个 blob 类型对象的内容即为实际文件的内容（即 file_name 对应的文件）</p>
</blockquote>
<p><strong>实际上，只要任何文件的内容是相同的，那么在 Git 看来它就是唯一的一个 blob</strong></p>
<h3 id="Git-对象彼此关系"><a href="#Git-对象彼此关系" class="headerlink" title="Git 对象彼此关系"></a>Git 对象彼此关系</h3><p><img src="/2020/09/22/Git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/objects.png" alt="Git 对象彼此关系"></p>
<blockquote>
<ul>
<li>一个 <strong>commit</strong> 对应一个 <strong>tree</strong>，它代表了这个 <strong>commit</strong> 在这个时间点整个仓库的快照，即在这个时间点：目录结构、文件是什么样子，将通过 <strong>tree</strong> 呈现出来 —— 见黄色部分 <strong>823gb7…</strong></li>
<li><strong>tree</strong> 代表文件夹，<strong>tree</strong> 中可以包含 <strong>tree</strong><ul>
<li>可以看到 <strong>tree - 87a87a</strong> 代表 <strong>images</strong> 文件夹，具体见箭头指向</li>
<li>可以看到 <strong>tree - bdd489</strong> 代表 <strong>styles</strong> 文件见，具体见箭头指向</li>
</ul>
</li>
<li><strong>blob</strong> 代表文件，<strong>blob</strong> 与文件名没有任何关系，即不管文件名为什么，文件内容相同那么就只有一个 <strong>blob</strong></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础编程题解</title>
    <url>/2020/11/27/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>一味地追求理解概念不如 Show Me The Code，本篇博文收集了网络上常见的 Java 基础阶段编程题目<br>博文意在巩固基本概念，提高自己运用代码解决问题的能力以及帮助自己理解概念的深层内涵<br>挑选一些比较有趣的题目及比较有启发的解法</p>
<h3 id="显示当前时间"><a href="#显示当前时间" class="headerlink" title="显示当前时间"></a>显示当前时间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 显示当前时间</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> totalMilliseconds = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> totalSeconds = totalMilliseconds / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">long</span> currentSecond = totalSeconds % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">long</span> totalMinutes = totalSeconds / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">long</span> currentMinute = totalMinutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">long</span> totalHours = totalMinutes / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">long</span> currentHour = (totalHours + <span class="number">8</span>) % <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Current time is &quot;</span> + currentHour + <span class="string">&quot;:&quot;</span> + currentMinute + <span class="string">&quot;:&quot;</span> + currentSecond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 判断闰年</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leapYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter a year: &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> year = input.nextInt();</span><br><span class="line">    <span class="keyword">boolean</span> isLeapYear = (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(year + <span class="string">&quot; is a leap year? &quot;</span> + isLeapYear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算生肖"><a href="#计算生肖" class="headerlink" title="计算生肖"></a>计算生肖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 计算生肖</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chineseZodiac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter a year: &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> year = input.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (year % <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: System.out.println(<span class="string">&quot;猴&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: System.out.println(<span class="string">&quot;鸡&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: System.out.println(<span class="string">&quot;狗&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: System.out.println(<span class="string">&quot;猪&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: System.out.println(<span class="string">&quot;鼠&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: System.out.println(<span class="string">&quot;牛&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: System.out.println(<span class="string">&quot;虎&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: System.out.println(<span class="string">&quot;兔&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: System.out.println(<span class="string">&quot;龙&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>: System.out.println(<span class="string">&quot;蛇&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: System.out.println(<span class="string">&quot;马&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>: System.out.println(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="99-乘法表"><a href="#99-乘法表" class="headerlink" title="99 乘法表"></a>99 乘法表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 99 乘法表</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiplicationTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;        Multiplication Table&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;   &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n----------------------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot; | &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%4d&quot;</span>, i * j);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出两个正整数的最大公约数"><a href="#找出两个正整数的最大公约数" class="headerlink" title="找出两个正整数的最大公约数"></a>找出两个正整数的最大公约数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 找出两个正整数的最大公约数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greatestCommonDivisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter first integer: &quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> n1 = input.nextLong();</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter second integer: &quot;</span> );</span><br><span class="line">    <span class="keyword">long</span> n2 = input.nextLong();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> gcd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n1 &amp;&amp; k &lt;= n2; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 % k == <span class="number">0</span> &amp;&amp; n2 % k == <span class="number">0</span>)</span><br><span class="line">            gcd = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;The greatest common divisor for &quot;</span> + n1 + <span class="string">&quot; and &quot;</span> + n2 + <span class="string">&quot; is &quot;</span> + gcd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出两个正整数的最大公约数-欧几里得算法"><a href="#找出两个正整数的最大公约数-欧几里得算法" class="headerlink" title="找出两个正整数的最大公约数(欧几里得算法)"></a>找出两个正整数的最大公约数(欧几里得算法)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m % n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十六进制转十进制"><a href="#十六进制转十进制" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 十进制转十六进制</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec2Hex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter a decimal number: &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> decimal = input.nextInt();</span><br><span class="line">    String hex = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (decimal != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> hexValue = decimal % <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">char</span> hexDigit = (hexValue &lt;= <span class="number">9</span> &amp;&amp; hexValue &gt;= <span class="number">0</span>) ? (<span class="keyword">char</span>)(hexValue + <span class="string">&#x27;0&#x27;</span>) : (<span class="keyword">char</span>)(hexValue - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        hex = hexDigit + hex;</span><br><span class="line">        decimal = decimal / <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;The hex number is &quot;</span> + hex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十六进制转十进制-1"><a href="#十六进制转十进制-1" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 十六进制转十进制</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hex2Dec2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter a hex number: &quot;</span>);</span><br><span class="line">    String hex = input.nextLine();</span><br><span class="line">    System.out.println(<span class="string">&quot;The decimal value for hex number &quot;</span> + hex + <span class="string">&quot; is &quot;</span> + hex2Decimal(hex.toUpperCase()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hex2Decimal</span><span class="params">(String hex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> decimalValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hex.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> hexChar = hex.charAt(i);</span><br><span class="line">        decimalValue = decimalValue * <span class="number">16</span> + hexChar2Decimal(hexChar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decimalValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hexChar2Decimal</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>) ? <span class="number">10</span> + ch - <span class="string">&#x27;A&#x27;</span> : ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断回文串-字符串"><a href="#判断回文串-字符串" class="headerlink" title="判断回文串(字符串)"></a>判断回文串(字符串)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 判断回文串(字符串)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">palindromeString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    String s = input.nextLine();</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isPalindrome = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(low) != s.charAt(high)) &#123;</span><br><span class="line">            isPalindrome = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        low++;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s += isPalindrome ? <span class="string">&quot; is a palindrome&quot;</span> : <span class="string">&quot; is not a palindrome&quot;</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断回文串-字符串-递归解法"><a href="#判断回文串-字符串-递归解法" class="headerlink" title="判断回文串(字符串 - 递归解法)"></a>判断回文串(字符串 - 递归解法)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursivePalindrome</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPalindrome(s, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (high &lt;= low)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(low) != s.charAt(high))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(s, low + <span class="number">1</span>, high - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Is moon a palindrome? &quot;</span> + isPalindrome(<span class="string">&quot;moon&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Is noon a palindrome? &quot;</span> + isPalindrome(<span class="string">&quot;noon&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Is a a palindrome? &quot;</span> + isPalindrome(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Is aba a palindrome? &quot;</span> + isPalindrome(<span class="string">&quot;aba&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Is ab a palindrome? &quot;</span> + isPalindrome(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断回文数"><a href="#判断回文数" class="headerlink" title="判断回文数"></a>判断回文数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 判断回文数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">palindromeInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.print(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> number = input.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> || (number % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; number != <span class="number">0</span>))</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reversedNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (number &gt; reversedNumber) &#123;</span><br><span class="line">        reversedNumber = reversedNumber * <span class="number">10</span> + number % <span class="number">10</span>;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(number == reversedNumber || number == reversedNumber / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求-100-以内质数"><a href="#求-100-以内质数" class="headerlink" title="求 100 以内质数"></a>求 100 以内质数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出 100 以内的质数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    label:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印环形矩阵"><a href="#打印环形矩阵" class="headerlink" title="打印环形矩阵"></a>打印环形矩阵</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 打印环形矩阵</span></span><br><span class="line"><span class="comment">* Enter an integer: 4</span></span><br><span class="line"><span class="comment">* 01 02	03 04	</span></span><br><span class="line"><span class="comment">* 12 13	14 05	</span></span><br><span class="line"><span class="comment">* 11 16	15 06	</span></span><br><span class="line"><span class="comment">* 10 09	08 07</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCircularMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxX = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxY = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (minX &lt;= maxX) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = minX; x &lt;= maxX; ++x)</span><br><span class="line">            array[minY][x] = ++count;</span><br><span class="line">        minY++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = minY; y &lt;= maxY; ++y)</span><br><span class="line">            array[y][maxX] = ++count;</span><br><span class="line">        maxX--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = maxX; x &gt;= minX; --x)</span><br><span class="line">            array[maxY][x] = ++count;</span><br><span class="line">        maxY--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = maxY; y &gt;= minY; --y)</span><br><span class="line">            array[y][minX] = ++count;</span><br><span class="line">        minX++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] eArray : array) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : eArray) &#123;</span><br><span class="line">            String space = (e + <span class="string">&quot;&quot;</span>).length() == <span class="number">1</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            System.out.print(space + e + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="随机抽取四张扑克牌"><a href="#随机抽取四张扑克牌" class="headerlink" title="随机抽取四张扑克牌"></a>随机抽取四张扑克牌</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 随机抽取 4 张扑克牌</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deckOfCards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] deck = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">52</span>];</span><br><span class="line">    String[] suits = &#123;<span class="string">&quot;Spades&quot;</span>, <span class="string">&quot;Hearts&quot;</span>, <span class="string">&quot;Diamonds&quot;</span>, <span class="string">&quot;Clubs&quot;</span>&#125;;</span><br><span class="line">    String[] ranks = &#123;<span class="string">&quot;Ace&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Queen&quot;</span>, <span class="string">&quot;King&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.length; ++i)</span><br><span class="line">        deck[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>)(Math.random() * deck.length);</span><br><span class="line">        <span class="keyword">int</span> temp = deck[i];</span><br><span class="line">        deck[i] = deck[index];</span><br><span class="line">        deck[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        String suit = suits[deck[i] / <span class="number">13</span>];</span><br><span class="line">        String rank = ranks[deck[i] % <span class="number">13</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;Card number &quot;</span> + deck[i] + <span class="string">&quot;: &quot;</span> + rank + <span class="string">&quot; of&quot;</span> + suit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建一个随机元素数组列表"><a href="#构建一个随机元素数组列表" class="headerlink" title="构建一个随机元素数组列表"></a>构建一个随机元素数组列表</h3><p>要求数组列表中各元素不重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = (<span class="keyword">int</span>)(Math.random() * <span class="number">9</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arrayList.contains(temp)) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arrayList.add(i, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计一个有理数类"><a href="#设计一个有理数类" class="headerlink" title="设计一个有理数类"></a>设计一个有理数类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rational</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Rational</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> numerator = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> denominator = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rational</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rational</span><span class="params">(<span class="keyword">long</span> numerator, <span class="keyword">long</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> gcd = gcd(numerator, denominator);</span><br><span class="line">        <span class="keyword">this</span>.numerator = ((denominator &gt; <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>) * numerator / gcd;</span><br><span class="line">        <span class="keyword">this</span>.denominator = Math.abs(denominator) / gcd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n1 = Math.abs(n);</span><br><span class="line">        <span class="keyword">long</span> n2 = Math.abs(d);</span><br><span class="line">        <span class="keyword">int</span> gcd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n1 &amp;&amp; k &lt;= n2; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1 % k == <span class="number">0</span> &amp;&amp; n2 % k == <span class="number">0</span>)</span><br><span class="line">                gcd = k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNumerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDenominator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rational <span class="title">add</span><span class="params">(Rational secondRational)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = numerator * secondRational.getDenominator() + denominator * secondRational.getNumerator();</span><br><span class="line">        <span class="keyword">long</span> d = denominator * secondRational.getDenominator();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rational(n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rational <span class="title">subtract</span><span class="params">(Rational secondRational)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = numerator * secondRational.getDenominator() - denominator * secondRational.getNumerator();</span><br><span class="line">        <span class="keyword">long</span> d = denominator * secondRational.getDenominator();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rational(n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rational <span class="title">multiply</span><span class="params">(Rational secondRational)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = numerator * secondRational.getNumerator();</span><br><span class="line">        <span class="keyword">long</span> d = denominator * secondRational.getDenominator();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rational(n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rational <span class="title">divide</span><span class="params">(Rational secondRational)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = numerator * secondRational.getDenominator();</span><br><span class="line">        <span class="keyword">long</span> d = denominator * secondRational.getNumerator();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rational(n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> numerator + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> numerator + <span class="string">&quot;/&quot;</span> + denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Rational)</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.subtract((Rational) (other))).getNumerator() == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numerator * <span class="number">1.0</span> / denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Rational o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subtract(o).getNumerator() &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.subtract(o).getNumerator() &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-Servlet 简明教程</title>
    <url>/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本篇博文为 Servlet 技术的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 技能。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Servlet 是 JavaEE 规范之一(接口)</p>
<p>Servlet 是 JavaWeb 三大组件之一</p>
<ul>
<li>Servlet 程序</li>
<li>Filter 过滤器</li>
<li>Listener 监听器</li>
</ul>
<p>Servlet 是运行在服务器上的一个 Java 程序，它可以接收客户端发来的请求并响应数据给客户端</p>
<h1 id="实现-Servlet-程序"><a href="#实现-Servlet-程序" class="headerlink" title="实现 Servlet 程序"></a>实现 Servlet 程序</h1><h2 id="实现-Servlet-接口"><a href="#实现-Servlet-接口" class="headerlink" title="实现 Servlet 接口"></a>实现 Servlet 接口</h2><p>编写一个实现 Servlet 接口的类</p>
<p>实现 service 方法，处理请求并响应数据</p>
<p>web.xml 配置 Servlet 程序的访问地址</p>
<p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110171118880.png" alt="image-20210110171118880"></p>
<h2 id="继承-HttpServlet"><a href="#继承-HttpServlet" class="headerlink" title="继承 HttpServlet"></a>继承 HttpServlet</h2><p>编写类，继承 HttpServlet</p>
<p>重写 doGet 或 doPost 方法</p>
<p>web.xml 配置 Servlet 程序的访问地址</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>第一次访问，创建 Servlet 程序时创建</p>
<ul>
<li><p>执行 Servlet 构造器方法</p>
</li>
<li><p>执行 init 初始化方法</p>
</li>
</ul>
<p>每次访问时调用</p>
<ul>
<li>执行 service 方法</li>
</ul>
<p>web 工程停止时调用</p>
<ul>
<li>执行 destroy 销毁方法</li>
</ul>
<h1 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h1><p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110171532228.png" alt="image-20210110171532228"></p>
<h1 id="常用类-接口"><a href="#常用类-接口" class="headerlink" title="常用类/接口"></a>常用类/接口</h1><h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>Servlet 程序的配置信息类</p>
<p>Servlet 程序和 ServletConfig 对象均由 Tomcat 负责创建</p>
<p>Servlet 程序默认为第一次访问时创建，每个 Servlet 程序创建时便创建一个对应的 ServletConfig 对象传递给 init 方法</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>String getServletName();<ul>
<li>获取 Servlet 程序别名 &lt;servlet-name&gt; 的值</li>
</ul>
</li>
<li>String getInitParameter(String val1);<ul>
<li>获取初始化参数 init-param</li>
</ul>
</li>
<li>ServletContext getServletContext();<ul>
<li>获取 ServletContext 对象</li>
</ul>
</li>
</ul>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>ServletContext 为一个接口，表示 Servlet 上下文对象</p>
<p>一个 web 工程只有一个 ServletContext 对象实例</p>
<p>ServletContext 对象是一个域对象</p>
<p>ServletContext 在 web 工程部署启动时创建，在 web 工程停止时销毁</p>
<p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110172539728.png" alt="image-20210110172539728"></p>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>只要有请求进入 Tomcat 服务器，Tomcat 便会将请求携带的  HTTP 协议信息进行解析并封装到 Request 对象中，传递给 service 方法(doGet 或 doPost)</p>
<p>可以通过 HttpServletRequest 对象获取到所有请求的信息</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>getRequestURI()<ul>
<li>获取请求的资源路径</li>
</ul>
</li>
<li>getRequestURL()<ul>
<li>获取请求的统一资源定位符(绝对路径)</li>
</ul>
</li>
<li>getRemoteHost()<ul>
<li>获取客户端的 IP</li>
</ul>
</li>
<li>getHeader(String val1)<ul>
<li>获取请求头</li>
</ul>
</li>
<li>getParameter()<ul>
<li>获取请求参数</li>
<li>getParameterValues()<ul>
<li>获取请求参数(多个值时使用 checkbox)</li>
</ul>
</li>
<li>在处理 POST 请求时<ul>
<li>httpServletRequest.setCharacterEncoding(“UTF-8”);<br>设置请求体的字符集为 UTF-8 从而解决 POST 请求中文乱码问题</li>
<li>在获取请求参数之前调用才有效</li>
</ul>
</li>
</ul>
</li>
<li>getMethod()<ul>
<li>获取请求方法</li>
</ul>
</li>
<li>setAttribute(key, value)<ul>
<li>设置域数据</li>
</ul>
</li>
<li>getAttribute(key)<ul>
<li>获取域数据</li>
</ul>
</li>
<li>getRequestDispatcher()<ul>
<li>获取请求转发对象</li>
</ul>
</li>
</ul>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110173334154.png" alt="image-20210110173334154"></p>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>只有有请求进入 Tomcat 服务器，Tomcat 便会创建一个 Response 对象传递给 Servlet 程序</p>
<p>可以通过 HttpServletResponse 对象设置需要返回给客户端的信息</p>
<p>通过流将数据传递给客户端</p>
<p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110173508326.png" alt="image-20210110173508326"></p>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>客户端与服务端之间通信，数据传输需要遵守的规则</p>
<ul>
<li>数据 -&gt; 报文</li>
<li>客户端给服务端发送数据 -&gt; 请求</li>
<li>服务端给客户端发送数据 -&gt; 响应</li>
</ul>
<h2 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h2><p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110173730665.png" alt="image-20210110173730665"></p>
<h2 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h2><p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110173848303.png" alt="image-20210110173848303"></p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p><img src="/2021/01/10/Servlet-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210110173926900.png" alt="image-20210110173926900"></p>
<h3 id="常见响应码"><a href="#常见响应码" class="headerlink" title="常见响应码"></a>常见响应码</h3><table>
<thead>
<tr>
<th align="center">响应码</th>
<th>英文含义</th>
<th>中文含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td>OK</td>
<td>请求成功</td>
</tr>
<tr>
<td align="center">301</td>
<td>Moved Permanently</td>
<td>所请求的页面已转移到一个新的 URL</td>
</tr>
<tr>
<td align="center">302</td>
<td>Found</td>
<td>所请求的页面已临时转移到一个新的 URL</td>
</tr>
<tr>
<td align="center">401</td>
<td>Unauthorized</td>
<td>所请求的页面需要认证登录</td>
</tr>
<tr>
<td align="center">403</td>
<td>Forbidden</td>
<td>禁止访问所请求的页面</td>
</tr>
<tr>
<td align="center">404</td>
<td>Not Found</td>
<td>服务器无法找到所请求的页面</td>
</tr>
<tr>
<td align="center">405</td>
<td>Method Not Allowed</td>
<td>在请求中指定的方法时不允许的</td>
</tr>
<tr>
<td align="center">500</td>
<td>Internal Server Error</td>
<td>未完成的请求，服务器遇到了一个意外的情况</td>
</tr>
<tr>
<td align="center">502</td>
<td>Bad Gateway</td>
<td>未完成的请求，服务器从上游服务器收到无效响应</td>
</tr>
<tr>
<td align="center">503</td>
<td>Service Unavailable</td>
<td>未完成的请求，服务器暂时超载或死机</td>
</tr>
<tr>
<td align="center">504</td>
<td>Gateway Timeout</td>
<td>网关超时</td>
</tr>
</tbody></table>
<h3 id="常见-MIME-类型"><a href="#常见-MIME-类型" class="headerlink" title="常见 MIME 类型"></a>常见 MIME 类型</h3><p>MIME 即 HTTP 协议中的数据类型</p>
<ul>
<li>全称：Multipurpose Internet Mail Extensions『多功能 Internet 邮件扩充服务』</li>
<li>格式为：『大类型/小类型』并与某一种文件的扩展名相对应</li>
</ul>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>扩展名</th>
<th>MIME 类型</th>
</tr>
</thead>
<tbody><tr>
<td>超文本标记语言文本</td>
<td>.html</td>
<td>text/html</td>
</tr>
<tr>
<td>普通文本</td>
<td>.txt</td>
<td>text/plain</td>
</tr>
<tr>
<td>RTF 文本</td>
<td>.rtf</td>
<td>application/rtf</td>
</tr>
<tr>
<td>GIF 图形</td>
<td>.gif</td>
<td>image/gif</td>
</tr>
<tr>
<td>JPEG 图形</td>
<td>.jpeg, .jpg</td>
<td>image/jpeg</td>
</tr>
<tr>
<td>au 声音文件</td>
<td>.au</td>
<td>audio/basic</td>
</tr>
<tr>
<td>MIDI 音乐文件</td>
<td>.mid, .midi</td>
<td>audio/midi, audio/x-midi</td>
</tr>
<tr>
<td>RealAudio 音乐文件</td>
<td>.ra, .ram</td>
<td>audio/x-pn-realaudio</td>
</tr>
<tr>
<td>MPEG 文件</td>
<td>.mpg, .mpeg</td>
<td>video/mpeg</td>
</tr>
<tr>
<td>AVI 文件</td>
<td>.avi</td>
<td>video/x-msvideo</td>
</tr>
<tr>
<td>GZIP 文件</td>
<td>.gz</td>
<td>application/x-gzip</td>
</tr>
<tr>
<td>TAR 文件</td>
<td>.tar</td>
<td>application/x-tar</td>
</tr>
</tbody></table>
<p><strong>完整思维导图地址：</strong><a href="https://www.processon.com/view/link/5ff9ed9c6376897ae0d6c744">Servlet 简明教程</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo + Gitee Pages 搭建个人静态博客</title>
    <url>/2020/09/20/%E4%BD%BF%E7%94%A8Hexo-Gitee-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong><a href="https://hexo.io/zh-cn/">Hexo</a></strong></p>
<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</p>
</blockquote>
<p><strong><a href="https://gitee.com/help/articles/4136">Gitee Pages</a></strong></p>
<blockquote>
<p>码云 Pages 是一个免费的静态网页托管服务，您可以使用 码云 Pages 托管博客、项目官网等静态网页。如果您使用过 Github Pages 那么您会很快上手使用码云的 Pages服务。目前码云 Pages 支持 Jekyll、Hugo、Hexo编译静态资源。</p>
</blockquote>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>点击名称进入官网，根据操作系统下载相应安装包 -&gt; 安装即可</p>
<ul>
<li><strong><a href="https://nodejs.org/zh-cn/">Node.js</a></strong></li>
<li><strong><a href="https://git-scm.com/">Git</a></strong></li>
<li><strong>安装 Hexo 执行以下命令：</strong>  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h3 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h3><p>选择需要创建的项目目录，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init [项目名称，如Blog]</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>到项目路径下修改 <code>_config.yml</code> 文件，将 <code>deploy</code> 节点修改如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Blog</span><br><span class="line">$ vim _config.yml</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repo:</span><br><span class="line">        gitee: git@gitee.com:[UserName]/[UserName].git,master</span><br></pre></td></tr></table></figure>
<p>将以上 [UserName]/[UserName] 修改为自己的项目地址，这里使用的是 SSH 协议</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建仓库需要采用特定的命名方式才能正确将 Hexo 博客部署到站点上，否则可能导致只有博客的主页能访问到，而其他路径全部失效</p>
<h4 id="仓库的命名"><a href="#仓库的命名" class="headerlink" title="仓库的命名"></a>仓库的命名</h4><p>对于 Gitee 可以选择建立一个私人仓库来部署自己的 Hexo 博客，仓库名称就命名为你的账户名<br>在部署成功后即可通过以下 URL 来进行访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://UserName.gitee.io</span><br></pre></td></tr></table></figure>

<h3 id="本地运行进行测试"><a href="#本地运行进行测试" class="headerlink" title="本地运行进行测试"></a>本地运行进行测试</h3><p>在项目根路径下执行 <code>hexo server</code> 或 <code>hexo s</code><br>待命令行显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Start processing</span><br><span class="line">INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to Stop.</span><br></pre></td></tr></table></figure>
<p>打开 <a href="http://localhost:4000/">http://localhost:4000</a> 即可在本地访问</p>
<h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>将博客部署到 Gitee Pages 需要下载以下插件，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>安装成功后即可进行部署，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h3 id="访问进行测试"><a href="#访问进行测试" class="headerlink" title="访问进行测试"></a>访问进行测试</h3><p>访问地址： <code>https://[Gitee用户名].gitee.io</code></p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于编程学习的思考</title>
    <url>/2020/12/03/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直在学习 Java，简单说就仅仅是一门编程语言而已，但是作为一门高级语言它还是拥有很庞大的体系需要仔细研究。就论语言，私自认为语言仅仅是一种工具，无论是作为思想载体的自然语言还是作为软件实现的编程语言来说，我们学习语言的最终目的好像并不是为了研究语言本身，而是能够更好的运用语言，退一步来说，即使我们不能优雅的运用语言，但是用它来达成自己想要达成的目的才应该是它诞生的意义</p>
<h1 id="一、编程需要学习吗"><a href="#一、编程需要学习吗" class="headerlink" title="一、编程需要学习吗"></a>一、编程需要学习吗</h1><p>私自认为编程不应该是一件需要学习的事情，更具体一点的描述是编程不应该成为一件专门费心费力去学习的事。因为广义上编程存在于生活中的方方面面，可以说它是生活中事物的抽象层面的体现。我们为什么要去学习那些我们习以为常的东西呢？说回高级语言，那不过是某一些人制定的某一些规则而已。如果可以，你甚至能够自己制定那些规则，然后通过自己制定的那些规则去实现同样想要实现的目的。这样来看，仿佛现有的有关于编程的技术都是可有可无的，但我想表达的并不是这个意思。现有的技术仅仅是一个过渡，是一个我们不得不选择接受的过渡，当它完成这一阶段，我们将迎来真正的编程自由。简单来说也就是只有到了那个时候，我们才不需要学习编程，而我们现在所学习的也不是真正的编程，而是这个阶段必须要借助的工具的使用方法而已</p>
<h1 id="二、如何学习编程"><a href="#二、如何学习编程" class="headerlink" title="二、如何学习编程"></a>二、如何学习编程</h1><p>私自认为编程最有效率的学习方式还是阅读加实践，因为只有阅读才能找准自己的节奏，无论是吸收新东西的速度还是思考的时机；只有实践才能验证。并不是说视频不可取，目前来看大多数视频都是总结了前人无数的心血，搜罗了全面详实的细节，但是我们是否也忽略了一点，这也是我一直以来所疑惑的问题：我们究竟如何一眼看清一片叶子的全部脉络</p>
<h2 id="2-1、不求甚解"><a href="#2-1、不求甚解" class="headerlink" title="2.1、不求甚解"></a>2.1、不求甚解</h2><p>私自认为，刚开始学习一种编程语言不需要刻意去理解记忆概念的含义，首先通篇阅读了解这种语言的脉络，接着大概了解一下这种语言的语法、特性、API，之后便可以试着写一些小东西出来了，像是简单的计算、打印什么的。这样一来基本使用就算是达到了，这个阶段其实便可以独自完成一些自己想要的功能，所需要的只是自己多思考罢了</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上只是自己当前阶段的一些浅显感悟，如果有不同的看法，欢迎讨论。既然是当前阶段的感悟，那么我也不敢保证我会在什么时间将它推翻重建</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>常用代码片段</title>
    <url>/2020/12/05/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总结一些常用的代码片段，一方面方便 CV，另一方面整理一些解决问题的小技巧</p>
<h1 id="一、关于基础"><a href="#一、关于基础" class="headerlink" title="一、关于基础"></a>一、关于基础</h1><h3 id="toArray-方法"><a href="#toArray-方法" class="headerlink" title="toArray() 方法"></a>toArray() 方法</h3><p>常用的无参方法返回一个 Object[]，通常不方便使用，这里可以使用它的重载方法 public &lt;T&gt; T[] toArray(T[] a)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Integer[] array = arrayList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>归档</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-JUC</title>
    <url>/2020/12/25/%E9%87%8D%E5%AD%A6Java-JUC/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本篇博文为 JUC 技术的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 技能。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><p>在 Java 5.0 提供了 java.util.concurrent (JUC)增加了在并发编程中常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架</p>
<ul>
<li>提供可调的、灵活的线程池</li>
<li>提供用于多线程上下文中的 Collection 实现</li>
</ul>
<h1 id="volatile-关键字与内存可见性"><a href="#volatile-关键字与内存可见性" class="headerlink" title="volatile 关键字与内存可见性"></a>volatile 关键字与内存可见性</h1><h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>内存可见性(Memory Visibility)</p>
<ul>
<li>当某个线程正在使用对象状态，而另一个线程在同时修改该状态，需要确保当一个线程修改了对象的状态后，其他线程能够看到发生的状态变化</li>
</ul>
<p>内存可见性错误(内存可见性问题)</p>
<ul>
<li><p>当读操作与写操作在不同的线程中执行时，无法确保执行读操作的线程能实时地看到其他线程写入的值</p>
</li>
<li><p>当多个线程操作共享数据时，彼此不可见</p>
</li>
<li><p>可以通过同步来保证对象被安全地发布</p>
<ul>
<li>同步锁可解决该问题(效率低)</li>
</ul>
</li>
<li><p>轻量级解决方案：volatile 变量</p>
</li>
</ul>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>volatile 变量是 Java 提供的一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程</p>
<ul>
<li>当多个线程进行操作共享数据时，可以保证内存中的数据可见<ul>
<li>可以将 volatile 看作一个轻量级的锁；与锁的区别：<ul>
<li>不具备『互斥性』：不能阻止另一个线程同时访问共享数据</li>
<li>不能保证变量的『原子性』</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="原子变量与-CAS-算法"><a href="#原子变量与-CAS-算法" class="headerlink" title="原子变量与 CAS 算法"></a>原子变量与 CAS 算法</h1><p>原子变量：JDK1.5 后 java.util.concurrent.atomic 包下提供了常用的原子变量：</p>
<ul>
<li>volatile 保证内存可见性</li>
<li>CAS(Compare-And-Swap) 算法保证数据的原子性<ul>
<li>CAS 算法是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问</li>
<li>CAS 包含了三个操作数<ul>
<li>内存值 V：需要读写的内存值</li>
<li>预估值 A：进行比较的值</li>
<li>更新值 B：拟写入的新值</li>
<li>当且仅当 V == A 时，V = B，否则将不做任何操作<br>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>支持在单个变量上解除锁的线程安全编程</p>
<ul>
<li>AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 这些类的实例各自提供对相应类型单个变量的访问和更新，每个类也为该类型提供适当的实用工具方法</li>
<li>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 这些类进一步扩展了原子操作，对这些类型的数组提供了支持</li>
<li>核心方法：boolean compareAndSet(expectedValue, updareValue)</li>
</ul>
<p>java.util.concurrent.atomic 提供了原子操作的常用类：</p>
<ul>
<li>AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference</li>
<li>AtomicIntegerArray、AtomicLongArray</li>
<li>AtomicMarkableReference</li>
<li>AtomicReferenceArray</li>
<li>AtomicStampedReference</li>
</ul>
<h1 id="ConcurrentHashMap-锁分段机制"><a href="#ConcurrentHashMap-锁分段机制" class="headerlink" title="ConcurrentHashMap 锁分段机制"></a>ConcurrentHashMap 锁分段机制</h1><p>Java 5.0 在 java.util.concurrent 中提供了多种并发容器类来改进同步容器的性能</p>
<p>concurrentHashMap 同步容器类是 Java 5 增加的一个线程安全的哈希表，对于多线程操作，介于 HashMap 与 Hashtable 之间，内部采用 “锁分段”机制代替 Hashtable 的独占锁，进而提高性能</p>
<p>用于多线程上下文中的 Collection 实现：</p>
<ul>
<li>当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap<br>ConcurrentSkipListMap 通常优于同步的 TreeMap</li>
<li>当期望的读和遍历远多于列表的更新时，CopyOnWriteArrayList 优于同步的 ArrayList</li>
</ul>
<h1 id="ConutDownLatch-闭锁"><a href="#ConutDownLatch-闭锁" class="headerlink" title="ConutDownLatch 闭锁"></a>ConutDownLatch 闭锁</h1><p>CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</p>
<p>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动</li>
<li>等待直到某个操作所有参与者都准备就绪再继续执行</li>
</ul>
<h1 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h1><p>创建执行线程的方式有 4 种</p>
<p>相较于实现 Runnable 接口(重写 run 方法)的方式，call 方法可以有返回值，并且可以抛出异常</p>
<p>Callable 方式创建的执行线程需要 FutureTask 实现类的支持，可用于接收运算结果</p>
<ul>
<li>FutureTask 是 Future 接口的实现类</li>
<li>FutureTask 可用于闭锁</li>
</ul>
<h1 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock 同步锁"></a>Lock 同步锁</h1><p>用于解决多线程安全问题的方式：</p>
<ul>
<li>synchronized：隐式锁<ul>
<li>同步代码块</li>
<li>同步方法</li>
</ul>
</li>
<li>JDK 1.5 后：显式锁(可以对锁进行灵活控制)<ul>
<li>同步锁 Lock<ul>
<li>需要通过 lock() 方法上锁，必须通过 unlock() 方法释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：</p>
<ul>
<li><p>通常通过 Lock 接口的实现类创建 lock 对象：Lock lock = new ReentrantLock();</p>
<ul>
<li>ReentrantLock 提供了与 synchronized 相同的互斥性和内存可见性，相较于 synchronized 处理锁的灵活性更高</li>
</ul>
</li>
<li><p>为了确保释放锁操作，通常 unlock() 方法置于 finally 代码块中</p>
</li>
</ul>
<h1 id="生产者消费者案例-虚假唤醒"><a href="#生产者消费者案例-虚假唤醒" class="headerlink" title="生产者消费者案例 - 虚假唤醒"></a>生产者消费者案例 - 虚假唤醒</h1><p>等待唤醒机制，解决生产者消费者存在的问题</p>
<p>为了避免虚假唤醒问题，wait() 方法应该总是用在循环中</p>
<h1 id="Condition-线程通信"><a href="#Condition-线程通信" class="headerlink" title="Condition 线程通信"></a>Condition 线程通信</h1><p>Condition 接口描述了可能会与锁有关联的条件变量</p>
<ul>
<li>这些变量用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能</li>
<li>单个 Lock 可能与多个 Condition 对象关联</li>
<li>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是 await、signal 和 signalAll</li>
<li>Condition 实例实质上被绑定到一个锁上，要为特定 Lock 实例获得 Condition 实例使用 newCondition() 方法</li>
</ul>
<h1 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h1><p>线程锁的关键：</p>
<ul>
<li>非静态方法的锁默认为 this，静态方法的锁为对应的 Class 实例</li>
<li>某一时刻内，无论有多少个方法只能有一个线程持有锁</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程，避免了创建于销毁额外的开销，提高了响应速度</p>
<p>线程池的体系结构：</p>
<ul>
<li>java.util.concurrent.Executor：负责线程的使用与调度的根接口<ul>
<li>ExecutorService 子接口：线程池的主要接口<ul>
<li>ThreadPoolExecutor：线程池的实现类</li>
<li>ScheduledExecutorService 子接口：负责线程的调度<ul>
<li>ScheduledThreadPoolExecutor：继承 ThreadPoolExecutor，实现 ScheduledExecutorService</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>工具类：Executors</p>
<ul>
<li>ExecutorService newFixedThreadPool()：创建固定大小的线程池</li>
<li>ExecutorService new CachedThreadPool()：缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量</li>
<li>ExecutorService newSingleThreadExecutor()：创建单个线程池，线程池中只有一个线程</li>
<li>ScheduledExecutorService newScheduledThreadPool()：创建固定大小的线程池，可以延迟或定时的执行任务</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-异常处理</title>
    <url>/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本篇博文为 Java 异常处理的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h1><p><strong>异常：</strong>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”。(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>Java 程序在执行过程中所发生的异常事件可分为两类：</p>
<ul>
<li>Error：Java 虚拟机无法解决的严重问题。<ul>
<li>如：JVM 系统内部错误、资源耗尽等严重情况。</li>
<li>比如：StackOverflowError(栈溢出) 和 OOM(OutOfMemoryError 堆溢出)</li>
<li>一般不编写针对性的代码进行处理</li>
</ul>
</li>
<li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，例如：<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组下标(索引)越界</li>
</ul>
</li>
</ul>
<p>对于这些错误，一般有两种解决方法：</p>
<ul>
<li>遇到错误就终止程序的运行</li>
<li>在编写程序时，考虑到错误的检测、错误消息的提示以及错误的处理</li>
</ul>
<h1 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h1><p>捕获错误最理想的是在编译期间，但有些错误只有在运行时才会发生，比如：</p>
<ul>
<li>除数为零(一个数除以 0)</li>
<li>数组下标越界</li>
</ul>
<p><strong>分类为：</strong>编译时异常、运行时异常</p>
<h2 id="编译时异常-受检异常-checked"><a href="#编译时异常-受检异常-checked" class="headerlink" title="编译时异常(受检异常 checked)"></a>编译时异常(受检异常 checked)</h2><ul>
<li>Throwable<ul>
<li>Exception<ul>
<li>IOException<ul>
<li>EOFException</li>
<li>FileNotFoundException</li>
<li>MalformedURLException</li>
<li>UnknownHostException</li>
</ul>
</li>
<li>ClassNotFoundException</li>
<li>CloneNotSupportedException</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运行时异常-非受检异常-unchecked"><a href="#运行时异常-非受检异常-unchecked" class="headerlink" title="运行时异常(非受检异常 unchecked)"></a>运行时异常(非受检异常 unchecked)</h2><p>Error</p>
<ul>
<li>RuntiomException<ul>
<li>ArithmeticException</li>
<li>ClassCastException</li>
<li>IllegalArgumentException</li>
<li>IllegalStateException</li>
<li>IndexOutOfBoundsException</li>
<li>NoSuchElementException</li>
<li>NullPointerException</li>
</ul>
</li>
</ul>
<h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">	|----java.lang.Error: 一般不编写针对性的代码进行处理</span><br><span class="line">	|----java.lang.Exception: 可以进行异常的处理</span><br><span class="line">		|----编译时异常(checked)</span><br><span class="line">			|----IOException</span><br><span class="line">				|----FileNotFoundException</span><br><span class="line">            |----ClassNotFoundException</span><br><span class="line">        |----运行时异常(unchecked)</span><br><span class="line">        	|----NullPointerException(空指针异常：引用变量指向 null 使用引用变量时触发)</span><br><span class="line">        	|----ArrayIndexOutOfBoundsException(数组下标越界: array[array.length])</span><br><span class="line">        	|----StringIndexOutOfBoundsException(String 下标越界)</span><br><span class="line">        	|----ClassCastException(类型转换异常: Object obj &#x3D; new Date();String str &#x3D; (String)obj;)</span><br><span class="line">        	|----NumberFormatException(数值格式化异常: String str &#x3D; &quot;a&quot;;int num &#x3D; Integer.parseInt(str);)</span><br><span class="line">        	|----InputMismatchException(输入不匹配异常:Scanner input &#x3D; Scanner(System.in);input.nextInt();此时键盘键入 a 触发)</span><br><span class="line">        	|----ArithmeticException(算数异常: int result &#x3D; 1&#x2F;0;)</span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p><strong>异常的处理：</strong>“抓抛模型”</p>
<ul>
<li>“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。<br>一旦抛出对象后，其后的代码就不再继续执行</li>
<li>“抓”：可以理解为异常的处理方式<ul>
<li>try-catch-finally</li>
<li>throws</li>
</ul>
</li>
</ul>
<p>Java 程序的执行过程中如出现异常，会生成一个异常类对象，该异常类对象将被交给 Java 运行时系统，这个过程称为抛出(throw)异常</p>
<p>异常对象的生成：</p>
<ul>
<li>由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出 —— 自动抛出</li>
<li>由开发人员手动创建：Exception exception = new ClassCastException(); —— 创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</li>
</ul>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p><strong>格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>finally 是可选的</li>
<li>使用 try 将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个异常类的对象，根据此对象的类型，去 catch 中进行匹配</li>
<li>一旦 try 中的异常对象匹配到某一个 catch 时，就进入 catch 中进行异常的处理。一旦处理完成就跳出当前的 try-catch 结构(在没有 finally 的情况)。继续执行其后的代码</li>
<li>catch 中的异常类型如果没有子、父类关系，则声明顺序随意<br>catch 中的异常类型如果满足子、父类关系，则要求子类一定声明在父类之前，否则编译报错</li>
<li>常用的异常对象处理的方式：<ul>
<li>String getMessage()：打印异常信息</li>
<li>printStackTrace()：打印堆栈</li>
</ul>
</li>
<li>在 try 结构中声明的变量，在出了 try 结构后不能再被调用</li>
<li>try-catch-finally 结构可以嵌套</li>
</ul>
<p><strong>注意：</strong>使用 try-catch-finally 处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于使用 try-catch-finally 将一个编译时可能出现的异常延迟到运行时出现</p>
<h2 id="throws-异常类型"><a href="#throws-异常类型" class="headerlink" title="throws + 异常类型"></a>throws + 异常类型</h2><ul>
<li>“throws + 异常类型” 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型<br>一旦方法执行时出现异常，仍会在异常代码处生成一个异常类对象，此对象满足 throws 后的异常类型时，就会被抛出。异常代码后续的代码不再继续执行</li>
<li>try-catch-finally 方式真正的将异常进行了处理<br>throws 方式只是将异常抛给了方法的调用者，并没有真正将异常进行处理</li>
</ul>
<h2 id="try-catch-finally-与-throws-的使用场景"><a href="#try-catch-finally-与-throws-的使用场景" class="headerlink" title="try-catch-finally 与 throws 的使用场景"></a>try-catch-finally 与 throws 的使用场景</h2><p>开发中根据不同场景选用不同的处理方式</p>
<ul>
<li>如果父类中被重写的方法没有 throws 方式处理异常，则子类重写的方法也不能使用 throws，意味着如果子类重写的方法中若涉及异常，必须使用 try-catch-finally 方式处理</li>
<li>要执行的方法中，先后又调用了另外的几个方法，这几个方法是通过递进关系执行的，这时建议这几个方法使用 throws 方式进行处理；而这个要执行的方法可以考虑使用 try-catch-finally 方式进行处理</li>
</ul>
<h2 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h2><p><strong>格式：</strong>throw new 异常类构造器(参数);</p>
<p><strong>throw 和 throws 的区别：</strong></p>
<ul>
<li>throw 表示抛出一个异常类的对象，生成异常类的过程。声明在方法体内</li>
<li>throws 属于异常处理的一种方式，声明在方法的声明处</li>
</ul>
<h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p><strong>自定义异常的方式：</strong></p>
<ul>
<li>继承于现有的异常类：RuntimeException、Exception</li>
<li>提供全局常量：serialVersionUID：(唯一标识)</li>
<li>提供重载的构造器</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java - 基础</title>
    <url>/2020/11/19/%E9%87%8D%E5%AD%A6Java-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本篇博文为 Java 基础阶段的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><p><strong>基本换算：</strong>1MB = 1024KB、1KB = 1024B、1B = 1byte = 8bit</p>
<p><strong>bit(比特、位)：</strong>计算机中的最小存储单位</p>
<p><strong>byte(字节)：</strong>计算机中基本存储单元</p>
<h1 id="Java-基本常识"><a href="#Java-基本常识" class="headerlink" title="Java 基本常识"></a>Java 基本常识</h1><h2 id="java-源文件编程规则"><a href="#java-源文件编程规则" class="headerlink" title=".java 源文件编程规则"></a>.java 源文件编程规则</h2><p>一个 .java 文件中可以有多个 class 但 <strong>public</strong> 修饰的 class 只能有一个</p>
<h2 id="JRE、JDK、JVM-之间的关系"><a href="#JRE、JDK、JVM-之间的关系" class="headerlink" title="JRE、JDK、JVM 之间的关系"></a>JRE、JDK、JVM 之间的关系</h2><ul>
<li>JRE = JVM + Java 核心类库</li>
<li>JDK = JRE + Java 开发工具(javac、java、<strong>javadoc</strong>、…)</li>
</ul>
<h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><ul>
<li>javac 编译 .java 源代码文件为 .class 字节码文件</li>
<li>java 运行 .class 字节码文件<ul>
<li>javac A.java (生成 A.class)</li>
<li>java A (运行 A.class，不需要加 .class 后缀)</li>
</ul>
</li>
</ul>
<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>单行注释：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>

<p><strong>多行注释：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>文档注释：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *文档注释</span></span><br><span class="line"><span class="comment"> *文档注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-关键字与保留字"><a href="#Java-关键字与保留字" class="headerlink" title="Java 关键字与保留字"></a>Java 关键字与保留字</h2><p><strong>命名时要避免使用关键字与保留字</strong></p>
<p><strong>关键字：</strong> 被 Java 赋予特殊作用的单词。关键字中所有字母均小写</p>
<ul>
<li><strong>用于定义数据类型的关键字：</strong>class、interface、enum、byte、short、int、long、float、double、char、boolean、void</li>
<li><strong>用于定义流程控制的关键字：</strong>if、else、switch、case、default、while、do、for、break、continue、return</li>
<li><strong>用于定义访问权限修饰符的关键字：</strong>private、(缺省)、protected、public</li>
<li><strong>用于定义类、方法(函数)、变量修饰符的关键字：</strong>abstract、final、static、synchronized</li>
<li><strong>用于定义类与类之间关系的关键字：</strong>extends、implements</li>
<li><strong>用于定义建立实例及引用实例，判断实例的关键字：</strong>new、this、super、instanceof</li>
<li><strong>用于异常处理的关键字：</strong>try、catch、finally、throw、throws</li>
<li><strong>用于包的关键字：</strong>package、import</li>
<li><strong>其他修饰关键字：</strong>native、strictfp、transient、volatile、assert</li>
<li>*<strong>用于定义数据类型值的字面值：</strong>true、false、null</li>
</ul>
<p><strong>保留字：</strong>Java 现版本尚未使用，但以后版本可能会成为关键字使用：goto、const</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符(凡是可以自己起名字的地方都叫做标识符)</p>
<h3 id="定义合法标识符的规则："><a href="#定义合法标识符的规则：" class="headerlink" title="定义合法标识符的规则："></a>定义合法标识符的规则：</h3><ul>
<li>由数字、字母、下划线( _ )、或 $ 组成</li>
<li>不可以用数字开头</li>
<li>不可以使用关键字和保留字，但可以包含关键字和保留字</li>
<li>严格区分大小写，长度无限制</li>
<li>不能包含空格</li>
<li>见名知义</li>
</ul>
<h3 id="标识符命名规范："><a href="#标识符命名规范：" class="headerlink" title="标识符命名规范："></a>标识符命名规范：</h3><ul>
<li>包名：多单词组成时所有字母均小写(aabbcc)</li>
<li>类名、接口名：多单词组成时，所有单词首字母大写(AaBbCc)</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，其余单词首字母大写(aaBbCc)</li>
<li>常量名：所有字母均大写，多单词组成时每个单词使用下划线( _ )连接(AA_BB_CC)</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>变量用于表示特定类型的数据</li>
<li>变量声明告知编译器根据数据类型为变量分配合适的内存空间</li>
<li>一个变量在使用前必须被声明和初始化</li>
<li>方法中声明的变量在使用之前必须被赋值</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>Java 中每个变量必须先声明后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对 {} 内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量(变量不可以重复声明)</li>
</ul>
<h3 id="分类-按数据类型"><a href="#分类-按数据类型" class="headerlink" title="分类(按数据类型)"></a>分类(按数据类型)</h3><p>Java 对于每一种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同大小的内存空间</p>
<ul>
<li>基本数据类型：<ul>
<li>数值型(整数类型(byte、short、int、long)、浮点类型(float、double))</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型：<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组array([])</li>
</ul>
</li>
</ul>
<h3 id="分类-按变量在类中声明的位置"><a href="#分类-按变量在类中声明的位置" class="headerlink" title="分类(按变量在类中声明的位置)"></a>分类(按变量在类中声明的位置)</h3><ul>
<li>成员变量：实例变量(不以 static 修饰)、类变量(以 static 修饰)</li>
<li>局部变量：形参(方法、构造器中定义的变量)、方法局部变量(在方法内定义)、代码块局部变量(在代码块内定义)</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Java 各整数类型有固定的表数范围和字段长度，不受具体的操作系统(OS)的影响，以保证 Java 程序的可移植性</p>
<p>Java 的整型常量默认为 int 型，声明 long 型常量后必须加 l 或 L 后缀(建议使用 L 便于辨识)<br>Java 程序中变量通常声明为 int 型，除非不足以表示较大的数，才使用 long</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节=8比特</td>
<td>-128 ~ 127 (-2^8 ~ 2^8 - 1)</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2^(2*8-1) ~ 2^(2*8-1) - 1</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2^(4*8-1) ~ 2^(4*8-1) - 1</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-2^(8*8-1) ~ 2^(8*8-1) - 1</td>
</tr>
</tbody></table>
<p><strong>整型数据类型表数范围为：-2^(占用字节数 * 8 - 1) ~ 2^(占用字节数 * 8 - 1) - 1</strong></p>
<p><strong>数值直接量：</strong>为了提高可读性，Java允许在数值直接量的两个数字间使用下划线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> ssn = <span class="number">123_456_789</span>;</span><br></pre></td></tr></table></figure>

<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>同整型，Java 各浮点类型也有固定的表数范围与字段长度，不受具体操作系统影响<br>Java 的浮点型常量默认为 double 型，声明 float 型常量必须加后缀 f 或 F</p>
<ul>
<li>float(单精度)：尾数可以精确到 <code>7</code> 位有效数字(很多情况下精度很难满足需求)</li>
<li>double(双精度)：精度是 float 的两倍(通常采用此类型)</li>
</ul>
<p><strong>浮点型常量两种表示形式：</strong></p>
<ul>
<li>十进制数形式：<code>3.14</code>、<code>6.28F</code>、<code>.1256</code>(必须有小数点)</li>
<li>科学计数法形式：<code>3.14E2</code>、<code>6.28e2</code>、<code>1256E-4</code></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<h3 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h3><p>char 型数据用来表示通常意义上的字符(<code>2</code> 字节)<br>Java 中的所有字符都使用 Unicode 编码，因此一个字符可以存储一个字母、一个汉字或其他书面语的一个字符</p>
<p><strong>字符型变量的三种表现形式：</strong></p>
<ul>
<li>字符常量是通过单引号(‘’)括起来的单个字符 (char a = ‘a’)</li>
<li>直接使用 Unicode 值来表示字符型常量 (‘\uXXXX’，XXXX 代表一个十六进制整数)、(‘\u000a’ 表示 ‘\n’)</li>
<li>Java 中允许使用转义字符 ‘\‘ 来将其后的字符转变为特殊字符型常量</li>
</ul>
<table>
<thead>
<tr>
<th align="center">转义字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘\b’</td>
<td align="center">(退格符)</td>
</tr>
<tr>
<td align="center">‘\n’</td>
<td align="center">(换行符)</td>
</tr>
<tr>
<td align="center">‘\r’</td>
<td align="center">(回车符)</td>
</tr>
<tr>
<td align="center">‘\t’</td>
<td align="center">(制表符)</td>
</tr>
<tr>
<td align="center">‘\‘’</td>
<td align="center">(单引号)</td>
</tr>
<tr>
<td align="center">‘\“‘</td>
<td align="center">(双引号)</td>
</tr>
<tr>
<td align="center">‘\\‘</td>
<td align="center">(反斜杠)</td>
</tr>
</tbody></table>
<p><strong>char 类型是可以进行运算的，因为它都对应有 Unicode 码</strong></p>
<h3 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h3><blockquote>
<p>在计算机内部，所有数据都使用二进制表示。每一个二进制位(bit)有 0 和 1 两种状态，因此 8 个二进制位就可以组合出 256 种状态，这被称为一个字节(byte)。一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从 00000000 到 11111111</p>
<p>ASCII 码：由美国制定的一套字符编码，对英语字符与二进制位之间的关系做了统一规定。ASCII 码一共规定了 128 个字符的编码</p>
<p>空格(‘SPACE’ 是 32(00100000)，’A’ 是 65(01000001)，’a’ 是 97)<br>这 128 个符号(包括 32 个不能打印出来的控制符号)，只占用了一个字节的后面 7 位，最前面的 1 位统一规定为 0</p>
</blockquote>
<h3 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型(boolean)"></a>布尔型(boolean)</h3><p>只包含 true 和 false</p>
<h3 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h3><ul>
<li><p>自动类型转换：容量小的类型自动转换为容量大的数据类型。</p>
</li>
<li><p>强制类型转换：将容量大的数据类型强制转换为容量小的数据类型，可能导致精度降低或溢出</p>
<ul>
<li>通常字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;65&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(a);</span><br></pre></td></tr></table></figure>

<ul>
<li>强制类型转换格式：强转类型 变量 = (强转类型)原变量;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> longType = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">int</span> intType = (<span class="keyword">int</span>)longType;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</p>
</li>
<li><p>byte、short、char 之间不会相互转换，它们三者在计算时首先转换为 int 类型(因为三者之间转换很容易超出表数范围)</p>
</li>
<li><p>boolean 类型不能与其他数据类型运算，不可以转换为其他数据类型        </p>
</li>
<li><p>当把任何基本数据类型的值和字符串(String)进行连接运算时( + )，基本数据类型的值将自动转化为字符串(String)类型</p>
</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>所有数字在计算机底层都以二进制形式存在</p>
<p><strong>对于整数，有四种表示方式：</strong></p>
<ul>
<li>二进制(binary)：0、1，满 2 进 1，以 0b 或 0B 开头表示</li>
<li>十进制(decimal)：0-9，满 10 进 1</li>
<li>八进制(octal)：0-7，满 8 进 1，以数字 0 开头表示</li>
<li>十六进制(hex)：0-9及A-F，满 16 进 1，以 0x 或 0X 开头表示(此处 A-F 不区分大小写)</li>
</ul>
<p><strong>进制转换：</strong></p>
<ul>
<li>十进制转其他进制：十进制数除以其他进制取每次余数的倒序表示</li>
<li>其他进制转十进制：右侧第一个数为起始位 0 位，各位上的数字与进制的位次方的乘积求和</li>
<li>其他进制之间进行转换：先转换为十进制再转换为目标进制</li>
</ul>
<p><strong>二进制：</strong></p>
<p>Java 整数常量默认是 int 类型，当用二进制定义整数时，其第 32 位是符号位。当是 long 类型时，二进制默认占 64 位，其第 64 位是符号位</p>
<p><strong>二进制的整数有三种形式：</strong></p>
<ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：对原码按位取反，最高位(符号位)确定为 1</li>
<li>负数的补码：其反码 +1</li>
</ul>
<p><strong>计算机以二进制补码的形式保存所有的整数</strong></p>
<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数的补码是其反码 +1</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><strong>算数运算符：</strong></p>
<ul>
<li>+、-、*、/、%、++、–</li>
<li>加( + )减( - )可作运算、可表正负，表示正负时优先级最高</li>
<li>自增( ++ )自减( – )运算符在前，先运算后取值、自增自减运算符在后，先取值后运算</li>
<li>% 取模(求余数)、Java 中只有当被除数为负数时结果才为负</li>
</ul>
<p><strong>赋值运算符：</strong></p>
<ul>
<li>=、+=、-=、*=、/=、%=</li>
<li>当( = )两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li>
<li>支持连续赋值</li>
</ul>
<p><strong>比较运算符(关系运算符)：</strong></p>
<ul>
<li>==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof</li>
<li>instanceof 检查是否是类的对象</li>
<li>比较运算符的结果都是 boolean 型，要么是 true 要么是 false</li>
</ul>
<p><strong>逻辑运算符：</strong></p>
<ul>
<li><p>&amp;：逻辑与、&amp;&amp;：短路与、|：逻辑或、||：短路或、!：逻辑非、^：逻辑异或</p>
</li>
<li><p>区分 &amp; 与 &amp;&amp;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  当 b1、b2 为 true 时打印结果为</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  num1 = 11</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  num2 = 11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  当 b1、b2 为 false 时打印结果为</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  num1 = 11</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  num2 = 10</span></span><br><span class="line"><span class="comment">  &amp; 为逻辑与、&amp;&amp; 为短路与</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// b1 = false</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (b1 &amp; (num1++ &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// b2 = false</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (b2 &amp;&amp; (num2++ &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br></pre></td></tr></table></figure>

<ul>
<li>区分 | 与 ||</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  当 b1、b2 为 true 时打印结果为</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  num1 = 11</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  num2 = 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  当 b1、b2 为 false 时打印结果为</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  num1 = 11</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  num2 = 11</span></span><br><span class="line"><span class="comment">  | 为逻辑或、|| 为短路或</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// b1 = false</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (b1 | (num1++ &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// b2 = false</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (b2 || (num2++ &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br></pre></td></tr></table></figure>

<p><strong>位运算符：</strong></p>
<ul>
<li>&lt;&lt;：左移(3&lt;&lt;2=12：3*2*2=12)、&gt;&gt;：右移(3&gt;&gt;1=1：3/2=1)、&gt;&gt;&gt;：无符号右移、&amp;：与运算、|：或运算、^：异或运算、~：取反运算</li>
<li>&lt;&lt;：在一定范围内，每向左移 <code>1</code> 位，相当于 <code>* 2</code></li>
<li>&gt;&gt;：在一定范围内，每向右移 <code>1</code> 位，相当于 <code>/ 2</code></li>
</ul>
<p><strong>位运算符的细节：</strong></p>
<ul>
<li>&lt;&lt;：被移除的高位丢弃，空缺位补 <code>0</code></li>
<li>&gt;&gt;：被移位的二进制最高位为 <code>0</code>，右移后，空缺位补 <code>0</code>；最高位为 <code>1</code>，右移后，空缺位补 <code>1</code></li>
<li>&gt;&gt;&gt;：被移位二进制最高位无论是 <code>0</code> 或 <code>1</code>，空缺位都用 <code>0</code> 补</li>
<li>&amp;：二进制位进行 <code>&amp;</code> 运算，只有 <code>1 &amp; 1</code> 时结果为 <code>1</code>，否则是 <code>0</code></li>
<li>|：二进制位进行 <code>|</code> 运算，只有 <code>0 | 0</code> 时结果是 <code>0</code>，否则是 <code>1</code></li>
<li>^：相同的二进制位进行 <code>^</code> 运算，结果是 <code>0</code>(<code>1^1=0</code>、<code>0^0=0</code>)、不相同的二进制位 <code>^</code> 运算结果是 <code>1</code>(<code>1^0=1</code>、<code>0^1=1</code>)</li>
<li>~：正数取反，各二进制码按补码各位取反、负数取反，各二进制位按补码各位取反</li>
</ul>
<p><strong>位运算是直接对整数的二进制进行的运算</strong></p>
<p><strong>三元运算符：</strong></p>
<p>格式：(条件表达式) <code>?</code> 表达式1 <code>:</code> 表达式2</p>
<ul>
<li>条件表达式结果为 true，运算后结果是：表达式1</li>
<li>条件变大时结果为 false，运算后结果是：表达式2</li>
<li>表达式1 和表达式2 是同种类型(整型类型自动类型提升)</li>
</ul>
<p><strong>三元运算符与 if-else 的联系与区别:</strong></p>
<ul>
<li>三元运算符可以简化 if-else 语句</li>
<li>三元运算符要求必须返回一个结果</li>
<li>if 后的代码块可以有多个语句</li>
<li>三元运算符可以嵌套使用</li>
<li>凡是可以使用三元运算符的地方都可以改写为 if-else 语句，反之不可以</li>
</ul>
<p><strong>运算符的优先级(运算顺序)：</strong>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>程序从上到下逐行执行，中间没有任何判断和跳转</p>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>根据条件，选择性地执行某段代码</p>
<blockquote>
<p>if…else 分支语句、switch-case 分支语句</p>
</blockquote>
<p><strong>if…else 分支语句：</strong></p>
<p>第一种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    执行表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种(二选一)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    执行表达式<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种(多选一)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    执行表达式<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">    执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    执行表达式 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch-case 分支语句：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据 switch 表达式的值，依次匹配各个 case 中的常量。一旦匹配成功，则进入相应 case 结构中，调用其执行语句</li>
<li>当调用完执行语句后，则仍然继续向下执行其他 case 结构中的执行语句，直到遇到 break 关键字或此 switch-case 结构末尾结束为止</li>
<li>break 可以使用在 switch-case 结构中，表示一旦执行到此关键字，就跳出 switch-case 结构</li>
<li><strong>switch 结构中的表达式，只能是：byte、short、char、int、枚举类型(JDK5.0新增)、String(JDK7.0新增) 类型之一</strong></li>
<li>case 子句中的值只能是常量，不能是变量名或不确定的表达式值，同一个 switch 语句，所有 case 子句中的值不相同</li>
<li>break 关键字用来在执行完一个 case 分支后使程序跳出 switch 语句块，如果没有 break，程序会顺序执行到 switch 结尾</li>
<li>default 子句是可选的。同时位置也是灵活的，当没有匹配的 case 时，执行 default 子句</li>
</ul>
<p><strong>if-else 与 switch-case 的关系：</strong></p>
<ul>
<li>凡是可以使用 switch-case 的结构，都可以转换为 if-else。反之不成立</li>
<li>当分支结构既可以使用 switch-case 又可以使用 if-else (同时，<strong>switch</strong> 中表达式的取值情况不太多)，优先选择 switch-case，因其执行效率稍高</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>根据循环条件，重复性地执行某段代码</p>
<blockquote>
<p>while 循环语句、do…while 循环语句、for 循环语句</p>
<p>JDK1.5 后提供了 foreach 循环，方便遍历集合、数组元素</p>
</blockquote>
<p>循环语句的四个组成部分：初始化部分(初始化条件)、循环条件部分(循环条件，boolean 类型)、循环体部分(循环体)、迭代部分(迭代条件)</p>
<p>for 循环的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化条件; 循环条件; 迭代条件) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while `循环的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化条件</span><br><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">    迭代条件;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：while 循环没有或错误的迭代条件可能导致死循环</strong></p>
<p>do-while 循环的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化条件</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体;</span><br><span class="line">    迭代条件;</span><br><span class="line">&#125; <span class="keyword">while</span> (循环条件)</span><br></pre></td></tr></table></figure>

<p><strong>while 循环与 do-while 循环的区别在于执行过程，do-while 循环至少会执行一次循环体</strong></p>
<p><strong>最简单的 “无限” 循环格式：</strong><code>while(true)</code>、<code>for(;;)</code></p>
<ul>
<li>无限循环存在的目的：当程序并不知道需要循环多少次时，需要根据循环体内部某些条件来控制循环的结束</li>
</ul>
<p><strong>循环结构可以嵌套使用</strong></p>
<p><strong>break 和 continue 关键字的使用：</strong></p>
<ul>
<li>break<ul>
<li>使用范围：switch-case、循环结构</li>
<li>作用(不同点)：结束当前</li>
</ul>
</li>
<li>continue<ul>
<li>使用范围：循环结构</li>
<li>作用(不同点)：结束当次</li>
</ul>
</li>
<li>相同点：关键字后不能声明执行语句</li>
</ul>
<p><strong>带标识的 break 和 continue：</strong>结束指定标识的一层循环结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求 100000 以内的质数</span></span><br><span class="line">label:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>多个相同类型数据按一定顺序排列的集合，并使用一个变量命名，通过编号的方式对这些数据进行统一管理</p>
<p><strong>数组的分类</strong></p>
<ul>
<li>按照维度：一维数组、二维数组、…</li>
<li>按照元素的数据类型：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)</li>
</ul>
<p><strong>数组的长度：</strong>数组中元素的个数</p>
<p><strong>数组的特点：</strong></p>
<ul>
<li>数组是有序排列的</li>
<li>数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址</li>
<li>数组的长度一旦确定就不能修改</li>
<li>可以通过下标(或索引)的方式调用指定位置的元素</li>
</ul>
<h3 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h3><p><strong>一维数组的声明和初始化：</strong></p>
<ul>
<li>声明：int[] array;</li>
<li>静态初始化：数组的初始化和数组元素的赋值操作同时进行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态初始化：数组的初始化和数组元素的赋值操作分开进行<ul>
<li>数组一旦初始化完成，其长度就确定了</li>
<li>类型推断：int[] array = {1, 2, 3, 4};</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p><strong>调用数组的指定位置的元素：</strong></p>
<ul>
<li>使用索引的方式调用</li>
<li>数组的索引从 0 开始，到数组长度 - 1 结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>获取数组的长度：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array.length;</span><br><span class="line">names.length;</span><br></pre></td></tr></table></figure>

<p><strong>遍历数组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; ++i) &#123;</span><br><span class="line">    System.out.println(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String e: names) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组元素的默认初始化值：</strong></p>
<ul>
<li>数组元素是整型：<code>0</code></li>
<li>数组元素是浮点型：<code>0.0</code></li>
<li>数组元素是 <code>char</code> 型：<code>0</code> 或 <code>&#39;\u0000&#39;</code> 而非 <code>&#39;0&#39;</code></li>
<li>数组元素是 <code>boolean</code> 型：<code>false</code></li>
<li>数组元素是引用数据类型：<code>null</code></li>
</ul>
<p><strong>数组的内存解析：</strong></p>
<ul>
<li><p>内存的简化结构：</p>
<ul>
<li>栈(stack)：局部变量</li>
<li>堆(heap)：new 出来的结构：对象、数组</li>
<li>方法区：常量池、静态域</li>
</ul>
</li>
<li><p>数组名(变量)在栈空间中，new 出的数组对象(连续空间，以首地址值表示)在堆空间中</p>
</li>
<li><p>默认值替换为初始化值</p>
</li>
<li><p>将首地址值赋给数组名(变量)，通过数组名(变量、首地址值)就可以访问堆空间中的数组对象</p>
</li>
</ul>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>可以把一维数组当成是表格的某一行，那么二维数组就相当于是一整个有多行多列的完整表格</p>
<p>对于二维数组，可以看作是某个一维数组的元素又是一个一维数组，这个元素是一维数组的数组就是二维数组</p>
<p>本质上从数组的底层运行机制来看其实没有多维数组</p>
<p><strong>二维数组的声明和初始化：</strong></p>
<ul>
<li>静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[][] array2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>动态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[][] array3 = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure>

<ul>
<li>如下也正确</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array4[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array5[] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;  <span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure>

<p><strong>二维数组的使用：</strong></p>
<p>规定：二维数组分为外层数组的元素，内层数组的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>外层元素：<code>array[0]</code>、<code>array[1]</code></li>
<li>内层元素：<code>array[0][0]</code>、<code>array[1][1]</code></li>
</ul>
<p><strong>二维数组的默认初始化值：</strong></p>
<ul>
<li><p>针对初始化方式一：<code>int[][] array = new int[4][3];</code></p>
<ul>
<li>外层元素的初始化值为：(带数据类型的)地址值</li>
<li>内层元素的初始化值为：与一维数组初始化情况一致</li>
</ul>
</li>
<li><p>针对初始化方式二：<code>int[][] array = new int[4][];</code></p>
<ul>
<li>外层元素的初始化值为：<code>null</code></li>
<li>内层元素的初始化值为：不能调用，否则报错</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-JDBC及数据库连接池</title>
    <url>/2020/12/24/%E9%87%8D%E5%AD%A6Java-JDBC%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本篇博文为 JDBC 技术的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 技能。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><strong>数据的持久化：</strong>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用</p>
<h2 id="Java-中的数据存储技术"><a href="#Java-中的数据存储技术" class="headerlink" title="Java 中的数据存储技术"></a>Java 中的数据存储技术</h2><ul>
<li>JDBC：直接访问数据库</li>
<li>JDO(Java Data Object) 技术</li>
<li>第三方 O/R 工具，如 Hibernate、Mybatis 等</li>
</ul>
<p>JDBC 是 Java 访问数据库的基础，JDO、Hibernate、Mybatis 等只是更好的封装了 JDBC</p>
<h2 id="JDBC-技术"><a href="#JDBC-技术" class="headerlink" title="JDBC 技术"></a>JDBC 技术</h2><p>JDBC(Java Database Connectivity) 是一个独立于特定数据库管理系统、通用的 SQL 数据库存取和操作的公共接口，定义了用来访问数据库的标准 Java 类库(java.sql、javax.sql)，使用这些类库可以以一种标准的方法方便地访问数据库资源</p>
<ul>
<li>为访问不同的数据库提供了一种统一的途径</li>
</ul>
<h3 id="JDBC-体系结构"><a href="#JDBC-体系结构" class="headerlink" title="JDBC 体系结构"></a>JDBC 体系结构</h3><ul>
<li>面向应用的 API：Java API，抽象接口，供应用程序开发人员使用</li>
<li>面向数据库的 API：Java Driver API，供开发商开发数据库驱动程序</li>
</ul>
<h3 id="DAO-及相关实现类"><a href="#DAO-及相关实现类" class="headerlink" title="DAO 及相关实现类"></a>DAO 及相关实现类</h3><p>DAO：Data Access Object 访问数据信息的类和接口，包括了对数据的 CRUD (Create、Retrival、Update、Delete)，而不包含任何业务相关的信息，也称作 BaseDAO</p>
<ul>
<li>作用：实现功能的模块化，更有利于代码的维护和升级</li>
</ul>
<h2 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h2><h3 id="Driver-接口"><a href="#Driver-接口" class="headerlink" title="Driver 接口"></a>Driver 接口</h3><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口</p>
<ul>
<li>供数据库厂商使用，以提供不同的实现(以 jar 包形式提供)<ul>
<li>Oracle 驱动：oracle.jdbc.driver.OracleDriver</li>
<li>MySQL 驱动：com.mysql.jdbc.Driver</li>
<li>习惯上置于 Java 工程目录 lib 下 Add to Build Path</li>
<li>针对 Dynamic Web Project 置于 WebContent(或 WebRoot) 中 WEB-INF 中 lib 下</li>
</ul>
</li>
<li>不需要直接访问实现 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些 Driver 实现</li>
</ul>
<h3 id="加载与注册-JDBC-驱动"><a href="#加载与注册-JDBC-驱动" class="headerlink" title="加载与注册 JDBC 驱动"></a>加载与注册 JDBC 驱动</h3><p><strong>加载驱动：</strong>调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li>Class.forName(“com.mysql.jdbc.Driver”);</li>
</ul>
<p><strong>注册驱动：</strong>DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li>DriverManager.registerDriver(com.mysql.jdbc.Driver);</li>
<li>通常不需要显式调用，Driver 接口的驱动程序类都包含了静态代码块，在其中会调用 DriverManager.registerDriver() 方法来注册自身的一个实例</li>
<li>MySQL 的 Driver 实现类的源码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接</p>
<p>JDBC URL 的标准由三部分组成，各部分间用冒号( : )分隔</p>
<ul>
<li>jdbc:子协议:子名称</li>
<li>协议：JDBC URL 中的协议总是 jdbc</li>
<li>子协议：子协议用于标识一个数据库驱动程序</li>
<li>子名称：一种标识数据库的方法<ul>
<li>子名称可以依不同的子协议而变化，子名称为定位数据库提供足够的信息；包含主机名(对应服务端的 ip 地址)、端口号、数据库名</li>
<li>jdbc:mysql://localhost:3306/test<ul>
<li>协议：jdbc</li>
<li>子协议：mysql</li>
<li>子名称：localhost:3306/test</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>常用数据库的 JDBC URL：</p>
<ul>
<li>MySQL<ul>
<li>jdbc:mysql://主机名称:MySQL 服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>参数：useUnicode=true&amp;characterEncoding=utf8<ul>
<li>若 JDBC 程序与服务器端字符集不一致，会导致乱码，可通过参数指定服务器端的字符集</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="建立并获取连接"><a href="#建立并获取连接" class="headerlink" title="建立并获取连接"></a>建立并获取连接</h3><p>调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</p>
<ul>
<li>user、password 可通过 “属性名=属性值” 的方式传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置</span></span><br><span class="line">    InputStream inputStream = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">    pros.load(inputStream);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    String driverClassName = pros.getProperty(<span class="string">&quot;driverClassName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载驱动</span></span><br><span class="line">    Class.forName(driverClassName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立并获取连接</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">    </span><br><span class="line">    System.out.println(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jdbc.properties：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user&#x3D;user</span><br><span class="line">password&#x3D;password</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">driverClassName&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><p>java.sql 包含 3 个接口分别定义了对数据库的调用的不同方式</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象</li>
<li>PreparedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行 SQL 语句</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<h3 id="Statement-操作数据库的弊端"><a href="#Statement-操作数据库的弊端" class="headerlink" title="Statement 操作数据库的弊端"></a>Statement 操作数据库的弊端</h3><p>通过调用 Connection 对象的 createStatement() 方法创建该对象，Statement 接口中定义了如下方法用于执行 SQL 语句：</p>
<ul>
<li>int executeUpdate(String sql)：执行更新操作(INSERT、UPDATE、DELETE)</li>
<li>ResultSet executeQuery(String sql)：执行查询操作(SELECT)</li>
</ul>
<p><strong>使用 Statement 操作数据表存在的弊端：</strong></p>
<ul>
<li>需要拼接字符串，操作繁琐</li>
<li>存在 SQL 注入问题<ul>
<li>利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令从而利用系统的 SQL 引擎完成恶意行为</li>
</ul>
</li>
</ul>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>通过调用 Connection 对象 的 prepareStatement(String sql) 方法获取 PreparedStatement 对象</p>
<ul>
<li>PreparedStatement 接口是 Statement 的子接口，表示一条预编译过的 SQL 语句</li>
<li>PreparedStatement 对象所代表的 SQL 语句中的参数使用问号( ? )表示，调用 PreparedStatement 对象的 setXxx(index, value) 方法设置具体参数值<ul>
<li>index 代表参数的索引(从 1 起始)</li>
<li>value 代表具体的参数值</li>
</ul>
</li>
</ul>
<h3 id="PreparedStatement-与-Statement-的对比"><a href="#PreparedStatement-与-Statement-的对比" class="headerlink" title="PreparedStatement 与 Statement 的对比"></a>PreparedStatement 与 Statement 的对比</h3><p>PreparedStatement 能最大可能提高性能：</p>
<blockquote>
<p>DBServer 会对预编译语句提供性能优化</p>
<p>因预编译语句有可能被重复调用，所以语句在被 DBServer 的编译器编译后的执行代码被缓存下来，下一次调用时只要是相同的预编译语句便只需将参数直接传入编译过的语句执行代码中就会得到执行</p>
</blockquote>
<p>PreparedStatement 可以防止 SQL 注入</p>
<h3 id="Java-与-SQL-数据类型的对应关系"><a href="#Java-与-SQL-数据类型的对应关系" class="headerlink" title="Java 与 SQL 数据类型的对应关系"></a>Java 与 SQL 数据类型的对应关系</h3><table>
<thead>
<tr>
<th>Java 类型</th>
<th>SQL 类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR、VARCHAR、LONGVARCHAR</td>
</tr>
<tr>
<td>byte array</td>
<td>BINARY、VARBINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h3 id="PreparedStatement-实现增、删、改操作"><a href="#PreparedStatement-实现增、删、改操作" class="headerlink" title="PreparedStatement 实现增、删、改操作"></a>PreparedStatement 实现增、删、改操作</h3><p>DBUtils：import org.apache.commons.dbutils.DbUtils;</p>
<p>BaseDAO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; cls;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 获取带泛型的父类 */</span></span><br><span class="line">        Type genericSuperclass = <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">/* 获取父类的泛型 */</span></span><br><span class="line">        Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">        cls = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 增、删、改操作 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection connection, String sql, Object ...args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询操作，获取单条记录 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getQuery</span><span class="params">(Connection connection, String sql, Object ...args)</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PreparedStatement 实现增、删、改操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection connection, String sql, Object ...args)</span> </span>&#123;</span><br><span class="line">    PreparedStatement pStatement = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pStatement = connection.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">            pStatement.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pStatement,executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exceptopn exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        DBUtils.closeQuietly(pStatement);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatement-实现查询操作"><a href="#PreparedStatement-实现查询操作" class="headerlink" title="PreparedStatement 实现查询操作"></a>PreparedStatement 实现查询操作</h3><p>返回单条记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getQuery</span><span class="params">(Connection connection, String sql, Object ...args)</span> </span>&#123;</span><br><span class="line">    PreparedStatement pStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pStatement = connection.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">            pStatement.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        resultSet = pStatement.executeQuery();</span><br><span class="line">        ResultSetMetaData resultSetMetaData = resultSet.getMetaData();</span><br><span class="line">        <span class="keyword">int</span> columnCount = resultSetMetaData.getColumnCount();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">            T t = cls.newInstance();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; ++i) &#123;</span><br><span class="line">                String columnLabel = resultSetMetaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                Object columnValue = resultSet.getObject(i + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                Field field = cls.getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(t, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DBUtils.closeQuietly(pStatement);</span><br><span class="line">            DBUtils.closeQuietly(resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回多条记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getQueryList</span><span class="params">(Connection connection, String sql, Object ...args)</span> </span>&#123;</span><br><span class="line">    PreparedStatement pStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pStatement = connection.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">            pStatement.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        resultSet = pStatement.executeQuery();</span><br><span class="line">        ResultSetMetaData resultSetMetaData = resultSet.getMetaData();</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> columnCount = resultSetMetaData.getColumnCount();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            T t = cls.getInstance();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; ++i) &#123;</span><br><span class="line">                String columnLabel = resultSetMetaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                Object columnValue = resultSet.getObject(i + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                Field field = cls.getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(t, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        DBUtils.closeQuietly(pStatement);</span><br><span class="line">        DBUtils.closeQuietly(resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ResultSet：</strong></p>
<blockquote>
<ul>
<li><p>PreparedStatement 对象的 executeQuery() 方法返回一个 ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表，有一个指针指向数据表的第一条记录的前面</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行</p>
<ul>
<li>调用 next() 方法检测下一行是否有效，若有效返回 true，且指针下移。相当于 Iterator 对象的 hasNext() 和 next() 方法的结合体</li>
</ul>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(index) 或 getXxx(columnName) 获取每一列的值</p>
<ul>
<li>例：getInt(1)、getString(“name”)</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>ResultSetMetaData：</strong></p>
<blockquote>
<ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData resultSetMetaData = resultSet.getMetaData();</p>
<ul>
<li>getColumnName(int column)：获取指定列的名称</li>
<li>getColumnLabel(int column)：获取指定列的别名</li>
<li>getColumnCount()：返回当前 ResultSet 对象中的列数</li>
<li>getColumnTypeName(int column)：返回指定列的数据库特定的类型名称</li>
<li>getColumnDisplaySize(int column)：返回指定列的最大标准宽度，以字符为单位</li>
<li>isNullable(int column)：返回指定列中的值是否可以为 null</li>
<li>isAutoIncrement(int column)：返回是否自动为指定列进行编号，这样这些列仍然是只读的</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>资源的释放：</strong></p>
<blockquote>
<ul>
<li>释放 ResultSet、Statement、Connection</li>
<li>Connection 的使用原则是<strong>尽量晚创建，尽量早释放</strong></li>
<li>可以在 finally 中关闭，保证即使其他代码出现异常，资源也一定能被关闭</li>
</ul>
</blockquote>
<h3 id="ORM-思想-Object-Relational-Mapping"><a href="#ORM-思想-Object-Relational-Mapping" class="headerlink" title="ORM 思想(Object Relational Mapping)"></a>ORM 思想(Object Relational Mapping)</h3><ul>
<li>一个数据表对应一个 Java 类</li>
<li>表中的一条记录对应 Java 类的一个对象</li>
<li>表中的一个字段对应 Java 类的一个属性</li>
</ul>
<h3 id="操作-BLOB-类型字段"><a href="#操作-BLOB-类型字段" class="headerlink" title="操作 BLOB 类型字段"></a>操作 BLOB 类型字段</h3><p><strong>MySQL BLOB 类型：</strong></p>
<ul>
<li>MySQL 中，BLOB 是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据</li>
<li>插入 BLOB 类型的数据必须使用 PreparedStatement，因为 BLOB 类型的数据无法使用字符串拼接</li>
<li>MySQL 的四种 BLOB 类型(除了在存储的最大信息量上不同外，它们是等同的)<ul>
<li>TinyBlob：最大 255 字节</li>
<li>Blob：最大 65 K</li>
<li>MediumBlob：最大 16 M</li>
<li>LongBlob：最大 4 G</li>
</ul>
</li>
<li>实际使用中根据需要存入的数据大小定义不同的 BLOB 类型</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降</li>
<li>若在指定了相关的 Blob 类型以后报错：xxx too large<ul>
<li>需如下配置：MySQL 的安装目录下 my.ini 文件追加配置参数：max_allowed_packet=16M</li>
<li>修改 my.ini 文件后需要重新启动 MySQL 服务</li>
</ul>
</li>
</ul>
<h3 id="批量执行SQL语句"><a href="#批量执行SQL语句" class="headerlink" title="批量执行SQL语句"></a>批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用 Java 的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理</p>
<p>JDBC 的批量处理语句包括下面三个方法：</p>
<ul>
<li>addBatch()：添加需要批量处理的 SQL 语句或是参数</li>
<li>executeBatch()：执行批量处理语句</li>
<li>clearBatch()：清空缓存的数据</li>
</ul>
<p>通常会遇到两种批量执行 SQL 语句的情况：</p>
<ul>
<li>多条 SQL 语句的批量处理</li>
<li>一个 SQL 语句的批量传参</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into table(name) values(?)&quot;</span>;</span><br><span class="line">PreparedStatement pStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    pStatement.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    pStatement.addBatch();</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">500</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        pStatement.executeBatch();</span><br><span class="line">        pStatement.clearBatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>例子(优化)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 不进行自动提交</span></span><br><span class="line">connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;insert into table(name) values(?)&quot;</span>;</span><br><span class="line">PreparedStatement pStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    pStatement.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    pStatement.addBatch();</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">500</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        pStatement.executeBatch();</span><br><span class="line">        pStatement.clearBatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交</span></span><br><span class="line">connection.commit();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>事务：一组逻辑操作单元，使数据从一种状态转变到另一种状态</p>
</li>
<li><p>事务处理(事务操作)：保证所有事务都作为一个工作单元来执行，即使出现了故障都不能改变这种执行方式</p>
<ul>
<li>当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；<br>要么数据库管理系统将放弃所做的所有修改，整个事务回滚(rollback)到最初状态</li>
</ul>
</li>
</ul>
<p>为确保数据库中数据的一致性，数据的操作应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为失败，所有从起始点以后的操作应全部回退到开始状态</p>
<h2 id="JDBC-事务处理"><a href="#JDBC-事务处理" class="headerlink" title="JDBC 事务处理"></a>JDBC 事务处理</h2><ul>
<li>数据一旦提交便不可回滚</li>
<li>数据什么时候意味着提交：<ul>
<li>当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交而不能回滚</li>
<li>关闭数据库连接，数据就会自动的提交<ul>
<li>若有多个操作，每个操作使用的是自己单独的连接，则无法保证事务</li>
<li>即同一个事务的多个操作必须在同一个连接下</li>
</ul>
</li>
</ul>
</li>
<li>JDBC 中让多个 SQL 语句作为一个事务执行：<ul>
<li>调用 Connection 对象的 setAutoCommit(false); 取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</li>
<li>在出现异常时，调用 rollback(); 方法回滚事务</li>
<li>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态(setAutoCommit(true))<ul>
<li>尤其在使用数据库连接池技术时，执行 close() 方法前，建议恢复自动提交状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事务的-ACID-属性"><a href="#事务的-ACID-属性" class="headerlink" title="事务的 ACID 属性"></a>事务的 ACID 属性</h2><ul>
<li>原子性(Atomicity)<ul>
<li>原子性指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li>
</ul>
</li>
<li>一致性(Consistency)<ul>
<li>一致性指事务必须使数据库从一个一致性状态转换到另外一个一致性状态</li>
</ul>
</li>
<li>隔离性(Isolation)<ul>
<li>隔离性指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对于并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
</ul>
</li>
<li>持久性(Durability)<ul>
<li>持久性指一个事务一旦被提交，它对数据库中数据的改变就是永久的，接下来的其他操作和数据库故障不应该对其有任何影响</li>
</ul>
</li>
</ul>
<h2 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h2><p>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，若没有采取必要的隔离机制，就会导致各种并发问题</p>
<ul>
<li>脏读：对于两个事务 T1、T2，T1 读取了已经被 T2 更新但还<strong>未被提交的字段</strong>。若 T2 回滚，T1 读取的内容就是临时且无效的</li>
<li>不可重复读：对于两个事务 T1、T2，T1 读取了一个字段，然后 T2 <strong>更新</strong>了该字段。若 T1 再次读取同一个字段，值被更新</li>
<li>幻读：对于两个事务 T1、T2，T1 从一个表中读取了一个字段，然后 T2 在该表中<strong>插入</strong>了一些新的行。若 T1 再次读取同一个表，便会多出新行</li>
</ul>
<p><strong>数据库事务的隔离性：</strong>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题</p>
<p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱</p>
<h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED<br>(读未提交数据)</td>
<td>允许事务读取未被其他事务提交的变更。脏读、不可重复读和幻读的问题都会出现</td>
</tr>
<tr>
<td>READ COMMITTED<br>(读已提交数据)</td>
<td>只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可重复读和幻读问题仍然可能出现</td>
</tr>
<tr>
<td>REPEATABLE READ<br>(可重复读)</td>
<td>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读，但幻读的问题仍然存在</td>
</tr>
<tr>
<td>SERIALIZABLE<br>(串行化)</td>
<td>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有并发问题都可以避免，但性能十分低下</td>
</tr>
</tbody></table>
<ul>
<li>Oracle 支持的两种事务隔离级别：READ COMMITTED、SERIALIZABLE<ul>
<li>默认的事务隔离级别为：READ COMMITTED</li>
</ul>
</li>
<li>MySQL 支持四种事务隔离级别<ul>
<li>默认的事务隔离级别为：REPEATABLE READ</li>
</ul>
</li>
</ul>
<h3 id="在-MySQL-中设置隔离级别"><a href="#在-MySQL-中设置隔离级别" class="headerlink" title="在 MySQL 中设置隔离级别"></a>在 MySQL 中设置隔离级别</h3><ul>
<li>每启动一个 MySQL 程序就会获得一个单独的数据库连接，每个数据库临界都有一个全局变量 @@tx_isolation 表示当前的事务隔离级别</li>
<li>查看当前的隔离级别：SELECT @@tx_isolation;</li>
<li>设置当前 MySQL 连接的隔离级别：set transaction isolation level read committed;</li>
<li>设置数据库系统的全局的隔离级别：set global transaction isolation level read committed;</li>
</ul>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="数据库连接池的必要性"><a href="#数据库连接池的必要性" class="headerlink" title="数据库连接池的必要性"></a>数据库连接池的必要性</h2><p>普通的 JDBC 数据库连接：</p>
<ul>
<li><p>使用 DriverManager 获取</p>
</li>
<li><p>每次向数据库建立连接时都要将 Connection 加载到内存中，再验证用户名、密码</p>
</li>
<li><p>需要时申请，执行完成断开连接，消耗大量资源和时间、数据库的连接资源并没有很好的重复利用</p>
</li>
<li><p>频繁的进行数据库连接操作将占用很多的系统资源</p>
</li>
<li><p>不能控制被创建的连接对象数 </p>
</li>
</ul>
<h2 id="数据库连接池技术"><a href="#数据库连接池技术" class="headerlink" title="数据库连接池技术"></a>数据库连接池技术</h2><ul>
<li><strong>数据库连接池的基本思想：</strong>为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去</li>
<li><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong></li>
<li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的<ul>
<li>无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量</li>
<li>连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li>
</ul>
</li>
</ul>
<h3 id="数据库连接池技术的优点"><a href="#数据库连接池技术的优点" class="headerlink" title="数据库连接池技术的优点"></a>数据库连接池技术的优点</h3><ul>
<li><p>资源重用</p>
<ul>
<li>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销</li>
<li>在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li>
</ul>
</li>
<li><p>更快的系统反应速度</p>
<ul>
<li>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用</li>
<li>此时连接的初始化工作均已完成</li>
<li>对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</li>
</ul>
</li>
<li><p>新的资源分配手段</p>
<ul>
<li>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</li>
</ul>
</li>
<li><p>统一的连接管理，避免数据库连接泄漏</p>
<ul>
<li>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</li>
</ul>
</li>
</ul>
<h2 id="开源的数据库连接池"><a href="#开源的数据库连接池" class="headerlink" title="开源的数据库连接池"></a>开源的数据库连接池</h2><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP：</strong>Apache 提供的数据库连接池</li>
<li><strong>C3P0：</strong>速度相对较慢，稳定性尚可，Hibernate 官方推荐使用</li>
<li><strong>Druid：</strong> 阿里巴巴提供的数据库连接池</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource 用来取代 DriverManager 来获取 Connection，获取速度快，同时可以大幅度提高数据库访问速度</strong></li>
<li>注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：connection.close(); 但 connection.close() 并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池</li>
</ul>
</li>
</ul>
<h3 id="C3P0-数据库连接池"><a href="#C3P0-数据库连接池" class="headerlink" title="C3P0 数据库连接池"></a>C3P0 数据库连接池</h3><p>如需使用该连接池实现，应在系统中增加 jar 文件：c3p0.jar</p>
<p>通过配置文件方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;intergalactoApp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cpds.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>src 下配置文件：c3p0-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;intergalactoApp&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的 4 个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>password<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- localhost:3306 可省略：(jdbc:mysql:///test) --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 连接池中连接用尽时, 一次向数据库服务器申请连接个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 连接池中的最小连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 连接池中的最大连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="DBCP-数据库连接池"><a href="#DBCP-数据库连接池" class="headerlink" title="DBCP 数据库连接池"></a>DBCP 数据库连接池</h3><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool</li>
<li>如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池采用该连接池实现</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用</li>
</ul>
<p><strong>配置参数：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<p>通过配置文件方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSourceFactory;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream inputStream = ClassLoader.getSystemResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">        pros.load(inputStream);</span><br><span class="line">        </span><br><span class="line">        dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>src 下配置文件：dbcp.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driverClassName&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">username&#x3D;username</span><br><span class="line">password&#x3D;password</span><br><span class="line"></span><br><span class="line">initialSize&#x3D;10</span><br></pre></td></tr></table></figure>

<h3 id="Druid-德鲁伊-数据库连接池"><a href="#Druid-德鲁伊-数据库连接池" class="headerlink" title="Druid(德鲁伊)数据库连接池"></a>Druid(德鲁伊)数据库连接池</h3><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP、Proxool 等的优点，同时加入了日志监控，可以很好的监控数据库连接池连接和 SQL 的执行情况</p>
<p>配置参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>缺省</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的 url</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据 url 自动识别，这一项可配可不配，如果不配置 druid 会根据 url 自动识别 dbType，然后选择相应的 driverClassName(建议配置)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用 init 方法，或者第一次 getConnection 时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了 maxWait 之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置 useUnfairLock 属性为 true 使用非公平锁</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存 preparedStatement，也就是 PSCache。PSCache 对支持游标的数据库性能提升巨大，比如说 oracle。在 MySQL 下建议关闭</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用 PSCache，必须配置大于 0，当大于 0 时，poolPreparedStatements 自动触发修改为 true。在 Druid 中，不会存在 Oracle 下 PSCache 占用内存过多的问题，可以把这个数值配置大一些，比如说 100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的 sql，要求是一个查询语句。如果 validationQuery 为 null，testOnBorrow、testOnReturn、testWhileIdle 都不会其作用</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为 true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行 validationQuery 检测连接是否有效</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy 线程会检测连接的间隔时间 2)testWhileIdle 的判断依据，详细看 testWhileIdle 属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个 DruidDataSource 只支持一个 EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的 sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据 dbType 自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的 filter:stat 日志用的 filter:log4j 防御 sql 注入的 filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是 List，如果同时配置了 filters 和 proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream inputStream = ClassLoader.getSystemResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        pros.load(inputStream);</span><br><span class="line">        dataSource = DruidDataSourceFactory.createDataSource(pros);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src 下配置文件：druid.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">username&#x3D;username</span><br><span class="line">password&#x3D;password</span><br><span class="line">driverClassName&#x3D;com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize&#x3D;10</span><br><span class="line">maxActive&#x3D;10</span><br></pre></td></tr></table></figure>

<h1 id="Apache-DBUtils-实现-CRUD-操作"><a href="#Apache-DBUtils-实现-CRUD-操作" class="headerlink" title="Apache-DBUtils 实现 CRUD 操作"></a>Apache-DBUtils 实现 CRUD 操作</h1><h2 id="Apache-DBUtils-简介"><a href="#Apache-DBUtils-简介" class="headerlink" title="Apache-DBUtils 简介"></a>Apache-DBUtils 简介</h2><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC 工具类库，它是对 JDBC 的简单封装，能极大简化 JDBC 编码的工作量，同时也不会影响程序的性能</p>
<h2 id="主要-API-的使用"><a href="#主要-API-的使用" class="headerlink" title="主要 API 的使用"></a>主要 API 的使用</h2><h3 id="DbUtils"><a href="#DbUtils" class="headerlink" title="DbUtils"></a>DbUtils</h3><p>DbUtils：提供如关闭连接、装载 JDBC 驱动程序等常规工作的工具类，所有方法都是静态的：</p>
<ul>
<li>public static void close(…) throws SQLException<ul>
<li>DbUtils 类提供了三个重载的关闭方法，检查所提供的参数是否为 null，若不是就关闭 Connection、Statement 和 ResultSet</li>
</ul>
</li>
<li>public static void closeQuietly(…)<ul>
<li>在 Connection、Statement 和 ResultSet 为 null 情况下避免关闭，还能隐藏一些在程序中抛出的 SQLEeception</li>
</ul>
</li>
<li>public static void commitAndClose(Connection conn) throws SQLException<ul>
<li>用来提交连接的事务，然后关闭连接</li>
</ul>
</li>
<li>public static void commitAndCloseQuietly(Connection conn)<ul>
<li>用来提交连接，然后关闭连接，并且在关闭连接时不抛出 SQL 异常</li>
</ul>
</li>
<li>public static void rollback(Connection conn) throws SQLException<ul>
<li>允许 conn 为 null，因方法内部做了判断</li>
</ul>
</li>
<li>public static void rollbackAndClose(Connection conn) throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(String driverClassName)<ul>
<li>装载并注册 JDBC 驱动程序，如果成功就返回 true</li>
<li>该方法不需要捕捉 ClassNotFoundException 异常</li>
</ul>
</li>
</ul>
<h3 id="QueryRunner-类"><a href="#QueryRunner-类" class="headerlink" title="QueryRunner 类"></a>QueryRunner 类</h3><p>该类简单化了 SQL 查询，它与 ResultSetHandler 组合使用可以完成大部分的数据库操作</p>
<ul>
<li><p>QueryRunner 类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner 类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object …params) throws SQLException<ul>
<li>用来执行一个更新（插入、更新或删除）操作</li>
</ul>
</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn, String sql, ResultSetHandler<T> rsh, Object …params) throws SQLException<ul>
<li>只支持 INSERT 语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.</li>
<li>返回值：An object generated by the handler. 即自动生成的键值</li>
</ul>
</T></T></li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn, String sql, Object[][] params) throws SQLException<ul>
<li>支持 INSERT, UPDATE, or DELETE 语句</li>
</ul>
</li>
<li>public <T> T insertBatch(Connection conn, String sql, ResultSetHandler<T> rsh, Object[][] params) throws SQLException<ul>
<li>只支持 INSERT 语句</li>
</ul>
</T></T></li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh, Object …params) throws SQLException<ul>
<li>执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数</li>
<li>该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ResultSetHandler-接口及实现类"><a href="#ResultSetHandler-接口及实现类" class="headerlink" title="ResultSetHandler 接口及实现类"></a>ResultSetHandler 接口及实现类</h3><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式</p>
<ul>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet rs)</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到 List 中</li>
<li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的 JavaBean 实例中</li>
<li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的 JavaBean 实例中，存放到 List 里</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到 List 中</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个 Map 里，再把这些 map 再存到一个 map 里，其 key 为指定的 key</li>
<li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个 Map 里，key 是列名，value 是对应的值</li>
<li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个 Map 里，然后再存放到 List</li>
<li><strong>ScalarHandler：</strong>查询单个值对象</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-面向对象</title>
    <url>/2020/11/20/%E9%87%8D%E5%AD%A6Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Java-面向对象三大主线"><a href="#Java-面向对象三大主线" class="headerlink" title="Java 面向对象三大主线"></a>Java 面向对象三大主线</h1><h2 id="Java-类及类的成员"><a href="#Java-类及类的成员" class="headerlink" title="Java 类及类的成员"></a>Java 类及类的成员</h2><p>属性、方法、构造器、内部类</p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>封装(Encapsulation)、继承(Inheriance)、多态(Polymorphism)、(抽象)</p>
<h2 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h2><p>this、super、static、final、abstract、interface、package、import</p>
<h1 id="面向过程-POP-与面向对象-OOP"><a href="#面向过程-POP-与面向对象-OOP" class="headerlink" title="面向过程(POP)与面向对象(OOP)"></a>面向过程(POP)与面向对象(OOP)</h1><p>面向过程：POP - Procedure Oriented Programming<br>面向对象：OOP - Object Oriented Programming<br>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<ul>
<li>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做</li>
<li>面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等</li>
</ul>
<h2 id="面向对象分析方法分析问题的思路和步骤"><a href="#面向对象分析方法分析问题的思路和步骤" class="headerlink" title="面向对象分析方法分析问题的思路和步骤"></a>面向对象分析方法分析问题的思路和步骤</h2><ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具</li>
</ul>
<h2 id="面向对象的思想概述"><a href="#面向对象的思想概述" class="headerlink" title="面向对象的思想概述"></a>面向对象的思想概述</h2><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)</li>
</ul>
</li>
<li>可以理解为：类 = 抽象概念的人；对象 = 实实在在的某个人</li>
<li>面向对象程序设计的重点是类的设计</li>
<li>类的设计，其实就是类的成员的设计</li>
</ul>
<h2 id="Java-中用-class-来描述事物，常见的类成员有："><a href="#Java-中用-class-来描述事物，常见的类成员有：" class="headerlink" title="Java 中用 class 来描述事物，常见的类成员有："></a>Java 中用 class 来描述事物，常见的类成员有：</h2><ul>
<li>属性：对应类中的成员变量</li>
<li>行为：对应类中的成员方法</li>
<li>Field = 属性 = 成员变量，Method = (成员)方法 = 函数</li>
</ul>
<p><strong>Java 类的实例化，即创建类的对象</strong></p>
<h2 id="类和对象的使用-面向对象思想的实现"><a href="#类和对象的使用-面向对象思想的实现" class="headerlink" title="类和对象的使用(面向对象思想的实现)"></a>类和对象的使用(面向对象思想的实现)</h2><ul>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过”对象.属性”或”对象.方法”调用对象的结构</li>
</ul>
<h2 id="类的多个对象的关系："><a href="#类的多个对象的关系：" class="headerlink" title="类的多个对象的关系："></a>类的多个对象的关系：</h2><ul>
<li>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性(非 static)</li>
</ul>
<h2 id="对象的内存解析"><a href="#对象的内存解析" class="headerlink" title="对象的内存解析"></a>对象的内存解析</h2><h2 id="属性-成员变量-与局部变量"><a href="#属性-成员变量-与局部变量" class="headerlink" title="属性(成员变量)与局部变量"></a>属性(成员变量)与局部变量</h2><ul>
<li>相同点<ul>
<li>定义变量的格式：数据类型 变量名 = 值</li>
<li>先声明，后使用</li>
<li>变量都有其对应的作用域</li>
</ul>
</li>
<li>不同点<ul>
<li>在类中声明的位置不同：<ul>
<li>属性：直接定义在类的一对 {} 内</li>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
</ul>
</li>
<li>关于权限修饰符的不同：<ul>
<li>属性：可以在声明属性时，指明其权限，使用权限修饰符<br>常用的权限修饰符：private、public、缺省(即没有)、protected</li>
<li>局部变量：不可以使用权限修饰符</li>
</ul>
</li>
<li>默认初始化值的情况：<ul>
<li>属性：类的属性，根据其类型，都有默认初始化值<br>整型(byte、short、int、long)：0<br>浮点型(float、double)：0.0<br>字符型(char)：0 (或 ‘\u0000’)<br>布尔型(boolean)：false<br>引用数据类型(类、数组、接口)：null</li>
<li>局部变量：没有默认初始化值<br>意味着在调用局部变量之前，一定要显式赋值<br>特别的：形参在调用时赋值即可</li>
</ul>
</li>
<li>在内存中加载的位置：<ul>
<li>属性：加载到堆空间中(非 static)</li>
<li>局部变量：加载到栈空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="方法的声明："><a href="#方法的声明：" class="headerlink" title="方法的声明："></a>方法的声明：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表) &#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的分类：按照是否有形参及返回值"><a href="#方法的分类：按照是否有形参及返回值" class="headerlink" title="方法的分类：按照是否有形参及返回值"></a>方法的分类：按照是否有形参及返回值</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">无返回值</th>
<th align="center">有返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无形参</td>
<td align="center">void 方法名() {}</td>
<td align="center">返回值的类型 方法名() {}</td>
</tr>
<tr>
<td align="center">有形参</td>
<td align="center">void 方法名(形参列表) {}</td>
<td align="center">返回值的类型 方法名(形参列表) {}</td>
</tr>
</tbody></table>
<h3 id="返回值类型：有返回值与没有返回值"><a href="#返回值类型：有返回值与没有返回值" class="headerlink" title="返回值类型：有返回值与没有返回值"></a>返回值类型：有返回值与没有返回值</h3><ul>
<li>如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用 return 关键字返回指定类型的变量或常量：”return 数据;”</li>
<li>如果方法没有返回值，则方法声明时，使用 void 关键字来表示。通常，没有返回值的方法中不需要使用 return，如果需要使用，可以 “return;” 表示结束此方法</li>
</ul>
<h3 id="return-关键字的使用："><a href="#return-关键字的使用：" class="headerlink" title="return 关键字的使用："></a>return 关键字的使用：</h3><ul>
<li>使用范围：使用在方法体中</li>
<li>作用：<ul>
<li>结束方法</li>
<li>针对有返回值类型的方法，使用 “return 数据;” 返回所需要的数据</li>
</ul>
</li>
<li>注意点：return 关键字后不可以声明执行语句</li>
</ul>
<h3 id="方法使用中的注意点："><a href="#方法使用中的注意点：" class="headerlink" title="方法使用中的注意点："></a>方法使用中的注意点：</h3><ul>
<li>方法的使用中，可以调用当前类的属性或方法<ul>
<li>特殊的：方法 A 中又调用了方法 A(递归)</li>
</ul>
</li>
<li>方法中，不可以定义方法</li>
</ul>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h3><ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</li>
<li>重载的特点：<ul>
<li>与方法的权限修饰符、返回值类型、形参变量名、方法体都无关</li>
<li>与参数列表有关且参数列表必须不同(参数个数或参数类型)</li>
<li>调用时，根据方法参数列表的不同来区别</li>
</ul>
</li>
</ul>
<h3 id="可变个数形参的方法"><a href="#可变个数形参的方法" class="headerlink" title="可变个数形参的方法"></a>可变个数形参的方法</h3><p>JavaSE 5.0 中提供了 Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参</p>
<ul>
<li><p>JDK 5.0 以前：采用数组形参来定义方法，传入多个同一类型变量</p>
<ul>
<li>public static void test(int a, String[] b) {}</li>
</ul>
</li>
<li><p>JDK 5.0 采用可变个数形参来定义方法，传入多个同一类型变量</p>
<ul>
<li>public static void test(int a, String … b) {}</li>
</ul>
</li>
<li><p>具体使用：</p>
<ul>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是任意的(0 个、1 个、2 个、…)</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组(数据类型[] 变量名)之间不构成重载。即，二者不能共用</li>
<li>可变个数形参在方法的形参中，必须声明在末尾</li>
<li>可变个数形参在方法的形参中，最多只能声明一个可变个数形参</li>
</ul>
</li>
</ul>
<h3 id="方法参数的值传递机制："><a href="#方法参数的值传递机制：" class="headerlink" title="方法参数的值传递机制："></a>方法参数的值传递机制：</h3><ul>
<li>方法必须由其所在类或对象调用才有意义。若方法含有参数：<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li>Java 的实参值传入方法的方式<ul>
<li>Java 中方法的参数传递方式只有一种：值传递。即，将实际参数值的副本传入方法内，而参数本身不受影响<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参</li>
</ul>
</li>
</ul>
</li>
<li>关于变量的赋值<ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值</li>
</ul>
</li>
</ul>
<h3 id="递归方法：一个方法体内调用它自身"><a href="#递归方法：一个方法体内调用它自身" class="headerlink" title="递归方法：一个方法体内调用它自身"></a>递归方法：一个方法体内调用它自身</h3><ul>
<li>理解递归可以通过画出递归树的方式</li>
</ul>
<h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><h2 id="封装与隐藏"><a href="#封装与隐藏" class="headerlink" title="封装与隐藏"></a>封装与隐藏</h2><h3 id="程序设计追求”高内聚，低耦合”"><a href="#程序设计追求”高内聚，低耦合”" class="headerlink" title="程序设计追求”高内聚，低耦合”"></a>程序设计追求”高内聚，低耦合”</h3><ul>
<li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li>
<li>低耦合：仅对外暴露少量的方法用于使用<br>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。即封装的设计思想</li>
</ul>
<h3 id="封装的体现"><a href="#封装的体现" class="headerlink" title="封装的体现"></a>封装的体现</h3><ul>
<li>避免用户使用 “对象.属性” 的方式对属性进行赋值</li>
<li>将属性name声明为私有(private)，同时提供公共的(public)方法来获取(getName)和设置(setName)此属性的值</li>
<li>封装的体现需要结合权限修饰符<ul>
<li>Java 权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限</li>
<li>Java 规定的 4 种权限(从小到大)：private、缺省(即没有权限修饰符)、protected、public</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内部</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(缺省)</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<ul>
<li>对于 class 的权限修饰只可以用 public 和 default(缺省)<ul>
<li>public 类可以在任意地方被访问</li>
<li>default 类只可以被同一个包内部的类访问</li>
</ul>
</li>
</ul>
<p><strong>总结封装：</strong>Java 提供了 4 种权限修饰符来修饰类及类的内部结构，体现类的内部结构在被调用时的可见性的大小</p>
<h3 id="构造器-构造方法-constructor"><a href="#构造器-构造方法-constructor" class="headerlink" title="构造器(构造方法 constructor)"></a>构造器(构造方法 constructor)</h3><ul>
<li>若没有显式的定义类的构造器，则默认提供一个无参构造器</li>
<li>定义构造器的格式：权限修饰符 类名(参数列表) {}</li>
<li>一个类中定义多个构造器，彼此构成重载</li>
<li>一旦显式的定义了类的构造器，便不再提供默认的无参构造器</li>
<li>一个类中至少存在一个构造器</li>
</ul>
<h3 id="构造器的作用：创建对象、初始化对象"><a href="#构造器的作用：创建对象、初始化对象" class="headerlink" title="构造器的作用：创建对象、初始化对象"></a>构造器的作用：创建对象、初始化对象</h3><ul>
<li>创建类的对象：new 构造器(<code>Order o = new Order();</code>)</li>
<li>初始化对象的信息</li>
</ul>
<h3 id="构造器的特征"><a href="#构造器的特征" class="headerlink" title="构造器的特征"></a>构造器的特征</h3><ul>
<li>具有与类相同的名称</li>
<li>不声明返回值类型</li>
<li>不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值</li>
</ul>
<h3 id="属性赋值的先后顺序"><a href="#属性赋值的先后顺序" class="headerlink" title="属性赋值的先后顺序"></a>属性赋值的先后顺序</h3><p>默认初始化 &gt; 显式初始化 &gt; 构造器中赋值 &gt; 通过 “对象.方法” 或 “对象.属性”的方式赋值</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>JavaBean 是一种 Java 语言写成的可重用组件</li>
<li>所谓 JavaBean 是指符合如下标准的 Java 类<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的 get、set 方法</li>
</ul>
</li>
<li>用户可以使用 JavaBean 将功能、处理、值、数据库访问和其他任何可以用 Java 代码创造的对象进行打包，并且其他的开发者可以通过内部的 JSP 页面、Servlet、其他 JavaBean、applet 程序或者应用来使用这些对象。用户可以认为 JavaBean 提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</li>
</ul>
<h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><table>
<thead>
<tr>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>- 属性名 : 属性类型<br>+ 属性名 : 属性类型<br># 属性名 : 属性类型</td>
</tr>
<tr>
<td>+<u>方法名(参数名 : 参数类型) : 返回值类型</u><br>-方法名(参数名 : 参数类型) : 返回值类型<br>+方法名(参数名 : 参数类型) : 返回值类型</td>
</tr>
</tbody></table>
<ul>
<li>+表示 public 类型、-表示 private 类型、#表示 protected 类型</li>
<li>若方法有下划线表示为构造方法</li>
</ul>
<h3 id="关键字-this-的使用"><a href="#关键字-this-的使用" class="headerlink" title="关键字 this 的使用"></a>关键字 this 的使用</h3><ul>
<li><p>this 的作用与词义很接近</p>
<ul>
<li>在方法内部使用，即这个方法所属对象的引用</li>
<li>在构造器内部使用，表示该构造器正在初始化的对象</li>
</ul>
</li>
<li><p>this 表示当前对象，可以调用类的属性、方法和构造器</p>
</li>
<li><p>this 的使用场景：</p>
<ul>
<li>当在方法内需要用到调用该方法的对象时<br>具体的，可以使用 this 来区分局部变量和属性<br><code>this.name = name;</code></li>
</ul>
</li>
<li><p>在类的方法中(或构造器中)，可以使用 “this.属性” 或 “this.方法” 的方式，调用当前对象属性或方法。但是通常情况下都选择省略 “this.”。特殊情况下，如果方法的形参(或构造器的形参)与类的属性同名时，必须显式的使用 “this.变量” 的方式，表明此变量是属性，而非形参。</p>
</li>
<li><p>this 调用构造器</p>
<ul>
<li>在类的构造器中可以显式的使用 “this(形参列表)” 方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过 “this(形参列表)” 方式调用自己</li>
<li>如果一个类中有 n 个构造器，则最多有 n-1 个构造器中使用了 “this(形参列表)”</li>
<li>规定：”this(形参列表)” 必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个 “this(形参列表)” 用来调用其他的构造器</li>
</ul>
</li>
</ul>
<h3 id="关键字-package、import-的使用"><a href="#关键字-package、import-的使用" class="headerlink" title="关键字 package、import 的使用"></a>关键字 package、import 的使用</h3><h3 id="package-关键字的使用"><a href="#package-关键字的使用" class="headerlink" title="package 关键字的使用"></a>package 关键字的使用</h3><ul>
<li>为了更好的实现项目中类的管理，提供包的概念</li>
<li>使用 package 声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符命名规则、规范、见名知义</li>
<li>每 “.” 一次就代表一层文件目录</li>
<li>补充：同一个包下，不能命名同名的接口、类</li>
</ul>
<h3 id="import-关键字的使用"><a href="#import-关键字的使用" class="headerlink" title="import 关键字的使用"></a>import 关键字的使用</h3><p>import 语句有两种类型：</p>
<ul>
<li>明确导入是在 import 语句中指定单个的类。</li>
<li>通配符导入是指通过使用星号( * )作为通配符，导入一个包中所有的类。</li>
</ul>
<p><strong>注意：</strong>除非要在程序中使用某个类，否则关于被导入包中的这些类的信息在编译时或是运行时是不被读入的。<br>    导入语句只是告诉编译器在什么地方能找到这些类。声明明确导入和声明通配符导入在性能上是没有什么差别的。</p>
<h3 id="JDK-中常用的包"><a href="#JDK-中常用的包" class="headerlink" title="JDK 中常用的包"></a>JDK 中常用的包</h3><ul>
<li>java.lang：包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能(默认导入)</li>
<li>java.net：包含执行与网络相关的操作的类和接口</li>
<li>java.io：包含能提供多种输入/输出功能的类</li>
<li>java.util：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。如 Scanner、Date</li>
<li>java.text：包含了一些 java 格式化相关的类</li>
<li>java.sql：包含了 java 进行 JDBC 数据库编程的相关类/接口</li>
<li>java.awt：包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)</li>
</ul>
<h3 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h3><p>MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层(view)、控制器层(controller)、数据模型层(model)。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序变得灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性</p>
<ul>
<li>模型层 model 主要处理数据<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li>控制层 controller 处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放 fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
<li>视图层 view 显示数据<ul>
<li>相关工具类 view.util</li>
<li>自定义 view view.ui</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java 只支持单继承和多层继承，不允许多重继承</p>
<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
</ul>
<h3 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h3><ul>
<li>减少代码冗余，提高复用性</li>
<li>便于功能拓展</li>
<li>为之后多态的使用提供了前提</li>
</ul>
<h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>class A extends B {}</p>
<ul>
<li><p>A：子类、派生类、subclass</p>
</li>
<li><p>B：父类、超类、基类、superclass</p>
</li>
<li><p>体现：一旦子类 A 继承了父类 B，子类 A 中就获取了父类 B 中声明的结构：属性、方法</p>
<ul>
<li>特别的，父类中声明为 private 的属性或方法，子类继承父类后，仍然认为获取了父类中私有的结构。只因为受封装的影响，使得子类不能直接调用父类的结构而已</li>
</ul>
</li>
<li><p>子类继承父类后，还可以声明自己特有的属性或方法，实现功能的扩展(extends：扩展)</p>
</li>
</ul>
<h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><ul>
<li>如果没有显式的声明一个类的父类，则此类继承于 java.lang.Object 类</li>
<li>所有的 java 类(除 java.lang.Object 类之外) 都直接或间接的继承于 java.lang.Object 类</li>
<li>意味着，所有的 java 类都具有 java.lang.Object 类声明的功能</li>
</ul>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><strong>定义：</strong>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法</p>
<p><strong>要求：</strong></p>
<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<ul>
<li>子类不能重写父类中声明为 private 权限的方法</li>
</ul>
</li>
<li>子类重写的方法抛出的异常不能大于父类被重写的方法的异常</li>
</ul>
<p><strong>注意：</strong>子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，或者同时声明为 static 的(不是重写)。因为 static 方法是属于类的，子类无法覆盖父类的方法。</p>
<p><strong>应用：</strong>方法重写后，当创建子类对象以后，通过子类对象调用子、父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
<h3 id="关键字-super"><a href="#关键字-super" class="headerlink" title="关键字 super"></a>关键字 super</h3><ul>
<li><p>super 理解为：父类的</p>
</li>
<li><p>super 可以用来调用：属性、方法、构造器</p>
</li>
<li><p>super 的使用：</p>
<ul>
<li>可以在子类的方法或构造器中，通过使用 “super.属性” 或 “super.方法” 的方式，显式的调用父类中声明的属性或方法。通常习惯省略 “super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用 “super.属性” 的方式，表明调用的是父类中声明的属性</li>
<li>特殊情况：当子类重写了父类中的方法后，要想在子类的方法中调用父类中被重写的方法时，则必须显式的使用 “super.方法” 的方式，表明调用的是父类中被重写的方法</li>
<li>super 调用构造器<ul>
<li>可以在子类的构造器中显式的使用 “super(形参列表)” 的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)” 的使用，必须声明在子类构造器的首行</li>
<li>在类的构造器中，针对于 “this(形参列表)” 或 “super(形参列表)” 只能二选一，不能同时出现</li>
<li>在构造器的首行，没有显式的声明 “this(形参列表)” 或 “super(形参列表)”，则默认调用的是父类中无参的构造器：”super()”</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了 “super(形参列表)”  调用父类中的构造器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="子类对象实例化的过程"><a href="#子类对象实例化的过程" class="headerlink" title="子类对象实例化的过程"></a>子类对象实例化的过程</h3><p><strong>从结果来看(继承)：</strong></p>
<ul>
<li>子类继承父类后，就获取了父类中声明的属性和方法</li>
<li>创建子类的对象，在堆空间中就会加载所有父类中声明的属性</li>
</ul>
<p><strong>从过程上来看：</strong></p>
<ul>
<li>当通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器…<br>直到调用了 java.lang.Object 类中的无参的构造器为止。正因为加载过所有的父类的结构，所以可以看到内存中有父类中的结构，子类对象才可以考虑进行调用</li>
</ul>
<p><strong>注意：</strong>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即 new 出的子类对象</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>对象的多态性：父类的引用指向子类的对象(或子类的对象赋给父类的引用)</strong></p>
<ul>
<li>可以直接应用在抽象类和接口上</li>
</ul>
<p><strong>Java 引用变量有两个类型：</strong></p>
<ul>
<li><p>编译时类型和运行时类型</p>
</li>
<li><p>编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋值给该变量的对象决定。(编译时，看 “=” 左边、运行时，看 “=” 右边)</p>
</li>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性</p>
</li>
<li><p>多态情况下：</p>
<ul>
<li>“看左边”：看的是父类的引用(父类中不具备子类特有的方法)</li>
<li>“看右边”：看的是子类的对象(实际运行的是子类重写父类的方法)</li>
</ul>
</li>
</ul>
<p><strong>多态的使用：</strong></p>
<ul>
<li>当调用子、父类同名同参数的方法时，实际执行的是子类重写父类的方法(虚拟方法调用)</li>
<li>在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法</li>
<li>多态的使用前提：类继承关系、方法重写</li>
<li>多态只适用于方法，不适用于属性(编译期与运行期均决定于 “=” 左边声明的变量类型)</li>
</ul>
<p><strong>多态是运行时行为</strong></p>
<h3 id="虚拟方法调用-多态情况下"><a href="#虚拟方法调用-多态情况下" class="headerlink" title="虚拟方法调用(多态情况下)"></a>虚拟方法调用(多态情况下)</h3><p>子类中定义了与父类同名同参的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<p><strong>动态绑定：</strong></p>
<p>编译时引用变量类型是父类类型，而方法调用是在运行时确定的，所以调用的便是子类的方法，该过程称为动态绑定</p>
<h3 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h3><p><strong>二者的定义细节：</strong></p>
<ul>
<li>重载：重名方法，方法的参数列表不同</li>
<li>重写：子类根据需求对父类中的方法进行改造。必须方法同名、同参数列表</li>
</ul>
<p><strong>从编译和运行的角度看：</strong></p>
<ul>
<li>重载，是指允许存在多个同名方法，而这些方法的参数列表不同。它们的调用地址在编译期就绑定了。Java 重载是可以包括父类和子类的，即子类可以重载父类的同名，参数列表不同的方法。所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为 “早绑定” 或 “静态绑定”</li>
<li>对于多态与方法重写，只有等到方法调用的那一刻才会确定所要调用的具体方法，这称为 “晚绑定” 或 “动态绑定”</li>
</ul>
<h3 id="instaceof-操作符"><a href="#instaceof-操作符" class="headerlink" title="instaceof 操作符"></a>instaceof 操作符</h3><p>x instanceof A：检验 x 是否为类 A 的对象，返回值为 boolean 型</p>
<ul>
<li>要求 x 所属的类与类 A 必须是子类和父类的关系，否则编译错误</li>
<li>如果 x 属于类 A 的子类 B，x instanceof A 值也为 true</li>
</ul>
<h3 id="向下转型的使用"><a href="#向下转型的使用" class="headerlink" title="向下转型的使用"></a>向下转型的使用</h3><p>由于对象的多态性，内存中实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用</p>
<p>向上转型：多态</p>
<p>向下转型：使用强制类型转换符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Man m = (Man)p;</span><br></pre></td></tr></table></figure>

<p>强转时可能出现 ClassCastException 异常，此时可以使用 instanceof 操作符进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Man) &#123;</span><br><span class="line">    Man m = (Man)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-类结构的剖析"><a href="#Object-类结构的剖析" class="headerlink" title="Object 类结构的剖析"></a>Object 类结构的剖析</h2><ul>
<li>Object 类是所有 Java 类的根父类</li>
<li>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object</li>
</ul>
<h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h3><ul>
<li><p>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</p>
</li>
<li><p>equals() 是属于 java.lang.Object 类中的方法，如果该方法没有被重写过，默认也是 ==。可以看到 String 等类的 equals() 方法是被重写过的，而且 String 类在日常开发中用的比较多，久而久之形成了 equals 是比较值的错误观点</p>
</li>
<li><p>具体要看自定义类里有没有重写 Object 的 equals() 方法来判断</p>
</li>
<li><p>通常情况下，重写 equals() 方法，会比较类中的相应属性是否都相等</p>
</li>
</ul>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><ul>
<li>toString() 方法在 Object 类中定义，其返回值是 String 类型，返回类名和它的引用地址</li>
<li>在进行 String 与其他类型数据的连接操作时，自动调用 toString() 方法</li>
<li>可以根据需要在用户自定义类型中重写 toString() 方法<br>如 String 类重写了 toString() 方法，返回字符串的值</li>
<li>基本类型数据转换为 String 类型时，调用了对应包装类的 toString() 方法</li>
</ul>
<h3 id="包装类-Wrapper-的使用"><a href="#包装类-Wrapper-的使用" class="headerlink" title="包装类(Wrapper)的使用"></a>包装类(Wrapper)的使用</h3><ul>
<li>针对八种基本数据类型定义相应的引用类型 —— 包装类(封装类)</li>
<li>有了类的特点，可以调用类中的方法</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<ul>
<li>其中 Byte、Short、Integer、Long、Float、Double 的父类是 Number</li>
</ul>
<p><strong>基本数据类型包装成包装类的实例 —— 装箱</strong></p>
<ul>
<li>通过包装类的构造器实现：int i =  1; Integer t = new Integer(i);</li>
<li>还可以通过字符串参数构造包装类对象：Float f = new Float(“3.14F”);</li>
</ul>
<p><strong>获得包装类对象中包装的基本类型变量 —— 拆箱</strong></p>
<ul>
<li>调用包装类的 .xxxValue() 方法：boolean b = bObj.booleanValue();</li>
<li>JDK1.5 之后，支持自动装箱，自动拆箱。但类型必须匹配</li>
<li>基本数据类型、包装类转换为 String 类型：调用 String 重载的 valueOf() 方法</li>
<li>String 类型准换为基本数据类型、包装类：调用包装类的 parseXxx() 方法</li>
</ul>
<h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字 static"></a>关键字 static</h2><p>当编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过 new 关键字才会产生出对象，这时才会分配内存空间给对象，其方法才可以供外部调用。若希望无论是否产生了对象或无论产生了多少个对象的情况下，某些特定的数据在内存空间中只有一份，这时可以使用 static 关键字修饰为静态的</p>
<ul>
<li><p>static 可以用来修饰：属性、方法、代码块、内部类</p>
</li>
<li><p>使用 static 修饰属性：静态变量</p>
<ul>
<li>属性按是否使用 static 修饰，分为：静态属性、非静态属性(实例变量)<ul>
<li>实例变量：创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值被修改</li>
<li>静态变量：创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时是被修改过的</li>
</ul>
</li>
<li>static 修饰属性的其他说明：<ul>
<li>静态变量随着类的加载而加载。可以通过 “类.静态变量” 的方式进行调用</li>
<li>静态变量的加载要早于对象的创建</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中</li>
<li>对象可以调用类变量(静态变量)和它的实例变量，类只能调用类变量不能调用实例变量</li>
</ul>
</li>
</ul>
</li>
<li><p>使用 static 修饰方法：静态方法</p>
<ul>
<li>随着类的加载而加载，可以通过 “类.静态方法” 的方式进行调用</li>
<li>对象可以调用类方法(静态方法)和非静态方法，类只能调用静态方法不能调用非静态方法</li>
<li>静态方法中，只能调用静态的方法或属性<br>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li>
</ul>
</li>
<li><p>注意点：在静态方法内，不能使用 this 关键字、super 关键字</p>
</li>
<li><p>何时需要 static</p>
<ul>
<li>属性是可以被多个对象所共享的，不会随着对象的不同而不同</li>
</ul>
</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li>代码块的作用：用来初始化类、对象</li>
<li>代码块只能使用 static 修饰</li>
<li>分类：<ul>
<li>静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着类的加载而执行，而且只执行一次</li>
<li>作用：初始化类的信息</li>
<li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态属性、静态方法，不能调用非静态的结构</li>
</ul>
</li>
<li>非静态代码块<ul>
<li>内部可以有输出语句</li>
<li>随着对象的创建而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法</li>
</ul>
</li>
<li>对属性可以赋值的位置<ul>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中初始化</li>
<li>有了对象以后，可以通过 “对象.属性” 或 “对象.方法” 进行赋值</li>
<li>在代码块中赋值</li>
</ul>
</li>
<li>属性赋值的先后顺序<ul>
<li>默认初始化 &gt; 显式初始化或在代码块中赋值(取决于顺序) &gt; 构造器中初始化 &gt; 有了对象以后，可以通过 “对象.属性” 或 “对象.方法” 进行赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h2><p>final：最终的</p>
<ul>
<li>final 可以用来修饰：类、方法、变量</li>
<li>final 用来修饰类：此类不能被其他类所继承<br>比如 String、System、StringBuffer</li>
<li>final 用来修饰方法：此方法不可以被重写<br>比如 Object 类中的 getClass()</li>
<li>final 用来修饰变量：此时的 “变量” 就称为是一个常量<ul>
<li>final 修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li>
<li>final 修饰局部变量：尤其是使用 final 修饰形参时，表明此形参是一个常量。当调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值</li>
</ul>
</li>
<li>static final 用来修饰属性：全局常量(大写)</li>
</ul>
<h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<h3 id="关键字-abstract-的使用"><a href="#关键字-abstract-的使用" class="headerlink" title="关键字 abstract 的使用"></a>关键字 abstract 的使用</h3><p><strong>abstract：抽象的</strong></p>
<ul>
<li>abstract 可以用来修饰：类、方法</li>
<li>abstract 修饰类：抽象类<ul>
<li>此类不能实例化</li>
<li>抽象类一定有构造器，便于子类实例化时使用(涉及：子类对象实例化的全过程)</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</li>
</ul>
</li>
<li>abstract 修饰方法：抽象方法<ul>
<li>抽象方法只有方法的声明，没有方法体</li>
<li>包含抽象方法的类，一定是抽象类。反之，抽象类中可以没有抽象方法</li>
<li>若子类重写了父类中的所有的抽象方法后，次子类方可实例化<br>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用 abstract 修饰</li>
</ul>
</li>
<li>abstract 使用上的注意点：<ul>
<li>abstract 不能用来修饰：属性、构造器等结构</li>
<li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是 Java 不支持多重继承，而接口便可以得到多重继承的效果</p>
</li>
<li><p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已</p>
</li>
<li><p>接口就是规范，定义的是一组规则，体现了现实世界中 “如果你是/要…则必须能…” 的思想。继承是一个 “是不是” 的关系，而接口实现则是 “能不能” 的关系</p>
</li>
<li><p>接口的本质是契约、标准、规范，指定后需要遵守</p>
</li>
</ul>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><ul>
<li>接口使用 interface 来定义</li>
<li>Java 中，接口和类是并列的两个结构</li>
<li>定义接口：定义接口中的成员<ul>
<li>JDK7 及以前：只能定义全局常量和抽象方法<ul>
<li>全局常量：public static final (可以省略不写)</li>
<li>抽象方法：public abstract</li>
</ul>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ul>
</li>
<li>接口中不能定义构造器，意味着接口不能实例化</li>
<li>Java 开发中，接口通过让类去实现(implements)的方式来使用<ul>
<li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li>
</ul>
</li>
<li>Java 类可以实现多个接口，弥补了 Java 单继承的局限性<br>格式：class AA extends BB implements CC, DD, EE</li>
<li>接口与接口之间可以继承，而且可以多继承</li>
<li>接口的具体使用，体现多态</li>
<li>接口，实际上可以看作是一种规范</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类</li>
<li>在 Java 中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类</li>
<li>Inner class 一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称<ul>
<li>Inner class 的名字不能与包含它的外部类类名相同</li>
</ul>
</li>
<li>分类：<ul>
<li>成员内部类(静态、非静态)<ul>
<li>作为外部类的成员<ul>
<li>调用外部类的结构</li>
<li>可以被 static 修饰</li>
<li>可以被 4 种不同的权限修饰</li>
</ul>
</li>
<li>作为一个类<ul>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被 final 修饰，表示此类不能被继承，反之可以被继承</li>
<li>可以被 abstract 修饰</li>
</ul>
</li>
</ul>
</li>
<li>局部内部类(方法内、代码块内、构造器内)、匿名内部类</li>
</ul>
</li>
<li>实例化成员内部类的对象<ul>
<li>静态成员内部类：外部类.内部类 变量 = new 外部类.内部类();</li>
<li>非静态成员内部类：外部类 外部类引用变量 = new 外部类(); 外部类.内部类 内部类引用变量 = 外部类引用变量.new 内部类();</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-进阶(1/2)</title>
    <url>/2020/11/21/%E9%87%8D%E5%AD%A6Java-%E8%BF%9B%E9%98%B61/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>【因内容较多，将拆分为两篇博文，此为篇一】<br>本篇博文为 Java 的一些高级特性的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="程序、进程、线程"><a href="#程序、进程、线程" class="headerlink" title="程序、进程、线程"></a>程序、进程、线程</h3><p><strong>程序(Program)：</strong>为完成特定任务，使用某种编程语言编写的一组指令的集合。即指一段静态的代码，静态对象</p>
<p><strong>进程(Process)：</strong>指程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程 —— 生命周期</p>
<ul>
<li>如：运行中的 Edge 浏览器、Chrome 浏览器</li>
<li>程序是静态的，进程是动态的</li>
<li><strong>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</strong></li>
</ul>
<p><strong>线程(Thread)：</strong>进程可进一步细化为线程，是一个程序内部的一条执行路径</p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li><strong>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</strong></li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间(它们从同一堆中分配对象，可以访问相同的变量和对象，使得线程间通信更便捷、高效。但多个线程操作共享的系统资源可能会带来安全隐患)</li>
</ul>
<h3 id="单核-CPU、多核-CPU"><a href="#单核-CPU、多核-CPU" class="headerlink" title="单核 CPU、多核 CPU"></a>单核 CPU、多核 CPU</h3><p>单核 CPU 中其实是一种假的多线程，因为在一个时间单元内，只能执行一个线程的任务</p>
<ul>
<li>多个任务只能由一个 CPU 进行处理，将正在执行中的任务”挂起”之后再去执行其他的任务，如此轮转。因为 CPU 时间单元特别短，因此感觉不出任务的切换</li>
<li>多核 CPU 才能更好的发挥多线程的效率</li>
<li>一个 Java 应用程序其实至少有三个线程：main() 主线程，gc() 垃圾回收线程，异常处理线程(如果发生异常，会影响主线程)</li>
</ul>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li><strong>并行：</strong>多个 CPU 同时执行多个任务(多个人同时做不同的事)</li>
<li><strong>并发：</strong>一个 CPU(采用时间片轮转)同时执行多个任务(多个人做同一件事)</li>
</ul>
<h3 id="多线程的优点与使用场景"><a href="#多线程的优点与使用场景" class="headerlink" title="多线程的优点与使用场景"></a>多线程的优点与使用场景</h3><p><strong>优点：</strong></p>
<ul>
<li>提高应用程序的响应</li>
<li>提高计算机系统 CPU 的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>程序需要同时执行两个或多个任务</li>
<li>程序需要实现一些需要等待的任务时</li>
<li>需要一些后台运行的程序时</li>
</ul>
<h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><p>Java 中的线程分为两类：一种是守护线程，一种是用户线程</p>
<ul>
<li>它们几乎每方面都是相同的，唯一的区别是判断 JVM 何时离开</li>
<li>守护线程是用来服务用户线程的，通过在 start() 方法前调用 thread.setDaemon(true) 可以把一个用户线程变成一个守护线程</li>
<li>Java 垃圾回收就是一个典型的守护线程</li>
<li>若 JVM 中都是守护线程，当前 JVM 将退出</li>
</ul>
<h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><p><strong>多线程的创建</strong></p>
<h3 id="创建线程方式一：继承于-Thread-类"><a href="#创建线程方式一：继承于-Thread-类" class="headerlink" title="创建线程方式一：继承于 Thread 类"></a>创建线程方式一：继承于 Thread 类</h3><ul>
<li>创建一个继承于 Thread 类的子类</li>
<li>重写 Thread 类的 run() 方法</li>
<li>创建 Thread 类的子类的对象</li>
<li>通过此子类对象调用 start() 方法：<ul>
<li>启动当前线程</li>
<li>调用当前线程的 run() 方法</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>不能通过直接调用 run() 的方式启动线程</li>
<li>不可以让已经 threadSubObj.start() 的线程再去执行启动线程( threadSubObj.start() )的操作。会报错：IllegalThreadStateException</li>
</ul>
<h3 id="创建线程方式二：实现-Runnable-接口"><a href="#创建线程方式二：实现-Runnable-接口" class="headerlink" title="创建线程方式二：实现 Runnable 接口"></a>创建线程方式二：实现 Runnable 接口</h3><ul>
<li>创建一个实现了 Runnable 接口的类</li>
<li>实现类去实现 Runnable 中的抽象方法：run() 方法</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象</li>
<li>通过这个 Thread 类的对象调用 start() 方法：<ul>
<li>启动当前线程</li>
<li>调用当前线程的 run() 方法(调用了 Runnable 类型的 target 的 run() 方法)</li>
</ul>
</li>
</ul>
<p><strong>创建线程的两种方式的比较：</strong></p>
<ul>
<li>开发中：优先选择实现 Runnable 接口的方式<ul>
<li>实现的方式没有类的单继承的局限性</li>
<li>实现的方式更适合用来处理多个线程有共享数据的情况</li>
</ul>
</li>
<li>两种实现方式的联系：( Thread 类也是 Runnable 的实现类 ) public class Thread implements Runnable</li>
<li>相同点：两种方式都需要重写 run() 方法，将线程要执行的逻辑声明在 run() 方法中</li>
</ul>
<h3 id="创建线程方式三：实现-Callable-接口-JDK5-0新增"><a href="#创建线程方式三：实现-Callable-接口-JDK5-0新增" class="headerlink" title="创建线程方式三：实现 Callable 接口 (JDK5.0新增)"></a>创建线程方式三：实现 Callable 接口 (JDK5.0新增)</h3><ul>
<li><code>import java.util.concurrent.Callable;</code></li>
<li>创建一个实现 Callable 接口的实现类</li>
<li>实现 call() 方法，将此线程需要执行的操作声明在 call() 方法中</li>
<li>创建 Callable 接口实现类的对象</li>
<li>将此 Callable 接口实现类的对象作为参数传递到 FutureTask 构造器中，创建 FutureTask 的对象</li>
<li>将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start() 方法</li>
<li>(可选)获取 Callable 中 call() 方法的返回值<br>get() 返回值即为 FutureTask 构造器参数 —— Callable 实现类重写的 call() 的返回值</li>
</ul>
<p><strong>与使用 Runnable 相比，Callable 功能更强，针对 Callable：</strong></p>
<ul>
<li>相比 run() 方法，call() 方法可以有返回值</li>
<li>call() 方法可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable 支持泛型的返回值</li>
<li>需要借助 FutureTask 类，比如获取返回结构</li>
</ul>
<p><strong>Future 接口：</strong></p>
<ul>
<li>可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完成、获取结果等</li>
<li>FutureTask 是 Future 接口的唯一的实现类</li>
<li>FutureTask 同时实现了 Runnable，Future 接口。它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值</li>
</ul>
<h3 id="创建线程方式四：使用线程池-JDK5-0新增"><a href="#创建线程方式四：使用线程池-JDK5-0新增" class="headerlink" title="创建线程方式四：使用线程池 (JDK5.0新增)"></a>创建线程方式四：使用线程池 (JDK5.0新增)</h3><p>开发中线程是经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。若提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p>
<p>JDK5.0起提供了线程池相关 API：ExecutorService 和 Executors</p>
<ul>
<li>ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行 Runnable</li>
<li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般用来执行 Callable</li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n)：创建一个可重用的固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</li>
</ul>
</li>
</ul>
<p><strong>创建及使用：</strong></p>
<ul>
<li><p><code>import java.util.concurrent.ExecutorService;</code><br><code>import java.util.concurrent.Executors;</code><br><code>import java.util.concurrent.ThreadPoolExecutor;</code></p>
</li>
<li><p>提供指定线程数量的线程池(ExecutorService service = Executors.newFixedThreadPool(nThreads: 10); )</p>
</li>
<li><p>执行指定的线程的操作。需要提供实现 Runnable 接口或 Callable 接口实现类的对象</p>
<ul>
<li>service.executer(Runnable runnable);  适用于 Runnable</li>
<li>service.submit(Callable callable); 适用于 Callable</li>
</ul>
</li>
<li><p>关闭连接池(service.shutdown(); )</p>
</li>
</ul>
<p><strong>线程池的优点：</strong></p>
<ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
<h3 id="Thread-类的常见方法"><a href="#Thread-类的常见方法" class="headerlink" title="Thread 类的常见方法"></a>Thread 类的常见方法</h3><ul>
<li>void start()：启动线程，并执行对象的 run() 方法</li>
<li>run()：线程在被调度时执行的操作<ul>
<li>通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中</li>
</ul>
</li>
<li>static Thread currentThread()：返回当前线程。在 Thread 子类中就是 this，通常用于主线程和 Runnable 实现类<ul>
<li>静态方法，返回执行当前代码的线程</li>
</ul>
</li>
<li>String getName()：返回该线程的名称<ul>
<li>获取当前线程的名称</li>
</ul>
</li>
<li>void setName(String name)：设置该线程名称<ul>
<li>设置当前线程的名称</li>
</ul>
</li>
<li>static void yield()：线程让步<ul>
<li>释放当前 CPU 的执行权</li>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</li>
<li>join()：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<ul>
<li>在线程 thread1 中调用线程 thread2 的 join()，此时线程 thread1 就进入阻塞状态，直到线程 thread2 完全执行完成后，线程 thread1 才结束阻塞状态</li>
<li>低优先级的线程也可以获得执行</li>
</ul>
</li>
<li>static void sleep(long millis)：(指定时间：毫秒)<ul>
<li>让当前线程”睡眠”指定的毫秒。在指定的毫秒时间内，当前线程是阻塞状态</li>
<li>令当前活动线程在指定时间段内放弃对 CPU 控制，使其他线程有机会被执行，时间到后重新排队</li>
<li>抛出 InterruptedException 异常(需要使用 try-catch)</li>
</ul>
</li>
<li>stop()：强制线程生命期结束，不推荐使用(已过时)<ul>
<li>当执行此方法时，强制结束当前线程</li>
</ul>
</li>
<li>boolean isAlive()：判断线程是否还活着</li>
</ul>
<h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p><strong>调度策略：</strong></p>
<ul>
<li>时间片</li>
<li>抢占式：高优先级的线程抢占 CPU</li>
</ul>
<p><strong>Java 的调度方法：</strong></p>
<ul>
<li>同优先级线程组成先进先出队列(先到先服务)，使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p><strong>线程的优先级：</strong></p>
<ul>
<li>现成的优先级等级：<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN_PRIORITY：1</li>
<li>NORM_PRIORITY：5 (默认优先级)</li>
</ul>
</li>
<li>涉及的方法：<ul>
<li>getPriority()：返回线程优先值</li>
<li>setPriority(int newPriority)：改变线程的优先级</li>
</ul>
</li>
<li>说明：<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
<li>高优先级的线程要抢占低优先级线程 CPU 的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后低优先级的线程才执行</li>
</ul>
</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>JDK 中用 Thread.State 类定义了线程的几种状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java 语言使用 Thread 类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建(new)：当一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被 start() 后将进入线程队列等待 CPU 时间片，此时它已具备了运行的条件，只是没有分配到 CPU 资源</li>
<li>运行：当就绪的线程被调度并获得 CPU 资源时，便进入运行状态，run() 方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时终止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地终止或出现异常导致结束</li>
</ul>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p><strong>线程存在的问题：</strong></p>
<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对数据的共享，会造成操作的不完整性，会破坏数据</li>
</ul>
<p><strong>Java 中通过同步机制来解决线程的安全问题</strong></p>
<h3 id="线程同步方式一：同步代码块"><a href="#线程同步方式一：同步代码块" class="headerlink" title="线程同步方式一：同步代码块"></a>线程同步方式一：同步代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器) &#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>操作共享数据的代码，即为需要被同步的代码<br>共享数据：多个线程共同操作的变量(数据)</li>
<li>同步监视器，俗称：”锁”。任何一个类的对象，都可以充当锁<br>要求：多个线程必须要共用同一把锁</li>
<li>补充：<ul>
<li>在实现 Runnable 接口创建多线程的方式中，可以考虑使用 this 充当同步监视器</li>
<li>在继承于 Thread 类创建多线程的方式中，可以考虑使用当前类本身(ClassX.clss)充当同步监视器</li>
</ul>
</li>
</ul>
<h3 id="线程同步方式二：同步方法"><a href="#线程同步方式二：同步方法" class="headerlink" title="线程同步方式二：同步方法"></a>线程同步方式二：同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，可以将此方法声明为同步的</p>
<p><strong>关于同步方法的总结：</strong></p>
<ul>
<li>同步方法仍然涉及同步监视器，只是不需要显式的声明</li>
<li>非静态的同步方法，同步监视器是：this<br>静态的同步方法，同步监视器是：当前类本身</li>
</ul>
<h3 id="线程同步方式三：Lock-锁"><a href="#线程同步方式三：Lock-锁" class="headerlink" title="线程同步方式三：Lock(锁)"></a>线程同步方式三：Lock(锁)</h3><ul>
<li>从 JDK5.0开始，Java 提供了更强大的线程同步机制 —— 通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当</li>
<li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具<ul>
<li>锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象</li>
</ul>
</li>
<li>ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock，可以显式加锁、释放锁</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 实例化 ReentrantLock</span></span><br><span class="line">    <span class="comment">// 参数 fair: 默认为 false 表示不公平的; true 表示公平的，即先进先出</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.Lock();</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized 与 Lock 的异同：</strong></p>
<ul>
<li>相同：二者都可以解决线程安全问题</li>
<li>不同：<ul>
<li>synchronized 机制在执行完相应的同步代码以后，自动的释放同步监视器</li>
<li>Lock 需要手动的启动( lock() )，同时结束同步也需要手动实现( unlock() )</li>
</ul>
</li>
</ul>
<p><strong>synchronized 与 Lock 的对比：</strong></p>
<ul>
<li>Lock 是显式锁(手动开启和关闭锁)，synchronized 是隐式锁，出了作用域自动释放</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)</li>
<li>优先使用顺序：Lock -&gt; 同步代码块(已经进入了方法体，分配了相应资源) -&gt; 同步方法(在方法体之外)</li>
</ul>
<p><strong>线程同步的局限性：</strong>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低</p>
<h3 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h3><p><strong>死锁：</strong></p>
<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
<h3 id="关于锁的小结"><a href="#关于锁的小结" class="headerlink" title="关于锁的小结"></a>关于锁的小结</h3><p><strong>释放锁的操作：</strong></p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步方法、同步代码块中遇到 break、return 终止了该方法、该代码块的继续执行</li>
<li>当前线程在同步方法、同步代码块中出现了未处理的 Error 或 Exception，导致异常结束</li>
<li>当前线程在同步方法、同步代码块中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁</li>
</ul>
<p><strong>不会释放锁的操作：</strong></p>
<ul>
<li>线程执行同步方法或同步代码块时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁(同步监视器)<ul>
<li>应尽量避免使用 suspend() 和 resume() 来控制线程</li>
</ul>
</li>
</ul>
<h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><p><strong>例子：</strong>交替打印、生产者消费者</p>
<p><strong>涉及到的三个方法：</strong></p>
<ul>
<li>wait()：一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器</li>
<li>notify()：一旦执行此方法，就会唤醒被 wait() 的一个线程。如果有多个线程被 wait，就唤醒优先级高的线程</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被 wait 的线程</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>wait()、notify()、notifyAll() 这三个方法必须使用在同步代码块或同步方法中</li>
<li>wait()、notify()、notifyAll() 这三个方法的调用者必须是同步代码块或同步方法中的同步监视器<br>否则，会出现 IllegalMonitorStateException 异常</li>
<li>wait()、notify()、notifyAll() 这三个方法定义在 java.lang.Object 类中</li>
</ul>
<p><strong>sleep() 和 wait() 的异同：</strong></p>
<ul>
<li><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态</p>
</li>
<li><p>不同点：</p>
<ul>
<li>两个方法声明的位置不同：<ul>
<li>Thread 类中声明 sleep()</li>
<li>Object 类中声明 wait()</li>
</ul>
</li>
<li>调用的要求不同：<ul>
<li>sleep() 可以在任何需要的场景下调用</li>
<li>wait() 必须使用在同步代码块或同步方法中</li>
</ul>
</li>
<li>关于是否释放同步监视器(锁)：<ul>
<li>如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放、wait() 会释放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>String 类：代表字符串。Java 程序中的所有字符串字面值(如”str”)都为此类的实例实现</p>
<ul>
<li>String 实现了 Serializable 接口：表示字符串是支持序列化的</li>
<li>String 内部定义了 final char[] value 用于存储字符串数据。String 代表不可变的字符序列(不可变性)<ul>
<li>当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li>
<li>当对现有的字符串进行连接操作时，需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li>
<li>当调用 String 的 replace() 方法修改指定字符或字符串时，需要重新指定内存区域赋值，不能使用原有的 value 进行赋值</li>
</ul>
</li>
<li>通过字面量的方式(区别于 new)给一个字符串赋值，此时的字符串值声明在字符串常量池中</li>
<li>字符串常量池中不会存储相同内容的字符串</li>
<li>字符串是常量，用双引号引起来表示。值在创建之后不能更改</li>
</ul>
<h3 id="String-对象的创建："><a href="#String-对象的创建：" class="headerlink" title="String 对象的创建："></a>String 对象的创建：</h3><ul>
<li>通过字面量定义的方式：此时变量指向的数据声明在方法区中的字符串常量池中</li>
<li>通过 new + 构造器的方式：此时变量指向数据在堆空间中开辟空间以后对应的地址值</li>
<li><strong>因此会有如下结果：</strong><br>String s1 = “str”;String s2 = “str”;<br>String s3 = new String(“str”);String s4 = new String(“str”);<br>s1 == s2 结果为 true、s1 == s3 结果为 false、s3 == s4 结果为 false</li>
<li>字符串常量存储在字符串常量池，目的是共享</li>
<li>字符串非常量对象存储在堆中</li>
<li>String s = new String(“str”); 方式创建对象，在内存中创建了两个对象：<ul>
<li>一个是堆空间中 new 结构</li>
<li>另一个是 char[] 对应的常量池中的数据：”str”</li>
</ul>
</li>
</ul>
<h3 id="String-的拼接特性："><a href="#String-的拼接特性：" class="headerlink" title="String 的拼接特性："></a>String 的拼接特性：</h3><ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量</li>
<li>只要其中一个是变量，结果就在堆中</li>
<li>如果拼接的结果调用 intern() 方法，返回值就在常量池中 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过字面量定义的方式</span></span><br><span class="line">String str0 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上：this.value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上：this.value = original.value;</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(String original);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上：this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>

<h3 id="String-常用方法："><a href="#String-常用方法：" class="headerlink" title="String 常用方法："></a>String 常用方法：</h3><ul>
<li>int length()：返回字符串的长度：return value.length</li>
<li>char charAt(int index)：返回某索引处的字符：return value[index]</li>
<li>boolean isEmpty()：判断是否是空字符串：return value.length == 0</li>
<li>String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写</li>
<li>String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为小写</li>
<li>String trim()：返回字符串的副本，忽略前导空白和尾部空白</li>
<li>boolean equals(Object obj)：比较字符串的内容是否相同</li>
<li>boolean equalsIgnoreCase(String anotherString)：与 equals 方法类似，忽略大小写</li>
<li>String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用 “+”</li>
<li>int compareTo(String anotherString)：比较两个字符串的大小</li>
<li>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串</li>
<li>String substring(int beginIndex, int endIndex)：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到 endIndex(不包含)的一个子字符串</li>
<li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</li>
<li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</li>
<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</li>
<li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</li>
<li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最后出现处的索引</li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后出现处的索引，从指定的索引开始反向搜索<br>indexOf 和 lastIndexOf 方法如果未找到都是返回 -1</li>
<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</li>
<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</li>
<li>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串</li>
<li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</li>
<li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式</li>
<li>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串</li>
<li>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过 limit 个，如果超过了，剩下的全部拼接为一个元素</li>
</ul>
<h3 id="String-与其他类型之间的转换"><a href="#String-与其他类型之间的转换" class="headerlink" title="String 与其他类型之间的转换"></a>String 与其他类型之间的转换</h3><p><strong>字符串与基本数据类型、包装类之间的相互转换：</strong></p>
<ul>
<li>字符串 -&gt; 基本数据类型、包装类：<ul>
<li>调用包装类的静态方法</li>
</ul>
</li>
<li>基本数据类型、包装类 -&gt; 字符串：<ul>
<li>调用 String 重载的 valueOf() 方法</li>
</ul>
</li>
</ul>
<p><strong>字符串与字符数组之间的相互转换：</strong></p>
<ul>
<li>字符数组 -&gt; 字符串：<ul>
<li>String 类的构造器 String(char[])：用字符数组中的全部字符创建字符串对象</li>
<li>String(char[], int offset, int length)：用部分字符创建字符串对象</li>
</ul>
</li>
<li>字符串 -&gt; 字符数组：<ul>
<li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法</li>
<li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：将指定索引范围内的字符串存放到字符数组中的方法</li>
</ul>
</li>
</ul>
<p><strong>字符串与字节数组之间的相互转换：</strong></p>
<ul>
<li>字节数组 -&gt; 字符串：<ul>
<li>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String</li>
<li>String(byte[], int offset, int length)：用指定的字节数组的一部分，即从数组的起始位置 offset 开始取 length 个字节构造一个字符串对象</li>
</ul>
</li>
<li>字符串 -&gt; 字节数组：<ul>
<li>public byte[] getBytes()：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</li>
<li>public byte[] getBytes(String charsetName)：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组</li>
<li>解码时要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码</li>
</ul>
</li>
</ul>
<h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><p><strong>String、StringBuffer、StringBuilder 三者的异同：</strong></p>
<ul>
<li>String：不可变的字符序列：底层使用 char[] 存储</li>
<li>StringBuffer：可变的字符序列：线程安全的，效率较低，底层使用 char[] 存储</li>
<li>StringBuilder：可变的字符序列：jdk5.0 新增，线程不安全的，效率较高，底层使用 char[] 存储</li>
</ul>
<p><strong>StringBuffer 和 StringBuilder 的常用方法：</strong></p>
<ul>
<li>StringBuffer append(参数列表)：提供了一些 append() 方法，用于进行字符串拼接</li>
<li>StringBuffer delete(int start, int end)：删除指定位置的内容</li>
<li>StringBuffer replace(int start, int end, String str)：把[start, end) 位置(左闭右开，包含左不包含右)替换为 str</li>
<li>StringBuffer insert(int offset, xxx)：在指定位置插入 xxx</li>
<li>StringBuffer reverse()：把当前字符序列逆转</li>
<li>当 append 和 insert 时，如果原来 value 数组长度不够，可扩容</li>
<li>如上方法支持方法链操作(sB.append(“a”).append(“b”).append(“c”))</li>
</ul>
<p>方法链原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8-之前的日期时间-API"><a href="#JDK8-之前的日期时间-API" class="headerlink" title="JDK8 之前的日期时间 API"></a>JDK8 之前的日期时间 API</h2><h3 id="java-lang-System-类"><a href="#java-lang-System-类" class="headerlink" title="java.lang.System 类"></a>java.lang.System 类</h3><p>System 类提供的 public static currentTimeMillis() 用来返回当前时间与 1970 年 1 月 1 日 0 时 0 分 0 秒之间以毫秒为单位的时间差(时间戳)</p>
<ul>
<li>此方法适于计算时间差</li>
</ul>
<p><strong>计算世界时间的主要标准：</strong></p>
<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
<h3 id="java-util-Date-类"><a href="#java-util-Date-类" class="headerlink" title="java.util.Date 类"></a>java.util.Date 类</h3><p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li>构造器：<ul>
<li>Date()：使用无参构造器创建的对象可以获取本地当时时间</li>
<li>Date(long date)：创建指定毫秒数的 Date 对象</li>
</ul>
</li>
<li>常用方法：<ul>
<li>getTime()：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数</li>
<li>toString()：把此 Date 对象转换为以下形式的String：dow mon dd hh:mm:ss zzz yyyy 其中：dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri、Sat)，zzz 是时间标准</li>
<li>其他很多方法已过时</li>
</ul>
</li>
</ul>
<h3 id="java-text-SimpleDateFormat-类"><a href="#java-text-SimpleDateFormat-类" class="headerlink" title="java.text.SimpleDateFormat 类"></a>java.text.SimpleDateFormat 类</h3><p>Date 类的 API 不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化：日期 -&gt; 文本，解析：文本 -&gt; 日期</p>
<p><strong>格式化：</strong></p>
<ul>
<li>SimpleDateFormat()：默认的模式和语言环境创建对象</li>
<li>public SimpleDateFornat(String pattern)：该构造方法可以用参数 pattern 指定的格式创建一个对象，该对象调用：<ul>
<li>public String format(Date date)：方法格式化事件对象 date</li>
</ul>
</li>
</ul>
<p><strong>解析：</strong></p>
<ul>
<li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期</li>
<li>解析要求字符串必须是符合 SimpleDateFormat 识别的格式(通过构造器参数体现)</li>
</ul>
<h3 id="java-util-Calendar-类-日历类"><a href="#java-util-Calendar-类-日历类" class="headerlink" title="java.util.Calendar 类(日历类)"></a>java.util.Calendar 类(日历类)</h3><p>Calendar 是一个抽象基类，主要用于完成日期字段之间相互操作的功能</p>
<p>获取 Calendar 实例的方法：</p>
<ul>
<li>使用 Calendar.getInstance() 方法</li>
<li>调用它的子类 GregorianCalendar 的构造器</li>
</ul>
<p>一个 Calendar 的实例是系统时间的抽象表示，通过 get(int field) 方法来取得想要的时间信息。比如 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</p>
<ul>
<li>public void set(int field, int value)：将指定 field 设置成新的值</li>
<li>public void add(int field, int amount)：将指定 field 增加 amount、减少可以使用负的 amount</li>
<li>public final Date getTime()：通过日历类获取 Date 对象</li>
<li>public final void setTime(Date date)：将 Date 的对象的时间设置成日历类的时间</li>
<li>注意：<ul>
<li>获取月份时：一月是 0、二月是 1，以此类推</li>
<li>获取星期时：周日是1、周二是 2，以此类推</li>
</ul>
</li>
</ul>
<h2 id="JDK8-中新的日期时间-API"><a href="#JDK8-中新的日期时间-API" class="headerlink" title="JDK8 中新的日期时间 API"></a>JDK8 中新的日期时间 API</h2><p>Date 与 Calendar 面临的问题：</p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的</li>
<li>偏移性：Date 中的年份是从 1900 开始的，二月份都从 0 开始</li>
<li>格式化：格式化只对 Date 有用，Calendar 则不行</li>
<li>此外它们也不是线程安全的、不能处理闰秒等</li>
<li>闰秒：指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中(也可能在季末)对协调世界时增加或减少 1 秒的调整</li>
</ul>
<h3 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h3><p><strong>java.time：</strong>包含值对象的基础包</p>
<p>java.time 中包含了所有关于：本地日期(LocalDate)、本地时间(LocalTime)、本地日期时间(LocalDateTime)、时区(ZonedDateTime)和持续时间(Duration)的类</p>
<p>LocalDate、LocalTime、LocalDateTime 它们的实例是不可变的对象，它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息</p>
<ul>
<li>LocalDate 代表 ISO 格式(yyy-MM-dd)的日期</li>
<li>LocalTime 表示一个时间</li>
<li>LocalDateTime 用来表示日期和时间</li>
<li>注：ISO-8601 日历系统是国际标准化组织制定的现代公民的日期和时间的表示法(公历)</li>
</ul>
<p><strong>关于 LocalDate、LocalTime、LocalDateTime 类创建对象及其对象的相关方法：</strong></p>
<ul>
<li>now() / now(ZoneId zone)：静态方法，根据当前时间创建对象 / 指定时区的对象<br>获取当前的日期、时间、日期+时间</li>
<li>of()：静态方法，根据指定日期/时间创建对象<br>设置指定的年、月、日、时、分、秒。没有偏移量</li>
<li>getDayOfMonth() / getDayOfYear()：获得月份天数(1-31) / 获得年份天数(1-366)</li>
<li>getDayOfWeek()：获得星期几(返回一个 DayOfWeek 枚举类)</li>
<li>getMonth()：获得月份(返回一个 Month 枚举类)</li>
<li>getMonthValue() / getYear()：获得月份(1-12) / 获得年份</li>
<li>getHour() / getMinute() / getSecond()：获得当前对象对应的小时、分钟、秒</li>
<li>withDayOfMonth() / withDayOfYear() / withMonth() / withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</li>
<li>plusDays() / plusWeeks() / plusMonths() / plusYears() / plusHours()：向当前对象增加几天、几周、几个月、几年、几小时</li>
<li>minusDays() / minusWeeks() / minusMonths() / minusYears() / minusHours()：向当前对象减去几天、几周、几个月、几年、几小时</li>
</ul>
<p><strong>Instant(瞬时)：</strong>时间线上的一个瞬时点</p>
<ul>
<li><p>只是简单的表示自 1970 年 1 月 1 日 0 分 0 秒(UTC) 开始的秒数)</p>
</li>
<li><p>因为 java.time 包是基于纳秒计算的，所以 Instant 的精度可以达到纳秒级(1 ns = 10^(-9) s、1秒=1000毫秒=10^6微妙=10^9纳秒)</p>
</li>
</ul>
<p><strong>关于 Instant 类创建对象及其对象的相关方法：</strong></p>
<ul>
<li>now()：静态方法，返回默认 UTC 时区的 Instant 类的对象</li>
<li>ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00:00:00 基础上加上指定毫秒数之后的 Instant 类的对象</li>
<li>atOffset(ZoneOffset offset)：结合即时的偏移来创建一个 OffsetDateTime</li>
<li>toEpochMilli()：返回 1970-01-01 00:00:00 到当前时间的毫秒数，即为时间戳</li>
</ul>
<h3 id="java-time-format-DateTimeFormatter-类"><a href="#java-time-format-DateTimeFormatter-类" class="headerlink" title="java.time.format.DateTimeFormatter 类"></a>java.time.format.DateTimeFormatter 类</h3><p><strong>该类提供了三种格式化方法：</strong></p>
<ul>
<li><p>预定义的标准格式</p>
<ul>
<li>ISO_LOCAL_DATE_TIME</li>
<li>ISO_LOCAL_DATE</li>
<li>ISO_LOCAL_TIME</li>
</ul>
</li>
<li><p>本地化相关的格式：</p>
<ul>
<li><p>ofLocalizedDate(FormatStyle.LONG)：适用于LocalDate</p>
<ul>
<li>FormatStyle.FULL</li>
<li>FormatStyle.LONG</li>
<li>FormatStyle.MEDIUM</li>
<li>FormatStyle.SHORT</li>
</ul>
</li>
<li><p>ofLocalizedDateTime(FormatStyle.LONG)：适用于 LocalDateTime</p>
<ul>
<li>FormatStyle.LONG</li>
<li>FormatStyle.MEDIUM</li>
<li>FormatStyle.SHORT</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义的格式，如：ofPattern(“yyyy-MM-dd hh:mm:ss E”)</p>
</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>ofPattern(String pattern)：静态方法，返回一个指定字符串格式的 DateTimeFormater</li>
<li>format(TemporalAccessor t)：格式化一个日期、时间，返回字符串</li>
<li>parse(CharSequence texr)：将指定格式的字符序列解析为一个日期、时间</li>
</ul>
<h3 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h3><ul>
<li>ZoneId：该类中包含了所有的时区信息，一个时区的 ID，如 Europe/Paris</li>
<li>ZonedDateTime：一个在 ISO-8601 日历系统时区的日期时间，如 2020-11-22T16:31:22+01:00 Europe/Paris<ul>
<li>其中每个时区都对应着 ID，地区 ID 都为 “{区域}/{城市}” 的格式，例如：Asia/Shanghai 等</li>
</ul>
</li>
<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟</li>
<li>持续时间：Duration，用于计算两个 “时间” 间隔</li>
<li>日期间隔：Period，用于计算两个 “日期” 间隔</li>
<li>TemporalAdjuster：时间校正器。如：将日期调整到 “下一个工作日” 等操作</li>
<li>TemporalAdjusters：该类通过以下静态方法提供了大量的常用 TemporalAdjuster 的实现：<ul>
<li>firstDayOfXxx()</li>
<li>lastDayOfXxx()</li>
<li>nextXxx()</li>
</ul>
</li>
</ul>
<h3 id="与遗留日期处理类的转换"><a href="#与遗留日期处理类的转换" class="headerlink" title="与遗留日期处理类的转换"></a>与遗留日期处理类的转换</h3><table>
<thead>
<tr>
<th>类</th>
<th align="left">转换为(To)遗留类</th>
<th align="left">升级为新类</th>
</tr>
</thead>
<tbody><tr>
<td>java.time.Instant 与 java.util.Date</td>
<td align="left">Date.from(instant)</td>
<td align="left">date.toinstant()</td>
</tr>
<tr>
<td>java.time.Instant 与 java.sql.Timestamp</td>
<td align="left">Timestamp.from(instant)</td>
<td align="left">timestamp.toinstant()</td>
</tr>
<tr>
<td>java.time.zonedDateTime 与 java.util.GregorianCalendar</td>
<td align="left">GregorianCalendar.from(zonedDateTime)</td>
<td align="left">cal.toZonedDateTime()</td>
</tr>
<tr>
<td>java.time.LocalDate 与 java.sql.Date</td>
<td align="left">Date.valueOf(localDate)</td>
<td align="left">date.toLocalDate()</td>
</tr>
<tr>
<td>java.time.LocalTime 与 java.sql.Time</td>
<td align="left">Date.valueOf(localTime)</td>
<td align="left">date.toLocalTime()</td>
</tr>
<tr>
<td>java.time.LocalDateTime 与 java.sql.Timestamp</td>
<td align="left">Timestamp.valueOf(localDateTime)</td>
<td align="left">timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td>java.time.ZoneId 与 java.util.TimeZone</td>
<td align="left">Timestamp.getTimeZone(id)</td>
<td align="left">timeZone.toZonedId()</td>
</tr>
<tr>
<td>java.time.format.DateTimeFormatter 与 java.text.DateFormat</td>
<td align="left">formatter.toFormat()</td>
<td align="left">无</td>
</tr>
</tbody></table>
<h2 id="Java-比较器"><a href="#Java-比较器" class="headerlink" title="Java 比较器"></a>Java 比较器</h2><p>在 Java 中经常会涉及到对象数组的排序问题，涉及到对象之间的比较问题，正常情况下只能进行比较：== 或 !=，不能使用 &gt; 或 &lt;</p>
<p><strong>Java 实现对象排序的方式：</strong></p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.lang.Comparator</li>
</ul>
<h3 id="java-lang-Comparable-接口"><a href="#java-lang-Comparable-接口" class="headerlink" title="java.lang.Comparable 接口"></a>java.lang.Comparable 接口</h3><p>像 String、包装类等实现了 Comparable 接口，重写了 compareTo(Object obj) 方法，给出了比较两个对象大小的方式</p>
<p>重写 compareTo(Object obj) 的规则：</p>
<ul>
<li>如果当前对象 this 大于形参对象 obj，则返回正整数</li>
<li>如果当前对象 this 小于形参对象 obj，则返回负整数</li>
<li>如果当前对象 this 等于形参对象 obj，则返回零</li>
</ul>
<p>对于自定义类，如果需要排序，可以让自定义类实现 comparable 接口，重写 compareTo(Object obj) 方法，在 compareTo(Object obj) 方法中指明如何排序</p>
<h3 id="java-lang-Comparator"><a href="#java-lang-Comparator" class="headerlink" title="java.lang.Comparator"></a>java.lang.Comparator</h3><p>当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较</p>
<ul>
<li>重写 compare(Object  obj1, Object obj2) 方法，比较 obj1 和 obj2 的大小，如果方法返回正整数，则表示 obj1 大于 obj2、如果返回 0，表示相等、返回负整数，表示 obj1 小于 obj2</li>
<li>可以将 Comparator 传递给 sort 方法(如 Collections.sort 或 Arrays.sort)，从而允许在排序顺序上实现精确控制</li>
<li>还可以使用 Comparator 来控制某些数据结构(如有序 set 或有序映射)的顺序，或者为那些没有自然顺序的对象 collection 提供排序</li>
</ul>
<p><strong>Comparable 接口与 Comparator 的使用对比：</strong></p>
<ul>
<li>Comparable 接口的方式一旦一定，保证 Comparable 接口实现类的对象在任何位置都可以比较大小</li>
<li>Comparator 接口属于临时性的比较</li>
</ul>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><ul>
<li>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部，该类位于 java.lang 包</li>
<li>由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的</li>
<li>成员变量：<ul>
<li>System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流(键盘输入)、标准输出流(显示器)和标准错误输出流(显示器)</li>
</ul>
</li>
<li>成员方法：<ul>
<li>native long currentTimeMillis()：返回当前的计算机时间，时间的表达格式为当前计算机时间和 GMT 时间(格林威治时间)1970年1月1日0时0分0秒所差的毫秒数</li>
<li>void exit(int status)：退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。(使用该方法可以在图形界面编程中实现程序的退出功能)</li>
<li>void gc()：请求系统进行垃圾回收。至于系统是否立即回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况</li>
<li>String getProperty(String key)：获得系统中属性名为 key 的属性对应的值<ul>
<li>java.version：java 运行时环境版本</li>
<li>java.home：java 安装目录</li>
<li>os.name：操作系统的名称</li>
<li>os.version：操作系统的版本</li>
<li>user.name：用户的账户名称</li>
<li>user.home：用户的主目录</li>
<li>user.dir：用户的当前工作目录 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><ul>
<li>abs：求绝对值</li>
<li>acos、asin、atan、cos、sin、tan：三角函数</li>
<li>sqrt：求平方根</li>
<li>pow(double a, double b)：求 a 的 b 次幂</li>
<li>log：自然对数</li>
<li>exp：e 为底指数</li>
<li>max(double a, double b)：求最大值</li>
<li>min(double a, double b)：求最小值</li>
<li>random()：返回 0.0 到 1.0 之间的随机数</li>
<li>long round(double a)：double 型数据 a 转换为 long 型(四舍五入)</li>
<li>toDegrees(double angrad)：弧度 -&gt; 角度</li>
<li>toRadians(double angdeg)：角度 -&gt; 弧度</li>
</ul>
<h2 id="BigInteger-与-BigDecimal"><a href="#BigInteger-与-BigDecimal" class="headerlink" title="BigInteger 与 BigDecimal"></a>BigInteger 与 BigDecimal</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>Integer 类作为 int 的包装类，能存储的最大整型值为 <code>2^31 -1</code> ，Long 类也是有限的。如果要表示再大的整数，不管是基本数据类型还是它们的包装类都无能为力</p>
<p>java.math 包的 BigInteger 可以表示不可变的任意精度的整数。BigInteger 除了与 Java 中基本整数操作相同外还提供：模算数、GCD 计算、质数测试、素数生成、位操作以及一些其他操作</p>
<p><strong>构造器：</strong>BigInteger(String val)：根据字符串构建 BigInteger 对象</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>public BigInteger abs()：返回 BigInteger 的绝对值的 BigInteger</li>
<li>BigInteger add(BigInteger val)：返回其值为(this + val)的 BigInteger</li>
<li>BigInteger subtract(BigInteger val)：返回其值为(this - val)的 BigInteger</li>
<li>BigInteger multiply(BigInteger val)：返回其值为(this * val)的 BigInteger</li>
<li>BigInteger divide(BigInteger val)：返回其值为(this / val)的 BigInteger。整数相除只保留整数部分</li>
<li>BigInteger remainder(BigInteger val)：返回其值为(this % val)的 BigInteger</li>
<li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含(this / val)后跟(this % val)的两个 BigInteger 的数组</li>
<li>BigInteger pow(int exponent)：返回其值为(this^exponent)的 BigInteger</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类</p>
<p>BigDecimal 类支持不可变的、任意精度的有符号十进制定点数</p>
<p><strong>构造器：</strong></p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p><strong>枚举类的理解：</strong>类的对象是确定的且只有有限个，称此类为枚举类</p>
<ul>
<li><strong>需要定义一组常量时强烈建议使用枚举类</strong></li>
<li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li>
</ul>
<h2 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h2><ul>
<li>JDK5.0 之前，自定义枚举类<ul>
<li>自定义枚举类</li>
<li>声明对象的属性：private final 修饰</li>
<li>私有化(private)类的构造器，并初始化对象的属性</li>
<li>提供当前枚举类的多个对象：public static final 修饰</li>
<li>其他功能：<ul>
<li>获取枚举类对象的属性</li>
<li>提供 toString()</li>
</ul>
</li>
</ul>
</li>
<li>JDK5.0 新增，可以使用 enum 关键字定义枚举类<ul>
<li>使用 enum 关键字定义枚举类：默认继承于 java.lang.Enum 类</li>
<li>提供当前枚举类的对象，多个对象之间用逗号 “,” 隔开，末尾对象用分号 “;” 结束：enumObjName(“stringContent”)</li>
<li>声明对象的属性：private final 修饰</li>
<li>私有化(private)类的构造器，并初始化对象的属性</li>
<li>提供当前枚举类的多个对象：public static final 修饰</li>
<li>其他功能：<ul>
<li>获取枚举类对象的属性</li>
<li>提供 toString()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Enum-中的常用方法"><a href="#Enum-中的常用方法" class="headerlink" title="Enum 中的常用方法"></a>Enum 中的常用方法</h2><p><strong>Enum 类的主要方法：</strong></p>
<ul>
<li>values()：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值</li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的”名字”。若不是则出现运行时异常：IllegalArgumentException</li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
<h2 id="使用-enum-关键字定义的枚举类实现接口的情况"><a href="#使用-enum-关键字定义的枚举类实现接口的情况" class="headerlink" title="使用 enum 关键字定义的枚举类实现接口的情况"></a>使用 enum 关键字定义的枚举类实现接口的情况</h2><ul>
<li>情况一：实现接口，在 enum 类中实现抽象方法</li>
<li>情况二：让枚举类的对象分别实现接口中的抽象方法<ul>
<li>enumObjName(“stringContent”){  // 实现抽象方法}</li>
</ul>
</li>
</ul>
<h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><p>从 JDK5.0 开始，Java 增加了对元数据(MetaData)的支持。也就是 Annotation(注解)</p>
<ul>
<li>Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理</li>
<li>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在 Annotation 的 “name=value” 对中</li>
</ul>
<h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p>使用 Annotation 时要在其前面增加 @ 符号，并把该 Annotation 当成一个修饰符使用，用于修饰它支持的程序元素</p>
<ul>
<li>生成文档相关的注解：<ul>
<li>@author：标明开发该类模块的作者，多个作者之间使用逗号 “,” 分隔</li>
<li>@version：标明该类模块的版本</li>
<li>@see：标明参考转向，也就是相关主题</li>
<li>@since：标明从哪个版本开始增加</li>
<li>@param：对方法中某参数的说明，如果没有参数则不能写</li>
<li>@return：对方法返回值的说明，如果方法的返回值类型是 void 则不能写</li>
<li>exception：对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常则不能写</li>
<li>其中：<ul>
<li>@param、@return、@exception 这三个标记都是只用于方法的</li>
<li>@param 的格式要求：@param 形参名 形参类型 形参说明</li>
<li>@return 的格式要求：@return 返回值类型 返回值说明</li>
<li>@exception 的格式要求：@exception 异常类型 异常说明</li>
<li>@param 和 @exception 可以并列多个</li>
</ul>
</li>
</ul>
</li>
<li>在编译时进行格式检查(JDK 内置的三个基本注解)<ul>
<li>@Override：限定重写父类方法，该注解只能用于方法</li>
<li>@Deprecated：用于表示所修饰的元素(类、方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings：抑制编译器警告<ul>
<li>@SuppressWarnings(“unused”)</li>
<li>@SuppressWarnings({ “unused”, “rawtypes” })</li>
</ul>
</li>
</ul>
</li>
<li>跟踪代码依赖性，实现替代配置文件功能<ul>
<li>Servlet3.0 提供了注解(Annotation)，使得不再需要在 web.xml 文件中进行 Servlet 的部署</li>
<li>spring 框架中关于 “事务” 的管理</li>
</ul>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p><strong>说明：</strong></p>
<ul>
<li>定义新的 Annotation 类型使用 @interface 关键字</li>
<li>自定义注解自动继承了 java.lang.annotation.Annotation 接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。称为配置参数。类型只能是八种基本数据类型、String 类型、Class 类型、enum 类型、Annotation 类型、以上所有类型的数组</li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值，指定成员变量的初始值可以使用 default 关键字</li>
<li>如果只有一个参数成员，建议使用参数名为 value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式为 “参数名=参数值”，如果只有一个参数成员，且名称为 value，可以省略 “value=”</li>
<li>没有成员定义的 Annotation 称为标记、包含成员变量的 Annotation 称为元数据 Annotation</li>
</ul>
<p><strong>注意：自定义注解必须配上注解的信息处理流程(使用反射)才有意义</strong></p>
<p><strong>自定义注解通常都会指明两个元注解：@Retention、@Target</strong></p>
<p><strong>步骤：</strong></p>
<ul>
<li>注解声明为：@interface</li>
<li>内部定义成员，通常使用 value</li>
<li>可以指定成员的默认值，使用 default 定义</li>
<li>如果自定义注解没有成员，标明是一个标识</li>
</ul>
<h2 id="JDK-中的元注解"><a href="#JDK-中的元注解" class="headerlink" title="JDK 中的元注解"></a>JDK 中的元注解</h2><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义</p>
<p>JDK5.0 提供了 4 个标准的 meta-annotation 类型：</p>
<ul>
<li>@Retrntion：只能用于修饰一个 Annotation 定义，用于指定该 Annotation 的生命周期，@Retention 包含一个 RetentionPolicy 类型的成员变量，使用 @Retention 时必须为该 value 成员变量指定值：<ul>
<li>RetentionPolicy.SOURCE：在源文件中有效(即源文件保留)，编译器直接丢弃这种策略的注解</li>
<li>RetentionPolicy.CLASS：在 class 文件中有效(即 class 保留)，当运行 Java 程序时，JVM 不会保留注解。(该值为默认值)</li>
<li>RetentionPolicy.RUNTIME：在运行时有效(即运行时保留)，当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li>
<li>只有声明为 RUNTIME 声明周期的注解，才能通过反射获取</li>
</ul>
</li>
<li>@Target：用于修饰 Annotation 定义，用于指定被修饰的 Annotation 能用于修饰哪些程序元素。@Target 也包含一个名为 value 的成员变量<ul>
<li>CONSTRUCTOR：用于描述构造器</li>
<li>FIELD：用于描述域</li>
<li>LOCAL_VARIABLE：用于描述局部变量</li>
<li>METHOD：用于描述方法</li>
<li>PACKAGE：用于描述包</li>
<li>PARAMETER：用于描述参数</li>
<li>TYPE：用于描述类、接口(包括注解类型)或 enum 声明</li>
</ul>
</li>
<li>@Documented：用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。默认情况下，javadoc 是不包括注解的<ul>
<li>定义为 Documented 的注解必须设置 Retention 值为 RUNTIME</li>
</ul>
</li>
<li>@Inherited：被它修饰的 Annotation 将具有继承性。如果某个类使用了被 @Inherited 修饰的 Annotation，则其子类将自动具有该注解<ul>
<li>比如：如果把标有 @Inherited 注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解</li>
<li>实际使用较少</li>
</ul>
</li>
</ul>
<h2 id="JDK8-中注解的新特性"><a href="#JDK8-中注解的新特性" class="headerlink" title="JDK8 中注解的新特性"></a>JDK8 中注解的新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p><strong>JDK8 之前的写法：</strong></p>
<ul>
<li>实现 MyAnnotation：public @interface MyAnnotation{String value() default “str”;}</li>
<li>实现 MyAnnotations：public @interface MyAnnotations{MyAnnotations[] value();}</li>
<li>使用：@MyAnnotations({@MyAnnotation(value=”str1”), @MyAnnotation(value=”str2”)})</li>
</ul>
<p>JDK8 新增支持的写法：</p>
<ul>
<li>在 MyAnnotation 上声明 @Repeatable，成员值为 MyAnnotations.class<ul>
<li>在 public @interface MyAnnotation{String value() default “str”;} 之上加上注解 @Repeatable(MyAnnotations.class)</li>
</ul>
</li>
<li>MyAnnotation 的 Target 和 Retention 等元注解与 MyAnnotations 保持一致<ul>
<li>@Retention(RetentionPolicy.RUNTIME)</li>
<li>@Target({TYPE, FIELD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</li>
<li>@Inherited、…</li>
</ul>
</li>
</ul>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>JDK8 之后，关于元注解 @Target 的参数类型 ElementType 枚举值多了两个：TYPE_PARAMETER、TYPE_USE</p>
<p>在 Java8 之前，注解只能是在声明的地方所使用，Java8 开始，注解可以应用在任何地方：</p>
<ul>
<li>ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中(如：泛型声明)</li>
<li>ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Java-进阶(2/2)</title>
    <url>/2020/11/22/%E9%87%8D%E5%AD%A6Java-%E8%BF%9B%E9%98%B62/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>【因内容较多，已拆分为两篇博文，此为篇二】<br>本篇博文为 Java 的一些高级特性的常见概念及相关细节梳理，意在重学 Java 查漏补缺。<br>博文随时会进行更新，补充新的内容并修正错漏，该系列博文旨在帮助自己巩固扎实 Java 基础。<br>毕竟万丈高楼，基础为重，借此督促自己时常温习回顾。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合、数组都是对多个数据进行存储(内存层面)操作的结构，即容器</p>
<p><strong>数组在内存存储方面的特点：</strong></p>
<ul>
<li>数组初始化后长度确定</li>
<li>数组声明的类型就决定了进行元素初始化时的类型</li>
</ul>
<p><strong>数组在存储数据方面的弊端：</strong></p>
<ul>
<li>数组初始化后长度不可变，不便于拓展</li>
<li>数组中提供的属性和方法不便于进行添加、删除、插入等操作，且效率不高<br>无法直接获取已存储元素的个数</li>
<li>数组存储的数据是有序(存入顺序)的、可重复的 —— 存储数据的特点单一</li>
</ul>
<p><strong>集合类可用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组</strong></p>
<p><strong>Java 集合可分为 Collection 和 Map 两种体系：</strong></p>
<ul>
<li>Collection 接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合<ul>
<li>ArrayList、LinkedList、Vector</li>
</ul>
</li>
<li>Set：元素无序、不可重复的集合<ul>
<li>HashSet、LinkedHashSet、TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map 接口：双列数据，保存具有映射关系 “key-value” 对 的集合<ul>
<li>HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li>
</ul>
</li>
</ul>
<h1 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h1><p><strong>常用方法：</strong>(例：Collection collectionVar = new ArrayList();)</p>
<ul>
<li>add(Object e)：将元素 e 添加到集合(collectionVar)中</li>
<li>size()：获取集合(collectionVar)中的元素个数</li>
<li>addAll(Collection collection)：将集合(collection)中的元素添加到当前集合(collectionVar)中</li>
<li>isEmpty()：判断当前集合(collectionVar)是否为空</li>
<li>clear()：清空集合(collectionVar)中的元素</li>
<li>contains(Object obj)：判断当前集合(collectionVar)中是否包含 obj<ul>
<li>向 Collection 接口实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 equals() 方法</li>
<li>判断时会调用 obj 对象所在类的 equals() 方法</li>
</ul>
</li>
<li>containsAll(Collection collection)：判断集合(collection)中的所有元素是否都存在于当前集合(collectionVar)中</li>
<li>remove(Object obj)：从当前集合(collectionVar)中移除 obj 元素</li>
<li>removeAll(Collection collection)：从当前集合(collectionVar)中移除指定集合(collection)中所有的元素(求差集)</li>
<li>retainAll(Colllection collection)：保留当前集合(collectionVar)与指定集合(collection)中所有相同的元素(求交集)</li>
<li>equals(Object obj)：判断当前集合(collectionVar)与指定 obj 中元素是否相同<ul>
<li>针对有序集合与元素顺序也相关</li>
<li>针对无序集合元素顺序无关</li>
</ul>
</li>
<li>hashCode()：返回当前对象的哈希值</li>
<li>集合 -&gt; 数组：toArray()<ul>
<li>数组 -&gt; 集合：调用 Arrays 类的静态方法 asList()<ul>
<li>注意：Arrays.asList(new int[]{1, 2, 3}) 与 Arrays.asList(new Integer[]{1, 2, 3}) 不同，前者结果为包含 1 个元素(int 数组对象)的集合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Iterator-迭代器接口"><a href="#Iterator-迭代器接口" class="headerlink" title="Iterator 迭代器接口"></a>Iterator 迭代器接口</h2><p>Iterator 对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素</p>
<ul>
<li>GOF 给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需要暴露该对象的内部细节。迭代器模式就是为容器而生</li>
<li>Iterator 仅用于遍历集合，Iterator 本身并不提供承载对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合</li>
<li>集合对象每次调用 iterator() 方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</li>
<li>Iterator 内部定义了 remove() 方法，可以在遍历的时候删除集合中的元素<ul>
<li>此方法不同于集合直接调用 remove()</li>
<li>如果还未调用 next() 或在上一次调用 next() 之后已经调用了 remove()，再次调用 remove() 将会抛出异常：IllegalStateException</li>
</ul>
</li>
<li>常用方法：<ul>
<li>hasNext()：判断是否还有下一个元素</li>
<li>next()：指针下移并将下移后集合位置上的元素返回</li>
<li>建议在调用 next() 方法之间必须要调用 hasNext() 进行检测。若不进行检测，且下一条记录无效，直接调用 next() 会抛出异常：NoSuchElementException</li>
</ul>
</li>
</ul>
<h2 id="foreach-循环遍历"><a href="#foreach-循环遍历" class="headerlink" title="foreach 循环遍历"></a>foreach 循环遍历</h2><p>Java5.0 提供了 foreach 循环迭代访问 Collection 和数组</p>
<ul>
<li>遍历操作不需要获取 Collection 或数组的长度，无需使用索引访问元素</li>
<li>遍历结合的底层调用 Iterator 完成操作</li>
<li>使用方法：<ul>
<li>for(集合元素的类型 局部变量 : 集合对象){}</li>
<li>for(数组元素的类型 局部变量 : 数组对象){}</li>
</ul>
</li>
</ul>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p><strong>List 接口的常用实现类：</strong>ArrayList、LinkedList 和 Vector</p>
<p><strong>ArrayList、LinkedList 和 Vector 的对比：</strong></p>
<ul>
<li><p>相同点：三个类都实现了 List 接口，存储数据的特点相同：存储有序的、可重复的数据</p>
</li>
<li><p>不同点：</p>
<ul>
<li>ArrayList：线程不安全，效率高；底层使用 Object[] elementData 存储</li>
<li>LinkedList：对于频繁的插入、删除操作使用此类效率比 ArrayList 高：底层使用双线链表存储</li>
<li>Vector：线程安全，效率低；底层使用 Object[] elementData 存储</li>
<li>Vector 在扩容方面默认扩容为原来数组长度的 2 倍 </li>
</ul>
</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>ArrayList 源码分析(JDK7)：</strong></p>
<ul>
<li>ArrayList list = new ArrayList();<ul>
<li>底层创建长度为 10 的 Object[] 数组 elementData</li>
</ul>
</li>
<li>list.add(1);<ul>
<li>elementData[0] = new Integer(1);</li>
</ul>
</li>
<li>list.add(2);list.add(3); 以此类推 list.add(11);<ul>
<li>list.add(11); 导致底层 elementData 数组容量不足，则扩容</li>
<li>默认情况下，扩容为原容量 1.5 倍，同时将原数组中元素复制到新数组中</li>
</ul>
</li>
<li>注：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity);</li>
</ul>
<p><strong>ArrayList 源码分析(JDK8)：</strong></p>
<ul>
<li>ArrayList list = new ArrayList();<ul>
<li>底层 Object[] elementData 初始化为 {}，并没有创建长度为 10 的数组</li>
</ul>
</li>
<li>list.add(1);<ul>
<li>第一次调用 add() 时，底层才创建了长度为 10 的数组，并将数据添加到 elementData[0]</li>
</ul>
</li>
<li>后续添加与扩容操作与 JDK7 一致</li>
</ul>
<p><strong>注：</strong>JDK7 中 ArrayList 的对象创建类似于单例模式中的饿汉式；JDK8 中 ArrayList 的对象创建类似于单例模式的懒汉式，延迟了数组的创建，节省内存</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList：双向链表，内部没有声明数组，而是定义了 Node 类型的 first 和 last 用于记录首、尾元素</p>
<ul>
<li>内部类 Node 作为 LinkedList 中保存数据的基本结构</li>
<li>Node 除保存数据，还定义了两个变量：<ul>
<li>prev 变量记录前一个元素的位置</li>
<li>next 变量记录后一个元素的位置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LinkedList 源码分析：</strong></p>
<ul>
<li>LinkedList list = new LinkedList();<ul>
<li>内部声明了 Node 类型的 first 和 last 属性，默认值为 null</li>
</ul>
</li>
<li>list.add(1);<ul>
<li>创建 Node 对象，将数据封装到 Node 中</li>
</ul>
</li>
</ul>
<h3 id="List-接口方法"><a href="#List-接口方法" class="headerlink" title="List 接口方法"></a>List 接口方法</h3><p>List 除了从 Collection 继承的方法外还增加了一些根据索引来操作集合元素的方法</p>
<ul>
<li>void add(int index, Object obj)：在 index 位置插入 obj 元素</li>
<li>boolean addAll(int index, Collection eles)：从 index 位置开始将 eles 中的所有元素添加进来</li>
<li>Object get(int index)：获取指定 index 位置的元素</li>
<li>int indexOf(Object obj)：返回 obj 在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj)：返回 obj 在集合中最后一次出现的位置</li>
<li>Object remove(int index)：移除指定 index 位置的元素，并返回此元素<ul>
<li><strong>注意区分 remove(int index) 和 remove(Object obj)</strong></li>
</ul>
</li>
<li>Object set(int index, Object obj)：设置指定 index 位置的元素 为 obj</li>
<li>List subList(int fromIndex, int toIndex)：返回从 fromIndex 到 toIndex 位置的子集合</li>
</ul>
<h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><p><strong>Set 接口的常用实现类：</strong>HashSet、LinkedSet、TreeSet</p>
<p><strong>HashSet、LinkedSet 和 TreeSet的对比：</strong></p>
<ul>
<li><p>相同点：三个类都实现了 Set 接口，存储数据的特点相同：存储无序的、不可重复的数据</p>
</li>
<li><p>不同点：</p>
<ul>
<li>HashSet：线程不安全；可以存储 null</li>
<li>LinkedSet：作为 HashSet 的子类：遍历其内部数据时，可以按照添加顺序遍历<ul>
<li>对于频繁的遍历操作，LinkedHashSet 效率高于 HashSet</li>
</ul>
</li>
<li>TreeSet：可以按照添加对象的指定属性进行排序</li>
</ul>
</li>
</ul>
<p><strong>Set 接口中没有额外定义新的方法，使用的都是 Collection 中声明过的方法</strong></p>
<p><strong>无序性：</strong>不等于随机性</p>
<ul>
<li>以 HashSet 为例：存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据 hash 值决定的</li>
</ul>
<p><strong>不可重复性：</strong>相同的元素只能添加一个(保证添加的元素按照 equal() 方法判断时返回结果为 false)</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用该实现类</p>
<ul>
<li>HashSet 按 Hash 算法来存储集合中的元素，因此具有较好的存取、查找、删除性能</li>
</ul>
<p><strong>HashSet 底层结构：</strong>数组 + 链表</p>
<ul>
<li>数组初始容量为 16，当使用率超过其 0.75 倍，则扩容为原来的 2 倍</li>
</ul>
<p><strong>HashSet 的特点：</strong></p>
<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet 不是线程安全的</li>
<li>集合元素可以是 null</li>
</ul>
<p><strong>对于存放在 Set 容器中的对象，对应的类必须重写 equals() 方法和 hashCode(Object obj) 方法，以实现对象的相等判断规则(相等的对象必须具有相等的散列码)</strong></p>
<ul>
<li>重写的原则：<ul>
<li>通常参与计算 hashCode 的对象的属性也应该参与到 equals() 中进行计算</li>
<li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值</li>
<li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等</li>
<li>对象中用作 equals() 方法比较的 Field 都应该用来计算 hashCode 值</li>
</ul>
</li>
</ul>
<blockquote>
<p>Eclipse 与 IntelliJ IDEA 工具中 hashCode() 的重写，可以调用工具自动完成，这里有个数字 31</p>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的 hash 地址越大，所谓的 “冲突” 就越少，查找起来效率也会提高(减少冲突)</li>
<li>并且 31 只占用 5bits，相乘造成的数据溢出的概率较小</li>
<li>31 可以由 i*31==(i&lt;&lt;5)-1 来表示(提高算法效率)</li>
<li>31 是一个素数，素数作用就是如果用一个数字乘这个素数，那么结果只能被这个素数本身和被乘数以及 1 整除(减少冲突)</li>
</ul>
</blockquote>
<p><strong>向 HashSet 中添加元素的过程：</strong></p>
<ul>
<li>向 HashSet 中添加新元素，首先调用新元素所在类的 hashCode() 方法，计算新元素的 hash 值，此 hash 值接着通过某种散列函数计算出在 HashSet 底层数组中的存储位置(索引位置)，接着判断数组此位置上是否已经有元素：<ul>
<li>若此位置没有其他元素，则新元素添加成功(情况 A)</li>
<li>若此位置已有元素(或以链表形式存在的多个元素)，则比较新元素与已有元素的 hash 值：<ul>
<li>若 hash 值不相同，则新元素添加成功(情况 B)</li>
<li>若 hash 值相同，进而需要调用新元素所在类的 equals() 方法：<ul>
<li>equals() 返回 false，则新元素添加成功(情况 C)</li>
<li>equals() 返回 true，则新元素添加失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于新元素添加成功的情况而言：B 与 C 的情况下，新元素与已经存在的指定索引位置上的数据以链表的方式存储</p>
<ul>
<li>JDK7：新元素存放在数组中，指向原来的元素</li>
<li>JDK8：原来的元素在数组中，指向新元素</li>
</ul>
<blockquote>
<p> 向 HashSet 中添加元素的过程：</p>
<ul>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。(这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计得越好)</li>
<li>如果两个元素的 hashCode 值相等，会再继续调用 equals() 方法，如果 equals() 方法结果为 true，添加失败；如果为 false，那么会保存该元素，但是该数组的位置已经有元素，因此会通过链表的方式继续链接</li>
<li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode 值不相等，HashSet 将会把它们存储在不同的位置，依然可以添加成功</li>
</ul>
</blockquote>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet 是 HashSet 的子类</p>
<ul>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的<ul>
<li>在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据</li>
</ul>
</li>
<li>LinkedHashSet 的插入性能略低于 HashSet，但在迭代访问 Set 集合中全部元素时有很好的性能</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态</p>
<ul>
<li>TreeSet 底层使用红黑树结构存储数据</li>
<li>TreeSet 两种排序方法<ul>
<li>(默认采用)自然排序 Comparable<ul>
<li>比较两个对象是否相同的标准为：compareTo() 返回 0。(不再是 equals())</li>
</ul>
</li>
<li>(传入参数)定制排序 Comparator<ul>
<li>比较两个对象是否相同的标准为：compare() 返回 0。(不再是 equals())</li>
</ul>
</li>
</ul>
</li>
<li>向 TreeSet 中添加的数据要求是相同类的对象</li>
</ul>
<h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><p>Map：双列数据，存储 key-value对 数据</p>
<ul>
<li>HashMap：线程不安全，效率高；key 和 value 可以为 null<ul>
<li>LinkedHashMap：保证在遍历时可以按照添加的顺序<br>在原有的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素<br>对于频繁的遍历操作，此类执行效率高于 HashMap</li>
</ul>
</li>
<li>TreeMap：保证按照添加的 key-value对 进行排序，实现排序遍历。(考虑 key 的自然排序或定制排序)</li>
<li>Hashtable：线程安全，效率低；key 和 value 不能为 null<ul>
<li>Properties：常用来处理配置文件。key 和 value 都是 String 类型</li>
</ul>
</li>
</ul>
<h2 id="Map-结构"><a href="#Map-结构" class="headerlink" title="Map 结构"></a>Map 结构</h2><ul>
<li>Map 中的 key：无序、不可重复，使用 Set 存储(HashMap：key 所在的类要重写 equals() 方法和 hashCode() 方法)</li>
<li>Map 中的 value：无序、可重复，使用 Collection 存储(value 所在的类要重写 equals() 方法)</li>
<li>一个键值对：key-value 构成一个 Entry 对象</li>
<li>Map 中的 Entry 的对象(entry)：无序、不可重复，使用 Set 存储</li>
</ul>
<h2 id="Map-中的常用方法"><a href="#Map-中的常用方法" class="headerlink" title="Map 中的常用方法"></a>Map 中的常用方法</h2><ul>
<li>添加、删除、修改操作：<ul>
<li>Object put(Object key, Object value)：将指定 key-value 添加到(或修改 value)当前 map 对象中</li>
<li>void putAll(Map m)：将 m 中的所有 key-value对 存放到当前 map 中</li>
<li>Object remove(Object key)：移除指定 key 的 key-value对，并返回 value</li>
<li>void clear()：清空当前 map 中的所有数据</li>
</ul>
</li>
<li>查询操作：<ul>
<li>Objec get(Object key)：获取指定 key 对应的 value</li>
<li>boolean containsKey(Object key)：判断是否包含指定的 key</li>
<li>boolean containsValue(Object value)：判断是否包含指定的 value</li>
<li>int size()：返回 map 中 key-value对 的个数</li>
<li>boolean isEmpty()：判断当前 map 是否为空</li>
<li>boolean equals(Object obj)：判断当前 map 和 obj 是否相等</li>
</ul>
</li>
<li>元视图操作：<ul>
<li>Set keySet()：返回所有 key 构成的 Set 集合</li>
<li>Collection values()：返回所有 value 构成的 Collection 集合</li>
<li>Set entrySet()：返回所有 key-value对 构成的 Set 集合</li>
</ul>
</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>HashMap 的底层实现原理(JDK7)：</strong></p>
<ul>
<li>HashMap map = new HashMap(); ：底层创建长度为 16 的一维数组 Entry[] table</li>
<li>map.put(key, value); ：首先调用 key 所在类的 hashCode() 方法计算 key 的 hash 值，此 hash 值经过某种算法计算得到 Entry 数组中的存放位置<ul>
<li>若此位置数据为空，此时 key-value 添加成功(情况 A)</li>
<li>若此位置数据不为空(存在一个或多个数据(以链表形式存在))，比较 key 与已存在的一个或多个数据的 hash 值<ul>
<li>若 key 的 hash 值与已存在的数据的 hash 值都不相同，此时 key-value 添加成功(情况 B)</li>
<li>若 key 的 hash 值与已存在的某一个数据的 hash 值相同，则调用 key 所在类的 equals() 与这个原数据的 key 做比较<ul>
<li>若 equals() 返回 false，此时 key-value 添加成功(情况 C)</li>
<li>若 equals() 返回 true，则使用 value 替换原数据的 value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于 key-value 添加成功的情况而言：B 与 C 的情况下，key-value 与原数据以链表的方式存储</p>
<p>在添加过程中涉及到扩容问题，当超出临界值时(且要存放的位置非空)默认扩容为 2 倍</p>
<p><strong>HashMap 在 JDK8 与 JDK7 底层实现方面的区别(针对 JDK8 而言)：</strong></p>
<ul>
<li>new HashMap()：底层没有直接创建一个长度为 16 的数组</li>
<li>JDK8 的底层数组是 Node[]，不再是 Entry[]</li>
<li>首次调用 put() 方法时，底层创建长度为 16 的数组</li>
<li>JDK7 底层实现结构：数组 + 链表；JDK8 底层实现结构：数组 + 链表 + 红黑树<ul>
<li>当数组的某一索引位置上的元素以链表形式存在的数据个数大于 8 且当前数组的长度大于 64 则此时索引位置上的所有数据改为使用红黑树存储</li>
</ul>
</li>
</ul>
<p><strong>HashMap 源码中的主要常量：</strong></p>
<ul>
<li>DEFAULT_INITAL_CAPACITY：HashMap 的默认容量</li>
<li>MAXIMUM_CAPACITY：HashMap 的最大支持容量 2^30</li>
<li>DEFAULT_LOAD_FACTOR：HashMap 的默认负载因子</li>
<li>TREEIFY_THRESHOLD：Bucket 中链表长度大于该默认值，转化为红黑树</li>
<li>UNTREEIFY_THRESHOLD：Bucket 中红黑树存储的 Node 小于该默认值，转化为链表</li>
<li>MIN_TREEIFY_CAPACITY：Bucket 中的 Node 被树化时最小的 hash 表容量<br>当 Bucket 中 Node 的数量大到需要转红黑树时，若 hash 表容量小于 MIN_TREEIFY_CAPACITY，此时应执行 resize 扩容这个 MIN_TREEIFY_CAPACITY 的值至少是 TREEIFY_THRESHOLD 的 4 倍</li>
<li>table：存储元素的数组，总是 2 的 n 次幂</li>
<li>entrySet：存储具体元素的集合</li>
<li>size：HashMap 中存储的键值对的数量</li>
<li>modeCount：HashMap 扩容和结构改变的次数</li>
<li>threshold：扩容的临界值(容量 * 负载因子)</li>
<li>loadFactor：负载因子</li>
</ul>
<p><strong>负载因子值的大小，对 HashMap 的影响：</strong></p>
<ul>
<li>负载因子的大小决定了 HashMap 的数据密度</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或添加时的比较次数增多，性能会下降</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，即发生碰撞的几率越小，数组中的链表也就越短，查询和添加时比较的次数也越少，性能会更高。但是会浪费一定的内存空间，而且经常扩容也会影响性能，因此建议初始化预设大一点的空间</li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为 0.7 ~ 0.75，此时平均检索长度接近于常数</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>HashMap 中的内部类：Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 中的内部类：Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;  <span class="comment">// 实现记录添加的元素的先后顺序</span></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties 类是 Hashtable 的子类，该对象用于处理配置文件</p>
<ul>
<li>配置文件中的 key、value 都是字符串类型，所以 Properties 中的 key、value 都是字符串类型</li>
<li>存取数据时，建议使用 setProperty(String key, String value) 方法和 getProperty(string key) 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">String db = pros.getProperty(<span class="string">&quot;db&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 是一个操作 List、Set 和 Map 等集合的工具类</p>
<ul>
<li>Collections 中提供了一系列静态方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
</ul>
<h3 id="Collections-常用方法：同步控制"><a href="#Collections-常用方法：同步控制" class="headerlink" title="Collections 常用方法：同步控制"></a>Collections 常用方法：同步控制</h3><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可以将指定集合包装为线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
<ul>
<li>synchronizedCollection(Collection&lt;T&gt; c)</li>
<li>synchronizedList(List&lt;T&gt; list)</li>
<li>synchronizedMap(Map&lt;K, T&gt; m)</li>
<li>synchronizedSet(Set&lt;T&gt;, s)</li>
<li>synchronizedSortedMap(SortedMap&lt;K, V&gt;, m)</li>
<li>synchronizedSortedSet(Sorted&lt;T&gt; s)</li>
</ul>
<h3 id="Collections-常用方法"><a href="#Collections-常用方法" class="headerlink" title="Collections 常用方法"></a>Collections 常用方法</h3><p><strong>排序操作(static 方法)：</strong></p>
<ul>
<li>reverse(List list)：反转 list 中元素的顺序</li>
<li>shuffle(List list)：对 list 集合元素进行随机排序</li>
<li>sort(List list)：对 list 集合元素进行自然排序(升序)</li>
<li>sort(List list, Comparator comparator)：根据指定的 comparator 对 list 集合元素进行定制排序</li>
<li>swap(List list, int i, int j)：将指定 list 集合中 i 处元素和 j 处元素进行交换</li>
</ul>
<p><strong>查找、替换：</strong></p>
<ul>
<li>Object max(Collection collection)：根据元素自然排序结果，返回给定集合中的最大元素</li>
<li>Object max(Collection collection, Comparator comparator)：根据 comparator 指定的排序规则，返回给定集合中的最大元素</li>
<li>Object min(Collection collection)：根据元素自然排序结果，返回给定集合中的最小元素</li>
<li>Object min(Collection collection, Comparator comparator)：根据 comparator 指定的排序规则，返回给定集合中的最小元素</li>
<li>int frequency(Collection collection, Object obj)：返回指定集合中指定元素的出现次数</li>
<li>void copy(List, dest, List src)：将 src 中的内容复制到 dest 中</li>
<li>boolean raplaceAll(List list, Object oldVal, Object newVal)：使用新值替换 List 集合中所有的旧值</li>
</ul>
<h1 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型(Generic)"></a>泛型(Generic)</h1><p>集合容器类在设计阶段(声明阶段)不能确定这个容器到底实际存的时什么类型的对象，所以在 JDK5 之前只能把元素类型设计为 Object。JDK5 之后使用泛型来解决</p>
<ul>
<li>因为这个时候除了元素的类型不确定，其他的部分是确定的，如关于这个元素如何保存，如何管理等。</li>
<li>此次此时将元素的类型设计成一个参数，该类型参数即泛型</li>
</ul>
<h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><p>允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值以及参数类型</p>
<ul>
<li>这个类型参数在使用时(如：继承或实现这个接口，用这个类型声明变量、创建对象时)确定(即传入实际的类型参数，也称为类型实参)</li>
</ul>
<p>从 JDK5 后，Java 引入了 “参数化类型(Parameterized type)” 的概念，允许在创建集合时再指定集合元素的类型</p>
<ul>
<li>如：List&lt;String&gt;，表明该 List 只能保存字符串类型的对象</li>
</ul>
<h3 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h3><p>JDK5 改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参</p>
<ul>
<li>在实例化集合类时，可以指明具体的泛型类型</li>
<li>在集合类或接口中凡是定义类或接口时，内部结构(如：方法、构造器、属性等)使用到类的泛型的位置，都指定为实例化的泛型类型<br>如 add(E e) 实例化后 add(Integer e)</li>
<li>注意：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，可用包装类代替</li>
<li>若实例化时没有指明泛型的类型，默认类型为 java.lang.Object 类型</li>
</ul>
<h2 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h2><h3 id="自定义泛型类、泛型接口"><a href="#自定义泛型类、泛型接口" class="headerlink" title="自定义泛型类、泛型接口"></a>自定义泛型类、泛型接口</h3><ul>
<li><p>泛型类可能有多个参数，此时可将多个参数放在一对尖括号内 “&lt;&gt;”，如&lt;E1, E2, E3&gt;</p>
</li>
<li><p>泛型类的无参构造器与普通无参构造器一致：public GenericClass(){}</p>
</li>
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致</p>
</li>
<li><p>泛型不同的引用不能相互赋值</p>
<ul>
<li>尽管在编译时 ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 是两种类型，但在运行时只有一个 ArrayList 被加载到 JVM 中</li>
</ul>
</li>
<li><p>泛型如果不指定将被擦除，泛型对应的类型均按照 Object 处理，但不等价于 Object</p>
<ul>
<li>建议：泛型一旦使用便要从一而终</li>
</ul>
</li>
<li><p>若泛型结构是一个接口或抽象类，则不能创建泛型类的对象</p>
</li>
<li><p>JDK7 新增类型推断，泛型的简化操作：ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换</p>
</li>
<li><p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型(静态方法的加载要早于类的初始化)</p>
</li>
<li><p>异常类不能是泛型的</p>
</li>
<li><p>不能使用 new E[]</p>
<ul>
<li>但可使用 E[] elements = (E[])new Object[capacity];<br>参考：ArrayList 源码中声明：Object[] elementData，而非泛型参数类型数组</li>
</ul>
</li>
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型</p>
<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型 -&gt; 擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
<li>子类除了指定或保留父类的泛型，还可以增加自己的泛型</li>
</ul>
</li>
</ul>
<h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><p>方法也可被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时参数的类型就是传入数据的类型</p>
<p><strong>泛型方法的格式：</strong>访问权限 &lt;泛型&gt; 返回类型 方法名(泛型标志 参数名称) 抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> id, E e)</span> </span>&#123;</span><br><span class="line">        E result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型方法：</strong>在方法中出现泛型结构，泛型参数与类的泛型参数没有任何关系</p>
<ul>
<li>泛型方法所属的类是不是泛型类都无关</li>
<li>泛型方法可以声明为静态的<ul>
<li>泛型参数是在调用方法时确定的，并非在实例化类时确定</li>
</ul>
</li>
</ul>
<h2 id="泛型在继承方面的体现"><a href="#泛型在继承方面的体现" class="headerlink" title="泛型在继承方面的体现"></a>泛型在继承方面的体现</h2><p>虽然类 A 是类 B 的父类，但是 E&lt;A&gt; 和 E&lt;B&gt; 二者不具备子、父类关系，二者是并列关系</p>
<ul>
<li>区别：类 A 是类 B 的父类，A&lt;E&gt; 是 B&lt;E&gt; 的父类</li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>泛型可以使用通配符 “?”，比如 List&lt;?&gt;，Map&lt;?&gt;</p>
<ul>
<li>List&lt;?&gt; 是 List&lt;String&gt;、List&lt;Object&gt; 等各种泛型 List 的父类<ul>
<li>类 A 是类 B 的父类，E&lt;A&gt; 和 E&lt;B&gt; 没有关系，二者共同的父类是 E&lt;?&gt; </li>
</ul>
</li>
<li>读取 List&lt;?&gt; 的对象 list 中的元素时，永远是安全的，因为无论 list 的真实类型，它包含的都是 Object</li>
<li>不可以向 list 中写入(添加元素)，因为不知道元素的类型，不能向其中添加对象<ul>
<li>唯一的例外是 null，它是所有类型的成员</li>
</ul>
</li>
</ul>
<h3 id="有限制条件的通配符"><a href="#有限制条件的通配符" class="headerlink" title="有限制条件的通配符"></a>有限制条件的通配符</h3><ul>
<li>&lt;?&gt;<ul>
<li>允许所有泛型的引用调用</li>
</ul>
</li>
<li>通配符指定上限<ul>
<li>上限 extends：使用时指定的类型必须是继承某个类，或者实现某个接口(即小于等于 &lt;=)</li>
<li>? extends A：G&lt;? extends A&gt; 可以作为 G&lt;A&gt; 和 G&lt;B&gt; 的父类，其中 B 是 A 的子类</li>
<li>&lt;? extends Number&gt;：(无穷小, Number]：只允许泛型为 Number 及 Number 子类的引用调用<ul>
<li>左开右闭：包括右不包括左</li>
</ul>
</li>
<li>&lt;? extends Comparable&gt;：只允许泛型为实现 Comparable 接口的实现类的引用调用</li>
</ul>
</li>
<li>通配符指定下限<ul>
<li>下限 super：使用时指定的类型不能小于操作的类(即大于等于 &gt;=)</li>
<li>？super A：G&lt;? super A&gt; 可以作为 G&lt;A&gt; 和 G&lt;B&gt; 的父类，其中 B 是 A 的父类</li>
<li>&lt;? super Number&gt;：[Number, 无穷大)：只允许泛型为 Number 及 Number 父类的引用调用<ul>
<li>左闭右开：包括左不包括右</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h1><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>java.io.File 类：文件和文件目录路径的抽象表示形式，与平台无关</p>
<ul>
<li>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身<ul>
<li>若需要访问文件内容本身，则需要使用 IO 流</li>
</ul>
</li>
<li>若要在 Java 程序中表示一个真实存在的文件或目录，则必须有一个 File 对象<ul>
<li>但 Java 程序中的一个 File 对象有时并不表示一个真实存在的文件或目录</li>
</ul>
</li>
<li>File 对象可作为参数传递给流的构造器</li>
</ul>
<h3 id="常用构造器"><a href="#常用构造器" class="headerlink" title="常用构造器"></a>常用构造器</h3><p>public File(String pathname)</p>
<ul>
<li>以 pathname 为路径创建 File 对象，可以是绝对路径或相对路径，若是相对路径则默认的当前路径在系统属性 user.dir 中存储</li>
</ul>
<p>public File(String parent, String child)</p>
<ul>
<li>以 parent 为父路径，child 为子路径创建 File 对象</li>
</ul>
<p>Public File(File parent, String child)</p>
<ul>
<li>根据一个父 File 对象和子文件路径创建 File 对象</li>
</ul>
<h3 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a>路径分隔符</h3><p>路径中的每级目录之间用一个路径分隔符隔开，路径分隔符与系统相关：</p>
<ul>
<li>Windows 和 DOS 系统默认采用 “\“ 表示</li>
<li>UNIX 和 URL 使用 “/“ 表示</li>
</ul>
<p>File 类提供常量，根据操作系统动态提供分隔符：</p>
<ul>
<li>public static final String separator</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>File 类的获取功能：</strong></p>
<ul>
<li>public String getAbsolutePath()：获取绝对路径</li>
<li>public String getPath()：获取路径</li>
<li>public String getName()：获取名称</li>
<li>public String getParent()：获取上层文件目录路径。若没有则返回 null</li>
<li>public long length()：获取文件长度(即字节数)。不能获取目录的长度</li>
<li>public long lastModified()：获取最后一次的修改时间，毫秒值</li>
<li>适用于文件目录：<ul>
<li>public string[] list()：获取指定目录下的所有文件或文件目录的名称数组</li>
<li>public File[] listFiles()：获取指定目录下的所有文件或文件目录的 File 数组</li>
</ul>
</li>
</ul>
<p><strong>File 类的重命名功能：</strong></p>
<ul>
<li>public boolean renameTo(File dest)：把文件重命名为指定的文件路径<ul>
<li>fileA.rename(fileB) 重命名成功条件：要求 fileA 真实存在且 fileB 不存在 </li>
</ul>
</li>
</ul>
<p><strong>File 类的创建功能：</strong></p>
<ul>
<li>public boolean createNewFile()：创建文件(若此文件存在则不创建，返回 false)</li>
<li>public boolean mkdir()：创建文件目录(若此文件目录存在则不创建；若此文件目录的上层目录不存在也不创建)</li>
<li>public boolean mkdirs()：创建文件目录(若此文件目录的上层目录不存在则一并创建)</li>
</ul>
<p><strong>File 类的删除功能：</strong></p>
<p>public boolean delete()：删除文件或文件目录(文件夹)</p>
<ul>
<li>Java 中删除不进入回收站(Windows)</li>
<li>要删除一个文件目录，需要该文件目录内不能包含文件或文件目录</li>
</ul>
<p><strong>File 类的判断功能：</strong></p>
<ul>
<li>public boolean isDirectory()：判断是否是文件目录</li>
<li>public boolean isFile()：判断是否是文件</li>
<li>public boolean exists()：判断是否存在</li>
<li>public boolean canRead()：判断是否可读</li>
<li>public boolean canWrite()：判断是否可写</li>
<li>public boolean isHidden()：判断是否隐藏</li>
</ul>
<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><p>I/O 是 Input/Output 的缩写，I/O 技术用于处理设备之间的数据传输</p>
<ul>
<li>Java 程序中，对于数据的输入/输出操作以 “流(steam)” 的方式进行</li>
<li>java.io 包下提供各种 “流” 类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据</li>
</ul>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p><strong>按操作数据单位不同：</strong></p>
<ul>
<li>字节流(8 bit)</li>
<li>字符流(16 bit)</li>
</ul>
<p><strong>按数据流的流向不同：</strong>输入流、输出流</p>
<p><strong>按流的角色不同：</strong>节点流、处理流</p>
<table>
<thead>
<tr>
<th>(抽象基类)</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Weiter</td>
</tr>
</tbody></table>
<p><strong>IO 流体系：</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td><strong>InputStream</strong></td>
<td><strong>OutputStream</strong></td>
<td><strong>Reader</strong></td>
<td><strong>Weiter</strong></td>
</tr>
<tr>
<td>访问文件</td>
<td><strong>FileInputStream</strong></td>
<td><strong>FileOutputStream</strong></td>
<td><strong>FileReader</strong></td>
<td><strong>FileWeiter</strong></td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWeiter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWeiter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWeiter</td>
</tr>
<tr>
<td>缓冲流</td>
<td><strong>BufferedInputStream</strong></td>
<td><strong>BufferedOutputStream</strong></td>
<td><strong>BufferedReader</strong></td>
<td><strong>BufferedWeiter</strong></td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td><strong>InputStreamReader</strong></td>
<td><strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td>对象流</td>
<td><strong>ObjectInputStream</strong></td>
<td><strong>ObjectOutputStream</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWeiter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintOutputStream</td>
<td></td>
<td>PrintWeiter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>数据流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>用于存储和读取基本数据类型数据或对象的处理流</p>
<ul>
<li>可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原</li>
</ul>
<p><strong>序列化：</strong>用 ObjectOutputStream 类保存基本类型数据或对象的机制</p>
<p><strong>反序列化：</strong>用 ObjectInputStream 类读取基本类型数据或对象的机制</p>
<p>ObjectOutputStream 和 ObjectInputStream 不能序列化 static 和 transient 修饰的成员变量</p>
<p>序列化的特点在于可将任何实现了 Serializable 接口的对象转换为字节数据，使其在保存和传输时可被还原</p>
<p>序列化是 RMI(Remote Method Invoke —— 远程方法调用)过程的参数和返回值都必须实现的机制</p>
<p>若要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，即所涉及的类必须实现 Serializable 接口或 Externalizable 接口之一</p>
<p>凡是实现 Serializable 接口的类都有一个表示序列化版本标识符的静态变量：private static final long serialVersionUID</p>
<ul>
<li>其用来表明类的不同版本间的兼容性(对序列化对象进行版本控制，检测对象各版本序列化时是否兼容)</li>
<li>若没有显式定义，Java 运行时环境根据类的内部细节自动生成。若类的实例变量做了修改，SerialVersionUID 可能发生变化，因此建议显式声明</li>
<li>Java 的序列化机制通过在运行时判断类的 serialVersionUID 来验证版本一致性。在进行反序列化时，JVM 将传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，若相同便认为是一致的，可以进行序列化，否则出现序列化版本不一致的异常(InvalidCastException)</li>
</ul>
<h1 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射(Reflection)"></a>反射(Reflection)</h1><p>反射被认为是动态语言的关键。反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p>
<ul>
<li>加载完类后，在堆内存的方法区产生了一个 Class 类型的对象(一个类只有一个 Class 对象)，这个对象包含了完整的类的结构信息，可以通过这个对象看到类的结构</li>
<li>正常方式：引入需要的 “包.类” 名称 -&gt; 通过 new 实例化 -&gt; 取得实例化对象</li>
<li>反射方式：实例化对象 -&gt; getClass() 方法 -&gt; 得到完整的 “包.类” 名称</li>
</ul>
<p><strong>反射机制提供的功能：</strong></p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<p><strong>反射相关的主要 API：</strong></p>
<ul>
<li>java.lang.Class：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
</ul>
<p><strong>关于 java.lang.Class 类的理解：</strong></p>
<ul>
<li>将字节码文件进行解释运行便相当于将某个字节码文件加载到内存中，此过程称为类的加载</li>
<li>加载到内存中的类，称其为运行时类，此运行时类就作为 Class 的一个实例</li>
<li><strong>Class 的实例就对应着一个运行时类</strong></li>
</ul>
<h2 id="获取-Class-的实例"><a href="#获取-Class-的实例" class="headerlink" title="获取 Class 的实例"></a>获取 Class 的实例</h2><p>加载到内存中的运行时类，会缓存一定的时间，在此时间内，可以通过不同的方式来获取此运行时类(唯一的)</p>
<ul>
<li>调用运行时类的属性：.class<ul>
<li>Class objClass = Object.class</li>
</ul>
</li>
<li>通过运行时类的对象，调用 getClass()<ul>
<li>Object obj = new Object();<br>class objClass = obj.getClass();</li>
</ul>
</li>
<li>调用 Class 的静态方法：forName(String classPath)<ul>
<li>Class objClass = Class.forNmae(“java.lang.Object”);</li>
<li>其中 classPath 以类的全类名方式表示<ul>
<li>类的全类名：包含包名在内的类的完整路径</li>
</ul>
</li>
</ul>
</li>
<li>使用类的加载器<ul>
<li>ClassLoader classLoader = Person.class.getClassLoader();<br>Class objClass = classLoader.loadClass(“java.lang.Object”);</li>
</ul>
</li>
</ul>
<p><strong>拥有 Class 对象的结构：</strong></p>
<ul>
<li>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组<ul>
<li>只要数组的元素类型与维度一样，就是同一个 Class</li>
</ul>
</li>
<li>enum：枚举类</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>当程序主动使用某个类时，若该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化：</p>
<ul>
<li>类的加载(Load)<ul>
<li>将类的 .class 文件读入内存，并为其创建一个 java.lang.Class 对象(此过程由类加载器完成)</li>
</ul>
</li>
<li>类的链接(Link)<ul>
<li>将类的二进制数据合并到 JRE 中</li>
</ul>
</li>
<li>类的初始化(Initialize)<ul>
<li>JVM 负责对类进行初始化</li>
</ul>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>类加载器的作用：</strong></p>
<ul>
<li>类加载作用：将 .class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口</li>
<li>类缓存：标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象</li>
</ul>
<p><strong>JVM 规范定义了如下类型的类加载器：</strong></p>
<ul>
<li>Bootstrap Classloader：引导类加载器：C++ 编写，JVM 自带类加载器，负责 Java 平台核心类库，用来加载核心类库，该类加载器无法直接获取</li>
<li>Extension Classloader：扩展类加载器：负责 jre/lib/ext 目录下的 jar 包或 -D java.ext.dirs 指定目录下的 jar 包装入工作</li>
<li>System Classloader：系统类加载器：负责 java -classpath 或 -D java.class.path 所指定的目录下的类与 jar 包装入工作(最常用)</li>
</ul>
<p>对于自定义类，使用系统类加载器进行加载</p>
<ul>
<li>调用系统类加载器的 getParent() 获取扩展类加载器</li>
<li>调用扩展类加载器的 getParent() 无法获取引导类加载器</li>
<li>引导类加载器主要负责加载 Java 的核心类库，无法加载自定义类</li>
</ul>
<p><strong>读取配置文件的两种方式：</strong></p>
<ul>
<li>FileInputStream 方式：此时文件默认在当前 module 下<ul>
<li>FileInputStream f = new FileInputStream(“filePath”);</li>
</ul>
</li>
<li>ClassLoader 方式：此时文件默认在当前 module 的 src 下<ul>
<li>InputStream f = classLoader.getResourseAsStream(“filePath”);</li>
</ul>
</li>
</ul>
<h2 id="通过反射创建运行时类的对象"><a href="#通过反射创建运行时类的对象" class="headerlink" title="通过反射创建运行时类的对象"></a>通过反射创建运行时类的对象</h2><p><strong>newInstance()</strong> 方法：创建对应运行时类的对象(内部调用了运行时类的空参构造器)</p>
<ul>
<li>运行时类必须提供空参构造器</li>
<li>空参构造器必须有合适的访问权限</li>
</ul>
<p>JavaBean 中要求提供一个 public 的空参构造器</p>
<ul>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类，默认调用 super() 时，保证父类有此构造器</li>
</ul>
<h2 id="获取运行时类结构的常用方法"><a href="#获取运行时类结构的常用方法" class="headerlink" title="获取运行时类结构的常用方法"></a>获取运行时类结构的常用方法</h2><p><strong>获取属性结构：</strong></p>
<ul>
<li>Field[] getFields()<ul>
<li>获取当前运行时类及其父类中声明为 public 访问权限的属性</li>
</ul>
</li>
<li>Field[] getDeclareFields()<ul>
<li>获取当前运行时类中声明的所有属性(不包含父类中声明的属性)</li>
</ul>
</li>
<li>获取属性权限修饰符：<ul>
<li>int getModifiers()<ul>
<li>针对获取到的返回值，可将参数传入 Modifier.toString(int i) 方法查看具体权限名</li>
</ul>
</li>
</ul>
</li>
<li>获取属性数据类型：<ul>
<li>Class getType()<ul>
<li>针对获取到的返回值可调用 getName() 方法查看具体数据类型名</li>
</ul>
</li>
</ul>
</li>
<li>获取属性变量名：<ul>
<li>getName()：针对具体属性可调用</li>
</ul>
</li>
</ul>
<p><strong>获取方法结构：</strong></p>
<ul>
<li>Method[] getMethods()<ul>
<li>获取当前运行时类及其父类中声明为 public 权限的方法</li>
</ul>
</li>
<li>Method[] getDeclareMethods()<ul>
<li>获取当前运行时类中声明的所有方法(不包含父类中声明的方法)</li>
</ul>
</li>
<li>获取方法声明的注解：<ul>
<li>Annotation[] getAnnotation()：针对具体方法可调用</li>
</ul>
</li>
<li>获取方法权限修饰符：<ul>
<li>int getModifiers()<ul>
<li>针对获取到的返回值，可将参数传入 Modifier.toString(int i) 方法查看具体权限名</li>
</ul>
</li>
</ul>
</li>
<li>获取方法返回值类型：<ul>
<li>int getReturnType()<ul>
<li>针对获取到的返回值可调用 getName() 方法查看具体数据类型名</li>
</ul>
</li>
</ul>
</li>
<li>获取方法名：<ul>
<li>getName()：针对具体方法可调用</li>
</ul>
</li>
<li>获取形参列表：<ul>
<li>Class[] getParameterTypes()：针对具体方法可调用</li>
</ul>
</li>
<li>获取抛出的异常：<ul>
<li>Class[] getExceptionTypes()：针对具体方法可调用</li>
</ul>
</li>
</ul>
<p><strong>获取构造器结构：</strong></p>
<ul>
<li>Constructor[] getConstructors()<ul>
<li>获取当前运行时类中声明为 public 的构造器</li>
</ul>
</li>
<li>Constructor[] getDeclaredContructors()<ul>
<li>获取当前运行时类中声明的所有的构造器</li>
</ul>
</li>
</ul>
<p><strong>获取运行时类所在的包：</strong></p>
<ul>
<li>Package getPackage()</li>
</ul>
<p><strong>获取运行时类声明的注解：</strong></p>
<ul>
<li>Annotation[] getAnnotations()</li>
</ul>
<p><strong>获取运行时类实现的接口：</strong></p>
<ul>
<li>Class[] getInterfaces()：</li>
</ul>
<p><strong>获取运行时类的父类：</strong></p>
<ul>
<li>Class getSuperclass()：获取当前运行时类的父类</li>
<li>获取运行时类的父类实现的接口：<ul>
<li>Class[] getSuperclass().getInterfaces()</li>
</ul>
</li>
<li>获取运行时类的带泛型的父类：<ul>
<li>Class getGenericSuperclass()</li>
</ul>
</li>
<li>获取运行时类的带泛型的父类的泛型：<ul>
<li>Type[] ((ParameterizedType) classObj.getGenericSuperclass()).getActualTypeArguments()<ul>
<li>可针对具体的 Type[] 中的元素调用 getName() 查看其名称<ul>
<li>result[0].getName();</li>
<li>((Class) result[0]).getName();</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="操作运行时类中的指定结构"><a href="#操作运行时类中的指定结构" class="headerlink" title="操作运行时类中的指定结构"></a>操作运行时类中的指定结构</h2><h3 id="操作运行时类中的指定的属性"><a href="#操作运行时类中的指定的属性" class="headerlink" title="操作运行时类中的指定的属性"></a>操作运行时类中的指定的属性</h3><ul>
<li>Field getDeclaredField(String fieldName)：获取运行时类中指定变量名的属性</li>
<li>setAccessible(true)：设置当前属性可访问</li>
<li>Object get(Object obj)：获取指定对象的此属性值</li>
<li>set(Object obj, Object value)：设置指定对象的此属性值</li>
</ul>
<p><strong>操作静态属性：</strong></p>
<ul>
<li>get(当前运行时类.class) 或 get(null)</li>
<li>set(当前运行时类.class, Object value) 或 set(null, Object value)</li>
</ul>
<h3 id="操作运行时类中指定的方法"><a href="#操作运行时类中指定的方法" class="headerlink" title="操作运行时类中指定的方法"></a>操作运行时类中指定的方法</h3><ul>
<li>Method getDeclaredMethod(String methodName, Class&lt;?&gt;… parameterTypes)：获取指定的某个方法</li>
<li>setAccessible(true)：设置当前方法可访问</li>
<li>Object invoke(Object obj, Object… args)：调用获取到的指定的某个方法<ul>
<li>第一个参数：方法的调用者(当前运行类的某个实例)</li>
<li>第二个参数：对应的形参列表</li>
</ul>
</li>
<li>invoke 的返回值即为对应类中调用的方法的返回值</li>
</ul>
<p><strong>调用静态方法：</strong></p>
<ul>
<li>invoke(当前运行时类.class) 或 invoke(null)</li>
</ul>
<h3 id="操作运行时类中指定的构造器"><a href="#操作运行时类中指定的构造器" class="headerlink" title="操作运行时类中指定的构造器"></a>操作运行时类中指定的构造器</h3><ul>
<li>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)：获取指定的构造器<ul>
<li>参数指明构造器的参数列表</li>
</ul>
</li>
<li>setAccessible(true)：设置当前构造器可访问</li>
<li>T newInstance(Object … initargs)：调用此构造器创建运行时类的对象</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="代理模式的原理"><a href="#代理模式的原理" class="headerlink" title="代理模式的原理"></a>代理模式的原理</h3><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象，任何对原始对象的调用都要通过代理类。代理对象决定是否以及何时将方法调用转到原始对象上</p>
<p>静态代理：代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展，同时每一个代理类只能为一个接口服务，这样程序开发中必然产生过多的代理</p>
<p>动态代理：指通过代理类来调用其他对象的方法，并且是在程序运行时根据需要动态的创建目标类的代理对象</p>
<ul>
<li>动态代理的使用场合：<ul>
<li>调式</li>
<li>远程方法调用</li>
</ul>
</li>
<li>动态代理相对于静态代理的优点<ul>
<li>抽象角色(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样可以更加灵活和统一的处理众多的方法</li>
</ul>
</li>
</ul>
<p><strong>实现动态代理需要解决的问题：</strong></p>
<ul>
<li>根据加载到内存中的被代理类，动态的创建一个代理类及其对象</li>
<li>当通过代理类的对象调用方法时，动态的去调用被代理类中的同名方法</li>
</ul>
<p><strong>实现动态代理用到的方法：</strong></p>
<ul>
<li>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
<li>实现 InvocationHandler 接口</li>
</ul>
<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>可以把 Lambda 表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)</p>
<ul>
<li>更简洁、更灵活 —— 更紧凑的代码风格</li>
</ul>
<h3 id="Lambda-表达式的使用"><a href="#Lambda-表达式的使用" class="headerlink" title="Lambda 表达式的使用"></a>Lambda 表达式的使用</h3><p><strong>格式：</strong></p>
<ul>
<li>-&gt;：lambda 操作符或箭头操作符</li>
<li>-&gt; 左侧：lambda 形参列表<ul>
<li>即接口中的抽象方法的形参列表</li>
</ul>
</li>
<li>-&gt; 右侧：lambda 体<ul>
<li>即重写的抽象方法的方法体</li>
</ul>
</li>
</ul>
<p><strong>Lambda 表达式的表现形式：</strong></p>
<p>-&gt; 左侧：lambda 形参列表的参数类型可以省略(类型推断)：如果 lambda 形参列表只有一个参数，则 () 也可以省略</p>
<p>-&gt; 右侧：lambda 体应该使用一对 {} 包裹；若 lambda 体只有一条执行语句(可能是 return 语句)，则可以省略(需要同时)这一对 {}  和 return</p>
<ul>
<li>无参，无返回值<ul>
<li>Runnable r = () -&gt; System.out.println(1);</li>
</ul>
</li>
<li>Lambda 需要一个参数，但没有返回值<ul>
<li>Consumer&lt;String&gt; con = (String str) -&gt; System.out.println(str);</li>
</ul>
</li>
<li>数据类型可省略(“类型推断”：可由编译器推断得出)<ul>
<li>Consumer&lt;String&gt; con = (str) -&gt; System.out.println(str);</li>
</ul>
</li>
<li>Lambda 若只需要一个参数时，参数的 () 可以省略<ul>
<li>Consumer&lt;String&gt; con = str -&gt; System.out.println(str);</li>
</ul>
</li>
<li>Lambda 需要两个或以上的参数，多条执行语句，并且有返回值<ul>
<li>Comparator&lt;Integer&gt; com = (x, y) -&gt; {System.out.println(x, y); return Integer.compare(x, y);};</li>
</ul>
</li>
<li>当 Lambda 体只有一条语句时，return 与 {} 若存在则都可以省略(return 与 {} 需要同时省略)<ul>
<li>Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</li>
</ul>
</li>
</ul>
<p><strong>Lambda 表达式的本质：</strong>作为函数式接口的实例</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>只包含一个抽象方法的接口，称为函数式接口</p>
<ul>
<li>可以通过 Lambda 表达式来创建该接口的对象<ul>
<li>若 Lambda 表达式抛出受检异常(非运行时异常)该异常需要在目标接口的抽象方法上进行声明</li>
</ul>
</li>
<li>可以在一个接口上使用 @FunctionInterface 注解，可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口</li>
</ul>
<h3 id="如何理解函数式接口"><a href="#如何理解函数式接口" class="headerlink" title="如何理解函数式接口"></a>如何理解函数式接口</h3><p>Java 不但可以支持 OOP 还可以支持 OOF(面向函数编程)</p>
<p>在函数式编程语言中 Lambda 表达式的类型是函数，但在 Java8 中，Lambda 表达式是对象，它们必须依附于一类特别的对象类型 —— 函数式接口</p>
<ul>
<li>Java8 中，Lambda 表达式就是一个函数式接口的实例(只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示)<ul>
<li>匿名实现类可以用 Lambda 表达式来写</li>
</ul>
</li>
</ul>
<p><strong>Java 内置四大核心函数式接口：</strong></p>
<table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">参数类型</th>
<th align="center">返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Consumer&lt;T&gt;<br>消费型接口</td>
<td align="center">T</td>
<td align="center">void</td>
<td>对类型为 T 的对象应用操作，包含方法：void accept&lt;T t&gt;</td>
</tr>
<tr>
<td align="center">Supplier&lt;T&gt;<br>供给型接口</td>
<td align="center">无</td>
<td align="center">T</td>
<td>返回类型为 T 的对象，包含方法：T get()</td>
</tr>
<tr>
<td align="center">Function&lt;T,R&gt;<br>函数型接口</td>
<td align="center">T</td>
<td align="center">R</td>
<td>对类型为 T 的对下对象应用操作，并返回结果。<br>结果是 R 类型的对象。包含方法：R apply(T t)</td>
</tr>
<tr>
<td align="center">Predicate&lt;T&gt;<br>断定型接口</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td>确定类型为 T 的对象是否满足某约束，并返回 boolean 值。<br>包含方法：boolean test(T t)</td>
</tr>
</tbody></table>
<h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给 Lambda 体的操作已经有实现的方法时，可以使用方法引用</p>
<ul>
<li><p>本质上就是 Lambda 表达式，而 Lambda 表达式是函数式接口的实例，因此方法引用也是函数式接口的实例</p>
</li>
<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</p>
</li>
<li><p>格式：使用操作符 “::” 将类(或对象)与方法名分隔开表示</p>
</li>
<li><p>常见情况：</p>
<ul>
<li>对象 :: 非静态方法<ul>
<li>对应 Consumer 中的 void accept(T t)</li>
</ul>
</li>
<li>类 :: 静态方法<ul>
<li>对应 Comparator 中的 int compare(T t1, T t2)<br>Integer 中的 int compare(T t1, T t2)</li>
</ul>
</li>
<li>类 :: 非静态方法<ul>
<li>对应 Comparator 中的 int compare(T t1, T t2)<br>String 中的 int t1.compareTo(t2)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>与方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致，抽象方法的返回值类型即为构造器所属的类的类型</p>
<ul>
<li>Supplier 中的 T get()</li>
<li>Function 中的 R apply(T t)</li>
<li>BiFunction 中的 R apply(T t, U u)</li>
</ul>
<p><strong>数组引用：</strong>把数组看作是一个特殊的类，则写法与构造器引用一致</p>
<h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p><strong>Stream 与集合：</strong></p>
<ul>
<li><p>Stream 关注的是数据的运算 —— 与 CPU 相关</p>
</li>
<li><p>集合关注的是数据的存储 —— 与内存相关</p>
</li>
</ul>
<p><strong>Stream 的特点：</strong></p>
<ul>
<li>Stream 自己不存储数据</li>
<li>不会改变原对象，而是返回一个持有结果的新 Stream</li>
<li>Stream 操作是延迟执行的，将等到需要结果时才执行</li>
</ul>
<p><strong>Stream 执行流程：</strong></p>
<ul>
<li>Stream 的实例化</li>
<li>中间操作</li>
<li>终止操作</li>
<li>说明：<ul>
<li>一个中间操作链对数据源的数据进行处理</li>
<li>一旦执行终止操作，就执行中间操作链并产生结果。之后不会再被使用</li>
</ul>
</li>
</ul>
<h2 id="Stream-的实例化"><a href="#Stream-的实例化" class="headerlink" title="Stream 的实例化"></a>Stream 的实例化</h2><ul>
<li>通过集合：Java8 中 Collection 接口被扩展，提供了两个获取流的方法<ul>
<li>default Stream&lt;E&gt; stream()：返回一个顺序流(串行流)</li>
<li>default Stream&lt;E&gt; parallelStream()：返回一个并行流</li>
</ul>
</li>
<li>通过数组：Java8 中 Arrays 的静态方法 stream() 可以获取数组流<ul>
<li>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)：返回一个流</li>
<li>重载形式，能够处理对应基本类型的数组<ul>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
</li>
</ul>
</li>
<li>通过 Stream 的 of() 方法：可以调用 Stream 类静态方法 of() 通过显式值创建一个流。可以接收任意数量的参数<ul>
<li>public static&lt;T&gt; Stream&lt;T&gt; of(T… value)：返回一个流</li>
</ul>
</li>
<li>创建无限流：可以使用静态方法 Stream.iterate() 和 Stream.generate() 创建无限流<ul>
<li>迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</li>
<li>生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</li>
</ul>
</li>
</ul>
<h2 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为 “惰性求值”</p>
<ul>
<li><strong>筛选与切片：</strong><ul>
<li>filter(Predicate p)：接收 Lambda，从流中排除某些元素</li>
<li>distinct()：筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</li>
<li>limit(long maxSize)：阶段流，使其元素不超过给定数量</li>
<li>skip(long n)：跳过元素，返回一个丢弃了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</li>
</ul>
</li>
<li><strong>映射：</strong><ul>
<li>map(Function f)：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li>
<li>map ToDouble(ToDoubleFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream</li>
<li>map ToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream</li>
<li>map ToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream</li>
<li>flatMap(Function f)：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</li>
</ul>
</li>
<li><strong>排序：</strong><ul>
<li>sorted()：产生一个新流，其中按自然排序排序</li>
<li>sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</li>
</ul>
</li>
</ul>
<h2 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a>Stream 的终止操作</h2><p>终止操作会从流水线生成结果。其结果可以是任何不是流的值(List、Integer，甚至是 void)</p>
<p><strong>流进行了终止操作后不能再次使用</strong></p>
<ul>
<li><strong>匹配与查找：</strong><ul>
<li>allMatch(Predicate p)：检查是否匹配所有元素</li>
<li>anyMatch(Predicate p)：检查是否至少匹配一个元素</li>
<li>noneMatch(Predicate p)：检查是否没有匹配所有元素</li>
<li>findFirst()：返回第一个元素</li>
<li>findAny()：返回当前流中的任意元素</li>
<li>count()：返回流中元素总数</li>
<li>max(Comparator c)：返回流中最大值</li>
<li>min(Comparator c)：返回流中最小值</li>
<li>forEach(Consumer c)：内部迭代(使用 Collection 接口需要自定义迭代称为外部迭代)</li>
</ul>
</li>
<li><strong>规约：</strong><ul>
<li>reduce(T iden, BinaryOperator b)：可以将流中元素反复结合起来得到一个值，返回 T</li>
<li>reduce(BinaryOperator b)：可以将流中元素反复结合起来得到一个值，返回 Optional&lt;T&gt;</li>
<li>map 和 reduce 的连接通常称为 map-reduce 模式</li>
</ul>
</li>
<li><strong>收集：</strong><ul>
<li>collect(Collector c)：将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法</li>
<li>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)</li>
<li>Collectors 实用类提供了一些静态方法，可以方便地创建常见收集器实例<ul>
<li>toList：把流中元素收集到 List<ul>
<li>返回值类型：List&lt;T&gt;</li>
</ul>
</li>
<li>toSet：把流中元素收集到 List<ul>
<li>返回值类型：Set&lt;T&gt;</li>
</ul>
</li>
<li>toCollection：把流中元素收集到创建的集合<ul>
<li>返回值类型：Collection&lt;T&gt;</li>
</ul>
</li>
<li>counting：计算流中元素的个数<ul>
<li>返回值类型：Long</li>
</ul>
</li>
<li>summingInt：对流中元素的 Integer 属性求和<ul>
<li>返回值类型：Integer</li>
</ul>
</li>
<li>averagingInt：计算流中元素 Integer 属性的平均值<ul>
<li>返回值类型：Double</li>
</ul>
</li>
<li>summarizingInt：收集流中 Integer 属性的统计值(如平均值)<ul>
<li>返回值类型：IntSummaryStatistics</li>
</ul>
</li>
<li>joining：连接流中每个字符串<ul>
<li>返回值类型：String</li>
</ul>
</li>
<li>maxBy：根据比较器选择最大值<ul>
<li>返回值类型：Optional&lt;T&gt;</li>
</ul>
</li>
<li>minBy：根据比较器选择最小值<ul>
<li>返回值类型：Optional&lt;T&gt;</li>
</ul>
</li>
<li>reducing：从一个作为累加器的初始值开始，利用 BinaryOperator 与流中元素逐个结合，从而归约成单个值<ul>
<li>返回值类型：归约产生的类型</li>
</ul>
</li>
<li>collectionAndThen：包裹另一个收集器，对其结果转换函数<ul>
<li>返回值类型：转换函数返回的类型</li>
</ul>
</li>
<li>groupingBy：根据某属性值对流分组，属性为 K，结果为 V<ul>
<li>返回值类型：Map&lt;K, List&lt;T&gt;&gt;</li>
</ul>
</li>
<li>partitioningBy：根据 true 或 false 进行分区<ul>
<li>返回值类型：Map&lt;Boolean, List&lt;T&gt;&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，它可以保存类型 T 的值，代表这个值存在。或者仅仅保存 null，表示这个值不存在</p>
<ul>
<li>之前使用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念，并且可以避免空指针</li>
</ul>
<p><strong>创建 Optional 类对象的方法：</strong></p>
<ul>
<li>Optional.of(T t)：创建一个 Optional 实例，t 必须非空</li>
<li>Optional.empty()：创建一个空的 Optional 实例</li>
<li>Optional.ofNullable(T t)：创建一个 Optional 实例，t 可以为 null</li>
</ul>
<p><strong>判断 Optional 容器中是否包含对象：</strong></p>
<ul>
<li>boolean isPresent()：判断是否包含对象</li>
<li>void ifPresent(Consumer&lt;? super T&gt; consumer)：如果有值，就执行 Consumer 接口的实现代码，并且该值会作为参数传给它</li>
</ul>
<p><strong>获取 Optional 容器的对象：</strong></p>
<ul>
<li>T get()：如果调用对象包含值，返回该值，否则抛出异常</li>
<li>T orElse(T other)：如果调用对象包含值，返回该值，否则返回指定的 other 对象</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other)：如果调用对象包含值，返回该值，否则返回 Supplier 接口实现提供的对象</li>
<li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：如果调用对象包含值，返回该值，否则抛出由 Supplier 接口实现提供的异常</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
